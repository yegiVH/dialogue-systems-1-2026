{"version":3,"file":"xstate-graph.umd.min.js","sources":["../../src/Mailbox.ts","../../src/constants.ts","../../src/dev/index.ts","../../src/eventUtils.ts","../../src/reportUnhandledError.ts","../../src/symbolObservable.ts","../../src/utils.ts","../../src/system.ts","../../src/createActor.ts","../../src/actions/cancel.ts","../../src/actions/spawnChild.ts","../../src/actions/stopChild.ts","../../src/guards.ts","../../src/stateUtils.ts","../../src/actions/raise.ts","../../src/State.ts","../../src/spawn.ts","../../src/actions/assign.ts","../../src/actors/index.ts","../../src/actors/transition.ts","../../src/memo.ts","../../src/StateNode.ts","../../src/StateMachine.ts","../../src/graph/utils.ts","../../src/graph/deduplicatePaths.ts","../../src/graph/pathGenerators.ts","../../src/graph/validateMachine.ts","../../src/graph/TestModel.ts","../../src/graph/actorScope.ts","../../src/graph/graph.ts","../../src/graph/adjacency.ts","../../src/graph/alterPath.ts","../../src/graph/pathFromEvents.ts","../../src/graph/shortestPaths.ts","../../src/graph/simplePaths.ts"],"sourcesContent":["interface MailboxItem<T> {\n  value: T;\n  next: MailboxItem<T> | null;\n}\n\nexport class Mailbox<T> {\n  private _active: boolean = false;\n  private _current: MailboxItem<T> | null = null;\n  private _last: MailboxItem<T> | null = null;\n\n  constructor(private _process: (ev: T) => void) {}\n\n  public start() {\n    this._active = true;\n    this.flush();\n  }\n\n  public clear(): void {\n    // we can't set _current to null because we might be currently processing\n    // and enqueue following clear shouldn't start processing the enqueued item immediately\n    if (this._current) {\n      this._current.next = null;\n      this._last = this._current;\n    }\n  }\n\n  public enqueue(event: T): void {\n    const enqueued = {\n      value: event,\n      next: null\n    };\n\n    if (this._current) {\n      this._last!.next = enqueued;\n      this._last = enqueued;\n      return;\n    }\n\n    this._current = enqueued;\n    this._last = enqueued;\n\n    if (this._active) {\n      this.flush();\n    }\n  }\n\n  private flush() {\n    while (this._current) {\n      // atm the given _process is responsible for implementing proper try/catch handling\n      // we assume here that this won't throw in a way that can affect this mailbox\n      const consumed = this._current;\n      this._process(consumed.value);\n      this._current = consumed.next;\n    }\n    this._last = null;\n  }\n}\n","export const STATE_DELIMITER = '.';\nexport const TARGETLESS_KEY = '';\nexport const NULL_EVENT = '';\nexport const STATE_IDENTIFIER = '#';\nexport const WILDCARD = '*';\nexport const XSTATE_INIT = 'xstate.init';\nexport const XSTATE_ERROR = 'xstate.error';\nexport const XSTATE_STOP = 'xstate.stop';\n","import isDevelopment from '#is-development';\nimport { AnyActor, DevToolsAdapter } from '../types.ts';\n\ninterface DevInterface {\n  services: Set<AnyActor>;\n  register(service: AnyActor): void;\n  onRegister(listener: ServiceListener): void;\n}\ntype ServiceListener = (service: AnyActor) => void;\n\nexport interface XStateDevInterface {\n  register: (service: AnyActor) => void;\n  unregister: (service: AnyActor) => void;\n  onRegister: (listener: ServiceListener) => {\n    unsubscribe: () => void;\n  };\n  services: Set<AnyActor>;\n}\n\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nexport function getGlobal(): typeof globalThis | undefined {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  if (isDevelopment) {\n    console.warn(\n      'XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues'\n    );\n  }\n}\n\nfunction getDevTools(): DevInterface | undefined {\n  const w = getGlobal();\n  if ((w as any).__xstate__) {\n    return (w as any).__xstate__;\n  }\n\n  return undefined;\n}\n\nexport function registerService(service: AnyActor) {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const devTools = getDevTools();\n\n  if (devTools) {\n    devTools.register(service);\n  }\n}\n\nexport const devToolsAdapter: DevToolsAdapter = (service) => {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const devTools = getDevTools();\n\n  if (devTools) {\n    devTools.register(service);\n  }\n};\n","import { XSTATE_INIT } from './constants.ts';\nimport { DoneActorEvent, DoneStateEvent, ErrorActorEvent } from './types.ts';\n\n/**\n * Returns an event that represents an implicit event that is sent after the\n * specified `delay`.\n *\n * @param delayRef The delay in milliseconds\n * @param id The state node ID where this event is handled\n */\nexport function createAfterEvent(delayRef: number | string, id: string) {\n  return { type: `xstate.after.${delayRef}.${id}` } as const;\n}\n\n/**\n * Returns an event that represents that a final state node has been reached in\n * the parent state node.\n *\n * @param id The final state node's parent state node `id`\n * @param output The data to pass into the event\n */\nexport function createDoneStateEvent(\n  id: string,\n  output?: unknown\n): DoneStateEvent {\n  return {\n    type: `xstate.done.state.${id}`,\n    output\n  };\n}\n\n/**\n * Returns an event that represents that an invoked service has terminated.\n *\n * An invoked service is terminated when it has reached a top-level final state\n * node, but not when it is canceled.\n *\n * @param invokeId The invoked service ID\n * @param output The data to pass into the event\n */\nexport function createDoneActorEvent(\n  invokeId: string,\n  output?: unknown\n): DoneActorEvent {\n  return {\n    type: `xstate.done.actor.${invokeId}`,\n    output,\n    actorId: invokeId\n  };\n}\n\nexport function createErrorActorEvent(\n  id: string,\n  error?: unknown\n): ErrorActorEvent {\n  return { type: `xstate.error.actor.${id}`, error, actorId: id };\n}\n\nexport function createInitEvent(input: unknown) {\n  return { type: XSTATE_INIT, input } as const;\n}\n","/**\n * This function makes sure that unhandled errors are thrown in a separate\n * macrotask. It allows those errors to be detected by global error handlers and\n * reported to bug tracking services without interrupting our own stack of\n * execution.\n *\n * @param err Error to be thrown\n */\nexport function reportUnhandledError(err: unknown) {\n  setTimeout(() => {\n    throw err;\n  });\n}\n","export const symbolObservable: typeof Symbol.observable = (() =>\n  (typeof Symbol === 'function' && Symbol.observable) ||\n  '@@observable')() as any;\n","import isDevelopment from '#is-development';\nimport { isMachineSnapshot } from './State.ts';\nimport type { StateNode } from './StateNode.ts';\nimport { TARGETLESS_KEY, WILDCARD } from './constants.ts';\nimport type {\n  AnyActorRef,\n  AnyEventObject,\n  AnyMachineSnapshot,\n  AnyStateMachine,\n  AnyTransitionConfig,\n  ErrorActorEvent,\n  EventObject,\n  InvokeConfig,\n  MachineContext,\n  Mapper,\n  NonReducibleUnknown,\n  Observer,\n  SingleOrArray,\n  StateLike,\n  StateValue,\n  TransitionConfigTarget\n} from './types.ts';\n\nexport function matchesState(\n  parentStateId: StateValue,\n  childStateId: StateValue\n): boolean {\n  const parentStateValue = toStateValue(parentStateId);\n  const childStateValue = toStateValue(childStateId);\n\n  if (typeof childStateValue === 'string') {\n    if (typeof parentStateValue === 'string') {\n      return childStateValue === parentStateValue;\n    }\n\n    // Parent more specific than child\n    return false;\n  }\n\n  if (typeof parentStateValue === 'string') {\n    return parentStateValue in childStateValue;\n  }\n\n  return Object.keys(parentStateValue).every((key) => {\n    if (!(key in childStateValue)) {\n      return false;\n    }\n\n    return matchesState(parentStateValue[key]!, childStateValue[key]!);\n  });\n}\n\nexport function toStatePath(stateId: string | string[]): string[] {\n  if (isArray(stateId)) {\n    return stateId;\n  }\n\n  const result: string[] = [];\n  let segment = '';\n\n  for (let i = 0; i < stateId.length; i++) {\n    const char = stateId.charCodeAt(i);\n    switch (char) {\n      // \\\n      case 92:\n        // consume the next character\n        segment += stateId[i + 1];\n        // and skip over it\n        i++;\n        continue;\n      // .\n      case 46:\n        result.push(segment);\n        segment = '';\n        continue;\n    }\n    segment += stateId[i];\n  }\n\n  result.push(segment);\n\n  return result;\n}\n\nfunction toStateValue(stateValue: StateLike<any> | StateValue): StateValue {\n  if (isMachineSnapshot(stateValue)) {\n    return stateValue.value;\n  }\n\n  if (typeof stateValue !== 'string') {\n    return stateValue as StateValue;\n  }\n\n  const statePath = toStatePath(stateValue);\n\n  return pathToStateValue(statePath);\n}\n\nexport function pathToStateValue(statePath: string[]): StateValue {\n  if (statePath.length === 1) {\n    return statePath[0];\n  }\n\n  const value: StateValue = {};\n  let marker = value;\n\n  for (let i = 0; i < statePath.length - 1; i++) {\n    if (i === statePath.length - 2) {\n      marker[statePath[i]] = statePath[i + 1];\n    } else {\n      const previous = marker;\n      marker = {};\n      previous[statePath[i]] = marker;\n    }\n  }\n\n  return value;\n}\n\nexport function mapValues<P, O extends Record<string, unknown>>(\n  collection: O,\n  iteratee: (item: O[keyof O], key: keyof O, collection: O, i: number) => P\n): { [key in keyof O]: P };\nexport function mapValues(\n  collection: Record<string, unknown>,\n  iteratee: (\n    item: unknown,\n    key: string,\n    collection: Record<string, unknown>,\n    i: number\n  ) => unknown\n) {\n  const result: Record<string, unknown> = {};\n\n  const collectionKeys = Object.keys(collection);\n  for (let i = 0; i < collectionKeys.length; i++) {\n    const key = collectionKeys[i];\n    result[key] = iteratee(collection[key], key, collection, i);\n  }\n\n  return result;\n}\n\nfunction toArrayStrict<T>(value: readonly T[] | T): readonly T[] {\n  if (isArray(value)) {\n    return value;\n  }\n  return [value];\n}\n\nexport function toArray<T>(value: readonly T[] | T | undefined): readonly T[] {\n  if (value === undefined) {\n    return [];\n  }\n  return toArrayStrict(value);\n}\n\nexport function resolveOutput<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n>(\n  mapper:\n    | Mapper<TContext, TExpressionEvent, unknown, EventObject>\n    | NonReducibleUnknown,\n  context: TContext,\n  event: TExpressionEvent,\n  self: AnyActorRef\n): unknown {\n  if (typeof mapper === 'function') {\n    return mapper({ context, event, self });\n  }\n\n  if (\n    isDevelopment &&\n    !!mapper &&\n    typeof mapper === 'object' &&\n    Object.values(mapper).some((val) => typeof val === 'function')\n  ) {\n    console.warn(\n      `Dynamically mapping values to individual properties is deprecated. Use a single function that returns the mapped object instead.\\nFound object containing properties whose values are possibly mapping functions: ${Object.entries(\n        mapper\n      )\n        .filter(([, value]) => typeof value === 'function')\n        .map(\n          ([key, value]) =>\n            `\\n - ${key}: ${(value as () => any)\n              .toString()\n              .replace(/\\n\\s*/g, '')}`\n        )\n        .join('')}`\n    );\n  }\n\n  return mapper;\n}\n\nfunction isArray(value: any): value is readonly any[] {\n  return Array.isArray(value);\n}\n\nexport function isErrorActorEvent(\n  event: AnyEventObject\n): event is ErrorActorEvent {\n  return event.type.startsWith('xstate.error.actor');\n}\n\nexport function toTransitionConfigArray(\n  configLike: SingleOrArray<AnyTransitionConfig | TransitionConfigTarget>\n): Array<AnyTransitionConfig> {\n  return toArrayStrict(configLike).map((transitionLike) => {\n    if (\n      typeof transitionLike === 'undefined' ||\n      typeof transitionLike === 'string'\n    ) {\n      return { target: transitionLike };\n    }\n\n    return transitionLike;\n  });\n}\n\nexport function normalizeTarget<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  target: SingleOrArray<string | StateNode<TContext, TEvent>> | undefined\n): ReadonlyArray<string | StateNode<TContext, TEvent>> | undefined {\n  if (target === undefined || target === TARGETLESS_KEY) {\n    return undefined;\n  }\n  return toArray(target);\n}\n\nexport function toObserver<T>(\n  nextHandler?: Observer<T> | ((value: T) => void),\n  errorHandler?: (error: any) => void,\n  completionHandler?: () => void\n): Observer<T> {\n  const isObserver = typeof nextHandler === 'object';\n  const self = isObserver ? nextHandler : undefined;\n\n  return {\n    next: (isObserver ? nextHandler.next : nextHandler)?.bind(self),\n    error: (isObserver ? nextHandler.error : errorHandler)?.bind(self),\n    complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(\n      self\n    )\n  };\n}\n\nexport function createInvokeId(stateNodeId: string, index: number): string {\n  return `${index}.${stateNodeId}`;\n}\n\nexport function resolveReferencedActor(machine: AnyStateMachine, src: string) {\n  const match = src.match(/^xstate\\.invoke\\.(\\d+)\\.(.*)/)!;\n  if (!match) {\n    return machine.implementations.actors[src];\n  }\n  const [, indexStr, nodeId] = match;\n  const node = machine.getStateNodeById(nodeId);\n  const invokeConfig = node.config.invoke!;\n  return (\n    Array.isArray(invokeConfig)\n      ? invokeConfig[indexStr as any]\n      : (invokeConfig as InvokeConfig<\n          any,\n          any,\n          any,\n          any,\n          any,\n          any,\n          any, // TEmitted\n          any // TMeta\n        >)\n  ).src;\n}\n\nexport function getAllOwnEventDescriptors(snapshot: AnyMachineSnapshot) {\n  return [...new Set([...snapshot._nodes.flatMap((sn) => sn.ownEvents)])];\n}\n\n/**\n * Checks if an event type matches an event descriptor, supporting wildcards.\n * Event descriptors can be:\n *\n * - Exact matches: \"event.type\"\n * - Wildcard: \"*\"\n * - Partial matches: \"event.*\"\n *\n * @param eventType - The actual event type string\n * @param descriptor - The event descriptor to match against\n * @returns True if the event type matches the descriptor\n */\nexport function matchesEventDescriptor(\n  eventType: string,\n  descriptor: string\n): boolean {\n  if (descriptor === eventType) {\n    return true;\n  }\n\n  if (descriptor === WILDCARD) {\n    return true;\n  }\n\n  if (!descriptor.endsWith('.*')) {\n    return false;\n  }\n\n  if (isDevelopment && /.*\\*.+/.test(descriptor)) {\n    console.warn(\n      `Wildcards can only be the last token of an event descriptor (e.g., \"event.*\") or the entire event descriptor (\"*\"). Check the \"${descriptor}\" event.`\n    );\n  }\n\n  const partialEventTokens = descriptor.split('.');\n  const eventTokens = eventType.split('.');\n\n  for (\n    let tokenIndex = 0;\n    tokenIndex < partialEventTokens.length;\n    tokenIndex++\n  ) {\n    const partialEventToken = partialEventTokens[tokenIndex];\n    const eventToken = eventTokens[tokenIndex];\n\n    if (partialEventToken === '*') {\n      const isLastToken = tokenIndex === partialEventTokens.length - 1;\n\n      if (isDevelopment && !isLastToken) {\n        console.warn(\n          `Infix wildcards in transition events are not allowed. Check the \"${descriptor}\" transition.`\n        );\n      }\n\n      return isLastToken;\n    }\n\n    if (partialEventToken !== eventToken) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import { InspectionEvent } from './inspection.ts';\nimport {\n  AnyEventObject,\n  ActorSystemInfo,\n  AnyActorRef,\n  Observer,\n  HomomorphicOmit,\n  EventObject,\n  Subscription\n} from './types.ts';\nimport { toObserver } from './utils.ts';\n\ninterface ScheduledEvent {\n  id: string;\n  event: EventObject;\n  startedAt: number; // timestamp\n  delay: number;\n  source: AnyActorRef;\n  target: AnyActorRef;\n}\n\nexport interface Clock {\n  setTimeout(fn: (...args: any[]) => void, timeout: number): any;\n  clearTimeout(id: any): void;\n}\n\ninterface Scheduler {\n  schedule(\n    source: AnyActorRef,\n    target: AnyActorRef,\n    event: EventObject,\n    delay: number,\n    id: string | undefined\n  ): void;\n  cancel(source: AnyActorRef, id: string): void;\n  cancelAll(actorRef: AnyActorRef): void;\n}\n\ntype ScheduledEventId = string & { __scheduledEventId: never };\n\nfunction createScheduledEventId(\n  actorRef: AnyActorRef,\n  id: string\n): ScheduledEventId {\n  return `${actorRef.sessionId}.${id}` as ScheduledEventId;\n}\n\nexport interface ActorSystem<T extends ActorSystemInfo> {\n  /** @internal */\n  _bookId: () => string;\n  /** @internal */\n  _register: (sessionId: string, actorRef: AnyActorRef) => string;\n  /** @internal */\n  _unregister: (actorRef: AnyActorRef) => void;\n  /** @internal */\n  _set: <K extends keyof T['actors']>(key: K, actorRef: T['actors'][K]) => void;\n  get: <K extends keyof T['actors']>(key: K) => T['actors'][K] | undefined;\n  getAll: () => Partial<T['actors']>;\n\n  inspect: (\n    observer:\n      | Observer<InspectionEvent>\n      | ((inspectionEvent: InspectionEvent) => void)\n  ) => Subscription;\n  /** @internal */\n  _sendInspectionEvent: (\n    event: HomomorphicOmit<InspectionEvent, 'rootId'>\n  ) => void;\n  /** @internal */\n  _relay: (\n    source: AnyActorRef | undefined,\n    target: AnyActorRef,\n    event: AnyEventObject\n  ) => void;\n  scheduler: Scheduler;\n  getSnapshot: () => {\n    _scheduledEvents: Record<string, ScheduledEvent>;\n  };\n  /** @internal */\n  _snapshot: {\n    _scheduledEvents: Record<ScheduledEventId, ScheduledEvent>;\n  };\n  start: () => void;\n  _clock: Clock;\n  _logger: (...args: any[]) => void;\n}\n\nexport type AnyActorSystem = ActorSystem<any>;\n\nlet idCounter = 0;\nexport function createSystem<T extends ActorSystemInfo>(\n  rootActor: AnyActorRef,\n  options: {\n    clock: Clock;\n    logger: (...args: any[]) => void;\n    snapshot?: unknown;\n  }\n): ActorSystem<T> {\n  const children = new Map<string, AnyActorRef>();\n  const keyedActors = new Map<keyof T['actors'], AnyActorRef | undefined>();\n  const reverseKeyedActors = new WeakMap<AnyActorRef, keyof T['actors']>();\n  const inspectionObservers = new Set<Observer<InspectionEvent>>();\n  const timerMap: { [id: ScheduledEventId]: number } = {};\n  const { clock, logger } = options;\n\n  const scheduler: Scheduler = {\n    schedule: (\n      source,\n      target,\n      event,\n      delay,\n      id = Math.random().toString(36).slice(2)\n    ) => {\n      const scheduledEvent: ScheduledEvent = {\n        source,\n        target,\n        event,\n        delay,\n        id,\n        startedAt: Date.now()\n      };\n      const scheduledEventId = createScheduledEventId(source, id);\n      system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;\n\n      const timeout = clock.setTimeout(() => {\n        delete timerMap[scheduledEventId];\n        delete system._snapshot._scheduledEvents[scheduledEventId];\n\n        system._relay(source, target, event);\n      }, delay);\n\n      timerMap[scheduledEventId] = timeout;\n    },\n    cancel: (source, id: string) => {\n      const scheduledEventId = createScheduledEventId(source, id);\n      const timeout = timerMap[scheduledEventId];\n\n      delete timerMap[scheduledEventId];\n      delete system._snapshot._scheduledEvents[scheduledEventId];\n\n      if (timeout !== undefined) {\n        clock.clearTimeout(timeout);\n      }\n    },\n    cancelAll: (actorRef) => {\n      for (const scheduledEventId in system._snapshot._scheduledEvents) {\n        const scheduledEvent =\n          system._snapshot._scheduledEvents[\n            scheduledEventId as ScheduledEventId\n          ];\n        if (scheduledEvent.source === actorRef) {\n          scheduler.cancel(actorRef, scheduledEvent.id);\n        }\n      }\n    }\n  };\n  const sendInspectionEvent = (event: InspectionEvent) => {\n    if (!inspectionObservers.size) {\n      return;\n    }\n    const resolvedInspectionEvent: InspectionEvent = {\n      ...event,\n      rootId: rootActor.sessionId\n    };\n    inspectionObservers.forEach((observer) =>\n      observer.next?.(resolvedInspectionEvent)\n    );\n  };\n\n  const system: ActorSystem<T> = {\n    _snapshot: {\n      _scheduledEvents:\n        (options?.snapshot && (options.snapshot as any).scheduler) ?? {}\n    },\n    _bookId: () => `x:${idCounter++}`,\n    _register: (sessionId, actorRef) => {\n      children.set(sessionId, actorRef);\n      return sessionId;\n    },\n    _unregister: (actorRef) => {\n      children.delete(actorRef.sessionId);\n      const systemId = reverseKeyedActors.get(actorRef);\n\n      if (systemId !== undefined) {\n        keyedActors.delete(systemId);\n        reverseKeyedActors.delete(actorRef);\n      }\n    },\n    get: (systemId) => {\n      return keyedActors.get(systemId) as T['actors'][any] | undefined;\n    },\n    getAll: () => {\n      return Object.fromEntries(keyedActors.entries()) as Partial<T['actors']>;\n    },\n    _set: (systemId, actorRef) => {\n      const existing = keyedActors.get(systemId);\n      if (existing && existing !== actorRef) {\n        throw new Error(\n          `Actor with system ID '${systemId as string}' already exists.`\n        );\n      }\n\n      keyedActors.set(systemId, actorRef);\n      reverseKeyedActors.set(actorRef, systemId);\n    },\n    inspect: (observerOrFn) => {\n      const observer = toObserver(observerOrFn);\n      inspectionObservers.add(observer);\n\n      return {\n        unsubscribe() {\n          inspectionObservers.delete(observer);\n        }\n      };\n    },\n    _sendInspectionEvent: sendInspectionEvent as any,\n    _relay: (source, target, event) => {\n      system._sendInspectionEvent({\n        type: '@xstate.event',\n        sourceRef: source,\n        actorRef: target,\n        event\n      });\n\n      target._send(event);\n    },\n    scheduler,\n    getSnapshot: () => {\n      return {\n        _scheduledEvents: { ...system._snapshot._scheduledEvents }\n      };\n    },\n    start: () => {\n      const scheduledEvents = system._snapshot._scheduledEvents;\n      system._snapshot._scheduledEvents = {};\n      for (const scheduledId in scheduledEvents) {\n        const { source, target, event, delay, id } =\n          scheduledEvents[scheduledId as ScheduledEventId];\n        scheduler.schedule(source, target, event, delay, id);\n      }\n    },\n    _clock: clock,\n    _logger: logger\n  };\n\n  return system;\n}\n","import isDevelopment from '#is-development';\nimport { Mailbox } from './Mailbox.ts';\nimport { XSTATE_STOP } from './constants.ts';\nimport { devToolsAdapter } from './dev/index.ts';\nimport {\n  createDoneActorEvent,\n  createErrorActorEvent,\n  createInitEvent\n} from './eventUtils.ts';\nimport { reportUnhandledError } from './reportUnhandledError.ts';\nimport { symbolObservable } from './symbolObservable.ts';\nimport { AnyActorSystem, Clock, createSystem } from './system.ts';\n\n// those are needed to make JSDoc `@link` work properly\nimport type {\n  fromObservable,\n  fromEventObservable\n} from './actors/observable.ts';\nimport type { fromCallback } from './actors/callback.ts';\nimport type { fromPromise } from './actors/promise.ts';\nimport type { fromTransition } from './actors/transition.ts';\nimport type { createMachine } from './createMachine.ts';\n\nexport let executingCustomAction: boolean = false;\n\nimport type {\n  ActorScope,\n  AnyActorLogic,\n  AnyActorRef,\n  ConditionalRequired,\n  DoneActorEvent,\n  EmittedFrom,\n  EventFromLogic,\n  InputFrom,\n  IsNotNever,\n  Snapshot,\n  SnapshotFrom\n} from './types.ts';\nimport {\n  ActorOptions,\n  ActorRef,\n  EventObject,\n  InteropSubscribable,\n  Observer,\n  Subscription\n} from './types.ts';\nimport { toObserver } from './utils.ts';\n\nexport const $$ACTOR_TYPE = 1;\n\n// those values are currently used by @xstate/react directly so it's important to keep the assigned values in sync\nexport enum ProcessingStatus {\n  NotStarted = 0,\n  Running = 1,\n  Stopped = 2\n}\n\nconst defaultOptions = {\n  clock: {\n    setTimeout: (fn, ms) => {\n      return setTimeout(fn, ms);\n    },\n    clearTimeout: (id) => {\n      return clearTimeout(id);\n    }\n  } as Clock,\n  logger: console.log.bind(console),\n  devTools: false\n};\n\n/**\n * An Actor is a running process that can receive events, send events and change\n * its behavior based on the events it receives, which can cause effects outside\n * of the actor. When you run a state machine, it becomes an actor.\n */\nexport class Actor<TLogic extends AnyActorLogic>\n  implements\n    ActorRef<SnapshotFrom<TLogic>, EventFromLogic<TLogic>, EmittedFrom<TLogic>>\n{\n  /** The current internal state of the actor. */\n  private _snapshot!: SnapshotFrom<TLogic>;\n  /**\n   * The clock that is responsible for setting and clearing timeouts, such as\n   * delayed events and transitions.\n   */\n  public clock: Clock;\n  public options: Readonly<ActorOptions<TLogic>>;\n\n  /** The unique identifier for this actor relative to its parent. */\n  public id: string;\n\n  private mailbox: Mailbox<EventFromLogic<TLogic>> = new Mailbox(\n    this._process.bind(this)\n  );\n\n  private observers: Set<Observer<SnapshotFrom<TLogic>>> = new Set();\n  private eventListeners: Map<\n    string,\n    Set<(emittedEvent: EmittedFrom<TLogic>) => void>\n  > = new Map();\n  private logger: (...args: any[]) => void;\n\n  /** @internal */\n  public _processingStatus: ProcessingStatus = ProcessingStatus.NotStarted;\n\n  // Actor Ref\n  public _parent?: AnyActorRef;\n  /** @internal */\n  public _syncSnapshot?: boolean;\n  public ref: ActorRef<\n    SnapshotFrom<TLogic>,\n    EventFromLogic<TLogic>,\n    EmittedFrom<TLogic>\n  >;\n  // TODO: add typings for system\n  private _actorScope: ActorScope<\n    SnapshotFrom<TLogic>,\n    EventFromLogic<TLogic>,\n    AnyActorSystem,\n    EmittedFrom<TLogic>\n  >;\n\n  public systemId: string | undefined;\n\n  /** The globally unique process ID for this invocation. */\n  public sessionId: string;\n\n  /** The system to which this actor belongs. */\n  public system: AnyActorSystem;\n  private _doneEvent?: DoneActorEvent;\n\n  public src: string | AnyActorLogic;\n\n  /**\n   * Creates a new actor instance for the given logic with the provided options,\n   * if any.\n   *\n   * @param logic The logic to create an actor from\n   * @param options Actor options\n   */\n  constructor(\n    public logic: TLogic,\n    options?: ActorOptions<TLogic>\n  ) {\n    const resolvedOptions = {\n      ...defaultOptions,\n      ...options\n    };\n\n    const { clock, logger, parent, syncSnapshot, id, systemId, inspect } =\n      resolvedOptions;\n\n    this.system = parent\n      ? parent.system\n      : createSystem(this, {\n          clock,\n          logger\n        });\n\n    if (inspect && !parent) {\n      // Always inspect at the system-level\n      this.system.inspect(toObserver(inspect));\n    }\n\n    this.sessionId = this.system._bookId();\n    this.id = id ?? this.sessionId;\n    this.logger = options?.logger ?? this.system._logger;\n    this.clock = options?.clock ?? this.system._clock;\n    this._parent = parent;\n    this._syncSnapshot = syncSnapshot;\n    this.options = resolvedOptions as ActorOptions<TLogic> &\n      typeof defaultOptions;\n    this.src = resolvedOptions.src ?? logic;\n    this.ref = this;\n    this._actorScope = {\n      self: this,\n      id: this.id,\n      sessionId: this.sessionId,\n      logger: this.logger,\n      defer: (fn) => {\n        this._deferred.push(fn);\n      },\n      system: this.system,\n      stopChild: (child) => {\n        if (child._parent !== this) {\n          throw new Error(\n            `Cannot stop child actor ${child.id} of ${this.id} because it is not a child`\n          );\n        }\n        (child as any)._stop();\n      },\n      emit: (emittedEvent) => {\n        const listeners = this.eventListeners.get(emittedEvent.type);\n        const wildcardListener = this.eventListeners.get('*');\n        if (!listeners && !wildcardListener) {\n          return;\n        }\n        const allListeners = [\n          ...(listeners ? listeners.values() : []),\n          ...(wildcardListener ? wildcardListener.values() : [])\n        ];\n        for (const handler of allListeners) {\n          try {\n            handler(emittedEvent);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n      },\n      actionExecutor: (action) => {\n        const exec = () => {\n          this._actorScope.system._sendInspectionEvent({\n            type: '@xstate.action',\n            actorRef: this,\n            action: {\n              type: action.type,\n              params: action.params\n            }\n          });\n          if (!action.exec) {\n            return;\n          }\n          const saveExecutingCustomAction = executingCustomAction;\n          try {\n            executingCustomAction = true;\n            action.exec(action.info, action.params);\n          } finally {\n            executingCustomAction = saveExecutingCustomAction;\n          }\n        };\n        if (this._processingStatus === ProcessingStatus.Running) {\n          exec();\n        } else {\n          this._deferred.push(exec);\n        }\n      }\n    };\n\n    // Ensure that the send method is bound to this Actor instance\n    // if destructured\n    this.send = this.send.bind(this);\n\n    this.system._sendInspectionEvent({\n      type: '@xstate.actor',\n      actorRef: this\n    });\n\n    if (systemId) {\n      this.systemId = systemId;\n      this.system._set(systemId, this);\n    }\n\n    this._initState(options?.snapshot ?? options?.state);\n\n    if (systemId && (this._snapshot as any).status !== 'active') {\n      this.system._unregister(this);\n    }\n  }\n\n  private _initState(persistedState?: Snapshot<unknown>) {\n    try {\n      this._snapshot = persistedState\n        ? this.logic.restoreSnapshot\n          ? this.logic.restoreSnapshot(persistedState, this._actorScope)\n          : persistedState\n        : this.logic.getInitialSnapshot(this._actorScope, this.options?.input);\n    } catch (err) {\n      // if we get here then it means that we assign a value to this._snapshot that is not of the correct type\n      // we can't get the true `TSnapshot & { status: 'error'; }`, it's impossible\n      // so right now this is a lie of sorts\n      this._snapshot = {\n        status: 'error',\n        output: undefined,\n        error: err\n      } as any;\n    }\n  }\n\n  // array of functions to defer\n  private _deferred: Array<() => void> = [];\n\n  private update(snapshot: SnapshotFrom<TLogic>, event: EventObject): void {\n    // Update state\n    this._snapshot = snapshot;\n\n    // Execute deferred effects\n    let deferredFn: (typeof this._deferred)[number] | undefined;\n\n    while ((deferredFn = this._deferred.shift())) {\n      try {\n        deferredFn();\n      } catch (err) {\n        // this error can only be caught when executing *initial* actions\n        // it's the only time when we call actions provided by the user through those deferreds\n        // when the actor is already running we always execute them synchronously while transitioning\n        // no \"builtin deferred\" should actually throw an error since they are either safe\n        // or the control flow is passed through the mailbox and errors should be caught by the `_process` used by the mailbox\n        this._deferred.length = 0;\n        this._snapshot = {\n          ...(snapshot as any),\n          status: 'error',\n          error: err\n        };\n      }\n    }\n\n    switch ((this._snapshot as any).status) {\n      case 'active':\n        for (const observer of this.observers) {\n          try {\n            observer.next?.(snapshot);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n        break;\n      case 'done':\n        // next observers are meant to be notified about done snapshots\n        // this can be seen as something that is different from how observable work\n        // but with observables `complete` callback is called without any arguments\n        // it's more ergonomic for XState to treat a done snapshot as a \"next\" value\n        // and the completion event as something that is separate,\n        // something that merely follows emitting that done snapshot\n        for (const observer of this.observers) {\n          try {\n            observer.next?.(snapshot);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n\n        this._stopProcedure();\n        this._complete();\n        this._doneEvent = createDoneActorEvent(\n          this.id,\n          (this._snapshot as any).output\n        );\n        if (this._parent) {\n          this.system._relay(this, this._parent, this._doneEvent);\n        }\n\n        break;\n      case 'error':\n        this._error((this._snapshot as any).error);\n        break;\n    }\n    this.system._sendInspectionEvent({\n      type: '@xstate.snapshot',\n      actorRef: this,\n      event,\n      snapshot\n    });\n  }\n\n  /**\n   * Subscribe an observer to an actor’s snapshot values.\n   *\n   * @remarks\n   * The observer will receive the actor’s snapshot value when it is emitted.\n   * The observer can be:\n   *\n   * - A plain function that receives the latest snapshot, or\n   * - An observer object whose `.next(snapshot)` method receives the latest\n   *   snapshot\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as a plain function\n   * const subscription = actor.subscribe((snapshot) => {\n   *   console.log(snapshot);\n   * });\n   * ```\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as an object\n   * const subscription = actor.subscribe({\n   *   next(snapshot) {\n   *     console.log(snapshot);\n   *   },\n   *   error(err) {\n   *     // ...\n   *   },\n   *   complete() {\n   *     // ...\n   *   }\n   * });\n   * ```\n   *\n   * The return value of `actor.subscribe(observer)` is a subscription object\n   * that has an `.unsubscribe()` method. You can call\n   * `subscription.unsubscribe()` to unsubscribe the observer:\n   *\n   * @example\n   *\n   * ```ts\n   * const subscription = actor.subscribe((snapshot) => {\n   *   // ...\n   * });\n   *\n   * // Unsubscribe the observer\n   * subscription.unsubscribe();\n   * ```\n   *\n   * When the actor is stopped, all of its observers will automatically be\n   * unsubscribed.\n   *\n   * @param observer - Either a plain function that receives the latest\n   *   snapshot, or an observer object whose `.next(snapshot)` method receives\n   *   the latest snapshot\n   */\n  public subscribe(observer: Observer<SnapshotFrom<TLogic>>): Subscription;\n  public subscribe(\n    nextListener?: (snapshot: SnapshotFrom<TLogic>) => void,\n    errorListener?: (error: any) => void,\n    completeListener?: () => void\n  ): Subscription;\n  public subscribe(\n    nextListenerOrObserver?:\n      | ((snapshot: SnapshotFrom<TLogic>) => void)\n      | Observer<SnapshotFrom<TLogic>>,\n    errorListener?: (error: any) => void,\n    completeListener?: () => void\n  ): Subscription {\n    const observer = toObserver(\n      nextListenerOrObserver,\n      errorListener,\n      completeListener\n    );\n\n    if (this._processingStatus !== ProcessingStatus.Stopped) {\n      this.observers.add(observer);\n    } else {\n      switch ((this._snapshot as any).status) {\n        case 'done':\n          try {\n            observer.complete?.();\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n          break;\n        case 'error': {\n          const err = (this._snapshot as any).error;\n          if (!observer.error) {\n            reportUnhandledError(err);\n          } else {\n            try {\n              observer.error(err);\n            } catch (err) {\n              reportUnhandledError(err);\n            }\n          }\n          break;\n        }\n      }\n    }\n\n    return {\n      unsubscribe: () => {\n        this.observers.delete(observer);\n      }\n    };\n  }\n\n  public on<TType extends EmittedFrom<TLogic>['type'] | '*'>(\n    type: TType,\n    handler: (\n      emitted: EmittedFrom<TLogic> &\n        (TType extends '*' ? unknown : { type: TType })\n    ) => void\n  ): Subscription {\n    let listeners = this.eventListeners.get(type);\n    if (!listeners) {\n      listeners = new Set();\n      this.eventListeners.set(type, listeners);\n    }\n    const wrappedHandler = handler.bind(undefined);\n    listeners.add(wrappedHandler);\n\n    return {\n      unsubscribe: () => {\n        listeners.delete(wrappedHandler);\n      }\n    };\n  }\n\n  /** Starts the Actor from the initial state */\n  public start(): this {\n    if (this._processingStatus === ProcessingStatus.Running) {\n      // Do not restart the service if it is already started\n      return this;\n    }\n\n    if (this._syncSnapshot) {\n      this.subscribe({\n        next: (snapshot: Snapshot<unknown>) => {\n          if (snapshot.status === 'active') {\n            this.system._relay(this, this._parent!, {\n              type: `xstate.snapshot.${this.id}`,\n              snapshot\n            });\n          }\n        },\n        error: () => {}\n      });\n    }\n\n    this.system._register(this.sessionId, this);\n    if (this.systemId) {\n      this.system._set(this.systemId, this);\n    }\n    this._processingStatus = ProcessingStatus.Running;\n\n    // TODO: this isn't correct when rehydrating\n    const initEvent = createInitEvent(this.options.input);\n\n    this.system._sendInspectionEvent({\n      type: '@xstate.event',\n      sourceRef: this._parent,\n      actorRef: this,\n      event: initEvent\n    });\n\n    const status = (this._snapshot as any).status;\n\n    switch (status) {\n      case 'done':\n        // a state machine can be \"done\" upon initialization (it could reach a final state using initial microsteps)\n        // we still need to complete observers, flush deferreds etc\n        this.update(\n          this._snapshot,\n          initEvent as unknown as EventFromLogic<TLogic>\n        );\n        // TODO: rethink cleanup of observers, mailbox, etc\n        return this;\n      case 'error':\n        this._error((this._snapshot as any).error);\n        return this;\n    }\n\n    if (!this._parent) {\n      this.system.start();\n    }\n\n    if (this.logic.start) {\n      try {\n        this.logic.start(this._snapshot, this._actorScope);\n      } catch (err) {\n        this._snapshot = {\n          ...(this._snapshot as any),\n          status: 'error',\n          error: err\n        };\n        this._error(err);\n        return this;\n      }\n    }\n\n    // TODO: this notifies all subscribers but usually this is redundant\n    // there is no real change happening here\n    // we need to rethink if this needs to be refactored\n    this.update(this._snapshot, initEvent as unknown as EventFromLogic<TLogic>);\n\n    if (this.options.devTools) {\n      this.attachDevTools();\n    }\n\n    this.mailbox.start();\n\n    return this;\n  }\n\n  private _process(event: EventFromLogic<TLogic>) {\n    let nextState;\n    let caughtError;\n    try {\n      nextState = this.logic.transition(\n        this._snapshot,\n        event,\n        this._actorScope\n      );\n    } catch (err) {\n      // we wrap it in a box so we can rethrow it later even if falsy value gets caught here\n      caughtError = { err };\n    }\n\n    if (caughtError) {\n      const { err } = caughtError;\n\n      this._snapshot = {\n        ...(this._snapshot as any),\n        status: 'error',\n        error: err\n      };\n      this._error(err);\n      return;\n    }\n\n    this.update(nextState, event);\n    if (event.type === XSTATE_STOP) {\n      this._stopProcedure();\n      this._complete();\n    }\n  }\n\n  private _stop(): this {\n    if (this._processingStatus === ProcessingStatus.Stopped) {\n      return this;\n    }\n    this.mailbox.clear();\n    if (this._processingStatus === ProcessingStatus.NotStarted) {\n      this._processingStatus = ProcessingStatus.Stopped;\n      return this;\n    }\n    this.mailbox.enqueue({ type: XSTATE_STOP } as any);\n\n    return this;\n  }\n\n  /** Stops the Actor and unsubscribe all listeners. */\n  public stop(): this {\n    if (this._parent) {\n      throw new Error('A non-root actor cannot be stopped directly.');\n    }\n    return this._stop();\n  }\n  private _complete(): void {\n    for (const observer of this.observers) {\n      try {\n        observer.complete?.();\n      } catch (err) {\n        reportUnhandledError(err);\n      }\n    }\n    this.observers.clear();\n    this.eventListeners.clear();\n  }\n  private _reportError(err: unknown): void {\n    if (!this.observers.size) {\n      if (!this._parent) {\n        reportUnhandledError(err);\n      }\n      this.eventListeners.clear();\n      return;\n    }\n    let reportError = false;\n\n    for (const observer of this.observers) {\n      const errorListener = observer.error;\n      reportError ||= !errorListener;\n      try {\n        errorListener?.(err);\n      } catch (err2) {\n        reportUnhandledError(err2);\n      }\n    }\n    this.observers.clear();\n    this.eventListeners.clear();\n    if (reportError) {\n      reportUnhandledError(err);\n    }\n  }\n  private _error(err: unknown): void {\n    this._stopProcedure();\n    this._reportError(err);\n    if (this._parent) {\n      this.system._relay(\n        this,\n        this._parent,\n        createErrorActorEvent(this.id, err)\n      );\n    }\n  }\n  // TODO: atm children don't belong entirely to the actor so\n  // in a way - it's not even super aware of them\n  // so we can't stop them from here but we really should!\n  // right now, they are being stopped within the machine's transition\n  // but that could throw and leave us with \"orphaned\" active actors\n  private _stopProcedure(): this {\n    if (this._processingStatus !== ProcessingStatus.Running) {\n      // Actor already stopped; do nothing\n      return this;\n    }\n\n    // Cancel all delayed events\n    this.system.scheduler.cancelAll(this);\n\n    // TODO: mailbox.reset\n    this.mailbox.clear();\n    // TODO: after `stop` we must prepare ourselves for receiving events again\n    // events sent *after* stop signal must be queued\n    // it seems like this should be the common behavior for all of our consumers\n    // so perhaps this should be unified somehow for all of them\n    this.mailbox = new Mailbox(this._process.bind(this));\n\n    this._processingStatus = ProcessingStatus.Stopped;\n    this.system._unregister(this);\n\n    return this;\n  }\n\n  /** @internal */\n  public _send(event: EventFromLogic<TLogic>) {\n    if (this._processingStatus === ProcessingStatus.Stopped) {\n      // do nothing\n      if (isDevelopment) {\n        const eventString = JSON.stringify(event);\n\n        console.warn(\n          `Event \"${event.type}\" was sent to stopped actor \"${this.id} (${this.sessionId})\". This actor has already reached its final state, and will not transition.\\nEvent: ${eventString}`\n        );\n      }\n      return;\n    }\n\n    this.mailbox.enqueue(event);\n  }\n\n  /**\n   * Sends an event to the running Actor to trigger a transition.\n   *\n   * @param event The event to send\n   */\n  public send(event: EventFromLogic<TLogic>) {\n    if (isDevelopment && typeof event === 'string') {\n      throw new Error(\n        `Only event objects may be sent to actors; use .send({ type: \"${event}\" }) instead`\n      );\n    }\n    this.system._relay(undefined, this, event);\n  }\n\n  private attachDevTools(): void {\n    const { devTools } = this.options;\n    if (devTools) {\n      const resolvedDevToolsAdapter =\n        typeof devTools === 'function' ? devTools : devToolsAdapter;\n\n      resolvedDevToolsAdapter(this);\n    }\n  }\n  public toJSON() {\n    return {\n      xstate$$type: $$ACTOR_TYPE,\n      id: this.id\n    };\n  }\n\n  /**\n   * Obtain the internal state of the actor, which can be persisted.\n   *\n   * @remarks\n   * The internal state can be persisted from any actor, not only machines.\n   *\n   * Note that the persisted state is not the same as the snapshot from\n   * {@link Actor.getSnapshot}. Persisted state represents the internal state of\n   * the actor, while snapshots represent the actor's last emitted value.\n   *\n   * Can be restored with {@link ActorOptions.state}\n   * @see https://stately.ai/docs/persistence\n   */\n  public getPersistedSnapshot(): Snapshot<unknown>;\n  public getPersistedSnapshot(options?: unknown): Snapshot<unknown> {\n    return this.logic.getPersistedSnapshot(this._snapshot, options);\n  }\n\n  public [symbolObservable](): InteropSubscribable<SnapshotFrom<TLogic>> {\n    return this;\n  }\n\n  /**\n   * Read an actor’s snapshot synchronously.\n   *\n   * @remarks\n   * The snapshot represent an actor's last emitted value.\n   *\n   * When an actor receives an event, its internal state may change. An actor\n   * may emit a snapshot when a state transition occurs.\n   *\n   * Note that some actors, such as callback actors generated with\n   * `fromCallback`, will not emit snapshots.\n   * @see {@link Actor.subscribe} to subscribe to an actor’s snapshot values.\n   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).\n   */\n  public getSnapshot(): SnapshotFrom<TLogic> {\n    if (isDevelopment && !this._snapshot) {\n      throw new Error(\n        `Snapshot can't be read while the actor initializes itself`\n      );\n    }\n    return this._snapshot;\n  }\n}\n\nexport type RequiredActorOptionsKeys<TLogic extends AnyActorLogic> =\n  undefined extends InputFrom<TLogic> ? never : 'input';\n\n/**\n * Creates a new actor instance for the given actor logic with the provided\n * options, if any.\n *\n * @remarks\n * When you create an actor from actor logic via `createActor(logic)`, you\n * implicitly create an actor system where the created actor is the root actor.\n * Any actors spawned from this root actor and its descendants are part of that\n * actor system.\n * @example\n *\n * ```ts\n * import { createActor } from 'xstate';\n * import { someActorLogic } from './someActorLogic.ts';\n *\n * // Creating the actor, which implicitly creates an actor system with itself as the root actor\n * const actor = createActor(someActorLogic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n *\n * // Actors must be started by calling `actor.start()`, which will also start the actor system.\n * actor.start();\n *\n * // Actors can receive events\n * actor.send({ type: 'someEvent' });\n *\n * // You can stop root actors by calling `actor.stop()`, which will also stop the actor system and all actors in that system.\n * actor.stop();\n * ```\n *\n * @param logic - The actor logic to create an actor from. For a state machine\n *   actor logic creator, see {@link createMachine}. Other actor logic creators\n *   include {@link fromCallback}, {@link fromEventObservable},\n *   {@link fromObservable}, {@link fromPromise}, and {@link fromTransition}.\n * @param options - Actor options\n */\nexport function createActor<TLogic extends AnyActorLogic>(\n  logic: TLogic,\n  ...[options]: ConditionalRequired<\n    [\n      options?: ActorOptions<TLogic> & {\n        [K in RequiredActorOptionsKeys<TLogic>]: unknown;\n      }\n    ],\n    IsNotNever<RequiredActorOptionsKeys<TLogic>>\n  >\n): Actor<TLogic> {\n  return new Actor(logic, options);\n}\n\n/**\n * Creates a new Interpreter instance for the given machine with the provided\n * options, if any.\n *\n * @deprecated Use `createActor` instead\n * @alias\n */\nexport const interpret = createActor;\n\n/**\n * @deprecated Use `Actor` instead.\n * @alias\n */\nexport type Interpreter = typeof Actor;\n","import isDevelopment from '#is-development';\nimport {\n  AnyActorScope,\n  AnyMachineSnapshot,\n  EventObject,\n  MachineContext,\n  ActionArgs,\n  ParameterizedObject,\n  BuiltinActionResolution\n} from '../types.ts';\n\ntype ResolvableSendId<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n> =\n  | string\n  | ((\n      args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n      params: TParams\n    ) => string);\n\nfunction resolveCancel(\n  _: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  actionArgs: ActionArgs<any, any, any>,\n  actionParams: ParameterizedObject['params'] | undefined,\n  { sendId }: { sendId: ResolvableSendId<any, any, any, any> }\n): BuiltinActionResolution {\n  const resolvedSendId =\n    typeof sendId === 'function' ? sendId(actionArgs, actionParams) : sendId;\n  return [snapshot, { sendId: resolvedSendId }, undefined];\n}\n\nfunction executeCancel(actorScope: AnyActorScope, params: { sendId: string }) {\n  actorScope.defer(() => {\n    actorScope.system.scheduler.cancel(actorScope.self, params.sendId);\n  });\n}\n\nexport interface CancelAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n}\n\n/**\n * Cancels a delayed `sendTo(...)` action that is waiting to be executed. The\n * canceled `sendTo(...)` action will not send its event or execute, unless the\n * `delay` has already elapsed before `cancel(...)` is called.\n *\n * @example\n *\n * ```ts\n * import { createMachine, sendTo, cancel } from 'xstate';\n *\n * const machine = createMachine({\n *   // ...\n *   on: {\n *     sendEvent: {\n *       actions: sendTo(\n *         'some-actor',\n *         { type: 'someEvent' },\n *         {\n *           id: 'some-id',\n *           delay: 1000\n *         }\n *       )\n *     },\n *     cancelEvent: {\n *       actions: cancel('some-id')\n *     }\n *   }\n * });\n * ```\n *\n * @param sendId The `id` of the `sendTo(...)` action to cancel.\n */\nexport function cancel<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n>(\n  sendId: ResolvableSendId<TContext, TExpressionEvent, TParams, TEvent>\n): CancelAction<TContext, TExpressionEvent, TParams, TEvent> {\n  function cancel(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  cancel.type = 'xstate.cancel';\n  cancel.sendId = sendId;\n\n  cancel.resolve = resolveCancel;\n  cancel.execute = executeCancel;\n\n  return cancel;\n}\n","import isDevelopment from '#is-development';\nimport { cloneMachineSnapshot } from '../State.ts';\nimport { ProcessingStatus, createActor } from '../createActor.ts';\nimport {\n  ActionArgs,\n  ActionFunction,\n  AnyActorLogic,\n  AnyActorRef,\n  AnyActorScope,\n  AnyMachineSnapshot,\n  ConditionalRequired,\n  EventObject,\n  InputFrom,\n  IsLiteralString,\n  IsNotNever,\n  MachineContext,\n  Mapper,\n  ParameterizedObject,\n  ProvidedActor,\n  RequiredActorOptions,\n  BuiltinActionResolution,\n  UnifiedArg\n} from '../types.ts';\nimport { resolveReferencedActor } from '../utils.ts';\n\ntype ResolvableActorId<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TId extends string | undefined\n> = TId | ((args: UnifiedArg<TContext, TExpressionEvent, TEvent>) => TId);\n\nfunction resolveSpawn(\n  actorScope: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  actionArgs: ActionArgs<any, any, any>,\n  _actionParams: ParameterizedObject['params'] | undefined,\n  {\n    id,\n    systemId,\n    src,\n    input,\n    syncSnapshot\n  }: {\n    id: ResolvableActorId<MachineContext, EventObject, EventObject, string>;\n    systemId: string | undefined;\n    src: AnyActorLogic | string;\n    input?: unknown;\n    syncSnapshot: boolean;\n  }\n): BuiltinActionResolution {\n  const logic =\n    typeof src === 'string'\n      ? resolveReferencedActor(snapshot.machine, src)\n      : src;\n  const resolvedId = typeof id === 'function' ? id(actionArgs) : id;\n  let actorRef: AnyActorRef | undefined;\n  let resolvedInput: unknown | undefined = undefined;\n\n  if (logic) {\n    resolvedInput =\n      typeof input === 'function'\n        ? input({\n            context: snapshot.context,\n            event: actionArgs.event,\n            self: actorScope.self\n          })\n        : input;\n    actorRef = createActor(logic, {\n      id: resolvedId,\n      src,\n      parent: actorScope.self,\n      syncSnapshot,\n      systemId,\n      input: resolvedInput\n    });\n  }\n\n  if (isDevelopment && !actorRef) {\n    console.warn(\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-base-to-string\n      `Actor type '${src}' not found in machine '${actorScope.id}'.`\n    );\n  }\n  return [\n    cloneMachineSnapshot(snapshot, {\n      children: {\n        ...snapshot.children,\n        [resolvedId]: actorRef!\n      }\n    }),\n    {\n      id,\n      systemId,\n      actorRef,\n      src,\n      input: resolvedInput\n    },\n    undefined\n  ];\n}\n\nfunction executeSpawn(\n  actorScope: AnyActorScope,\n  { actorRef }: { id: string; actorRef: AnyActorRef }\n) {\n  if (!actorRef) {\n    return;\n  }\n\n  actorScope.defer(() => {\n    if (actorRef._processingStatus === ProcessingStatus.Stopped) {\n      return;\n    }\n    actorRef.start();\n  });\n}\n\nexport interface SpawnAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n  _out_TActor?: TActor;\n}\n\nexport interface SpawnActionOptions<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> {\n  id?: ResolvableActorId<TContext, TExpressionEvent, TEvent, TActor['id']>;\n  systemId?: string;\n  input?:\n    | Mapper<TContext, TEvent, InputFrom<TActor['logic']>, TEvent>\n    | InputFrom<TActor['logic']>;\n  syncSnapshot?: boolean;\n}\n\ntype DistributeActors<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> =\n  | (TActor extends any\n      ? ConditionalRequired<\n          [\n            src: TActor['src'],\n            options?: SpawnActionOptions<\n              TContext,\n              TExpressionEvent,\n              TEvent,\n              TActor\n            > & {\n              [K in RequiredActorOptions<TActor>]: unknown;\n            }\n          ],\n          IsNotNever<RequiredActorOptions<TActor>>\n        >\n      : never)\n  | [\n      src: AnyActorLogic,\n      options?: SpawnActionOptions<\n        TContext,\n        TExpressionEvent,\n        TEvent,\n        ProvidedActor\n      > & { id?: never }\n    ];\n\ntype SpawnArguments<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> =\n  IsLiteralString<TActor['src']> extends true\n    ? DistributeActors<TContext, TExpressionEvent, TEvent, TActor>\n    : [\n        src: string | AnyActorLogic,\n        options?: {\n          id?: ResolvableActorId<TContext, TExpressionEvent, TEvent, string>;\n          systemId?: string;\n          input?: unknown;\n          syncSnapshot?: boolean;\n        }\n      ];\n\nexport function spawnChild<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n>(\n  ...[\n    src,\n    { id, systemId, input, syncSnapshot = false } = {} as any\n  ]: SpawnArguments<TContext, TExpressionEvent, TEvent, TActor>\n): ActionFunction<\n  TContext,\n  TExpressionEvent,\n  TEvent,\n  TParams,\n  TActor,\n  never,\n  never,\n  never,\n  never\n> {\n  function spawnChild(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  spawnChild.type = 'xstate.spawnChild';\n  spawnChild.id = id;\n  spawnChild.systemId = systemId;\n  spawnChild.src = src;\n  spawnChild.input = input;\n  spawnChild.syncSnapshot = syncSnapshot;\n\n  spawnChild.resolve = resolveSpawn;\n  spawnChild.execute = executeSpawn;\n\n  return spawnChild;\n}\n","import isDevelopment from '#is-development';\nimport { cloneMachineSnapshot } from '../State.ts';\nimport { ProcessingStatus } from '../createActor.ts';\nimport {\n  ActionArgs,\n  AnyActorRef,\n  AnyActorScope,\n  AnyMachineSnapshot,\n  EventObject,\n  MachineContext,\n  ParameterizedObject,\n  BuiltinActionResolution\n} from '../types.ts';\n\ntype ResolvableActorRef<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n> =\n  | string\n  | AnyActorRef\n  | ((\n      args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n      params: TParams\n    ) => AnyActorRef | string);\n\nfunction resolveStop(\n  _: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  args: ActionArgs<any, any, any>,\n  actionParams: ParameterizedObject['params'] | undefined,\n  { actorRef }: { actorRef: ResolvableActorRef<any, any, any, any> }\n): BuiltinActionResolution {\n  const actorRefOrString =\n    typeof actorRef === 'function' ? actorRef(args, actionParams) : actorRef;\n  const resolvedActorRef: AnyActorRef | undefined =\n    typeof actorRefOrString === 'string'\n      ? snapshot.children[actorRefOrString]\n      : actorRefOrString;\n\n  let children = snapshot.children;\n  if (resolvedActorRef) {\n    children = { ...children };\n    delete children[resolvedActorRef.id];\n  }\n  return [\n    cloneMachineSnapshot(snapshot, {\n      children\n    }),\n    resolvedActorRef,\n    undefined\n  ];\n}\nfunction unregisterRecursively(\n  actorScope: AnyActorScope,\n  actorRef: AnyActorRef\n) {\n  // unregister children first (depth-first)\n  const snapshot = actorRef.getSnapshot();\n  if (snapshot && 'children' in snapshot) {\n    for (const child of Object.values(\n      snapshot.children as Record<string, AnyActorRef>\n    )) {\n      unregisterRecursively(actorScope, child);\n    }\n  }\n  actorScope.system._unregister(actorRef);\n}\n\nfunction executeStop(\n  actorScope: AnyActorScope,\n  actorRef: AnyActorRef | undefined\n) {\n  if (!actorRef) {\n    return;\n  }\n\n  // we need to eagerly unregister it here so a new actor with the same systemId can be registered immediately\n  // since we defer actual stopping of the actor but we don't defer actor creations (and we can't do that)\n  // this could throw on `systemId` collision, for example, when dealing with reentering transitions\n  // we also need to recursively unregister all nested children's systemIds\n  unregisterRecursively(actorScope, actorRef);\n\n  // this allows us to prevent an actor from being started if it gets stopped within the same macrostep\n  // this can happen, for example, when the invoking state is being exited immediately by an always transition\n  if (actorRef._processingStatus !== ProcessingStatus.Running) {\n    actorScope.stopChild(actorRef);\n    return;\n  }\n  // stopping a child enqueues a stop event in the child actor's mailbox\n  // we need for all of the already enqueued events to be processed before we stop the child\n  // the parent itself might want to send some events to a child (for example from exit actions on the invoking state)\n  // and we don't want to ignore those events\n  actorScope.defer(() => {\n    actorScope.stopChild(actorRef);\n  });\n}\n\nexport interface StopAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n}\n\n/**\n * Stops a child actor.\n *\n * @param actorRef The actor to stop.\n */\nexport function stopChild<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject\n>(\n  actorRef: ResolvableActorRef<TContext, TExpressionEvent, TParams, TEvent>\n): StopAction<TContext, TExpressionEvent, TParams, TEvent> {\n  function stop(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  stop.type = 'xstate.stopChild';\n  stop.actorRef = actorRef;\n\n  stop.resolve = resolveStop;\n  stop.execute = executeStop;\n\n  return stop;\n}\n\n/**\n * Stops a child actor.\n *\n * @deprecated Use `stopChild(...)` instead\n * @alias\n */\nexport const stop = stopChild;\n","import isDevelopment from '#is-development';\nimport type {\n  EventObject,\n  StateValue,\n  MachineContext,\n  ParameterizedObject,\n  AnyMachineSnapshot,\n  NoRequiredParams,\n  WithDynamicParams,\n  Identity,\n  Elements,\n  DoNotInfer\n} from './types.ts';\nimport { isStateId } from './stateUtils.ts';\n\ntype SingleGuardArg<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TGuardArg\n> = [TGuardArg] extends [{ type: string }]\n  ? Identity<TGuardArg>\n  : [TGuardArg] extends [string]\n    ? TGuardArg\n    : GuardPredicate<TContext, TExpressionEvent, TParams, ParameterizedObject>;\n\ntype NormalizeGuardArg<TGuardArg> = TGuardArg extends { type: string }\n  ? Identity<TGuardArg> & { params: unknown }\n  : TGuardArg extends string\n    ? { type: TGuardArg; params: undefined }\n    : '_out_TGuard' extends keyof TGuardArg\n      ? TGuardArg['_out_TGuard'] & ParameterizedObject\n      : never;\n\ntype NormalizeGuardArgArray<TArg extends unknown[]> = Elements<{\n  [K in keyof TArg]: NormalizeGuardArg<TArg[K]>;\n}>;\n\nexport type GuardPredicate<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TGuard extends ParameterizedObject\n> = {\n  (args: GuardArgs<TContext, TExpressionEvent>, params: TParams): boolean;\n  _out_TGuard?: TGuard;\n};\n\nexport interface GuardArgs<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n> {\n  context: TContext;\n  event: TExpressionEvent;\n}\n\nexport type Guard<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TGuard extends ParameterizedObject\n> =\n  | NoRequiredParams<TGuard>\n  | WithDynamicParams<TContext, TExpressionEvent, TGuard>\n  | GuardPredicate<TContext, TExpressionEvent, TParams, TGuard>;\n\nexport type UnknownGuard = UnknownReferencedGuard | UnknownInlineGuard;\n\ntype UnknownReferencedGuard = Guard<\n  MachineContext,\n  EventObject,\n  ParameterizedObject['params'],\n  ParameterizedObject\n>;\n\ntype UnknownInlineGuard = Guard<\n  MachineContext,\n  EventObject,\n  undefined,\n  ParameterizedObject\n>;\n\ninterface BuiltinGuard {\n  (): boolean;\n  check: (\n    snapshot: AnyMachineSnapshot,\n    guardArgs: GuardArgs<any, any>,\n    params: unknown\n  ) => boolean;\n}\n\nfunction checkStateIn(\n  snapshot: AnyMachineSnapshot,\n  _: GuardArgs<any, any>,\n  { stateValue }: { stateValue: StateValue }\n) {\n  if (typeof stateValue === 'string' && isStateId(stateValue)) {\n    const target = snapshot.machine.getStateNodeById(stateValue);\n    return snapshot._nodes.some((sn) => sn === target);\n  }\n\n  return snapshot.matches(stateValue);\n}\n\nexport function stateIn<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined\n>(\n  stateValue: StateValue\n): GuardPredicate<\n  TContext,\n  TExpressionEvent,\n  TParams,\n  any // TODO: recheck if we could replace this with something better here\n> {\n  function stateIn() {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  stateIn.check = checkStateIn;\n  stateIn.stateValue = stateValue;\n\n  return stateIn;\n}\n\nfunction checkNot(\n  snapshot: AnyMachineSnapshot,\n  { context, event }: GuardArgs<any, any>,\n  { guards }: { guards: readonly UnknownGuard[] }\n) {\n  return !evaluateGuard(guards[0], context, event, snapshot);\n}\n\n/**\n * Higher-order guard that evaluates to `true` if the `guard` passed to it\n * evaluates to `false`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, not } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => false\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: not('someNamedGuard'),\n *       actions: () => {\n *         // will be executed if guard in `not(...)`\n *         // evaluates to `false`\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard\n */\nexport function not<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TArg\n>(\n  guard: SingleGuardArg<TContext, TExpressionEvent, unknown, TArg>\n): GuardPredicate<\n  TContext,\n  TExpressionEvent,\n  unknown,\n  NormalizeGuardArg<DoNotInfer<TArg>>\n> {\n  function not(_args: GuardArgs<TContext, TExpressionEvent>, _params: unknown) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  not.check = checkNot;\n  not.guards = [guard];\n\n  return not;\n}\n\nfunction checkAnd(\n  snapshot: AnyMachineSnapshot,\n  { context, event }: GuardArgs<any, any>,\n  { guards }: { guards: readonly UnknownGuard[] }\n) {\n  return guards.every((guard) =>\n    evaluateGuard(guard, context, event, snapshot)\n  );\n}\n\n/**\n * Higher-order guard that evaluates to `true` if all `guards` passed to it\n * evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, and } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: and([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if all guards in `and(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */\nexport function and<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TArg extends unknown[]\n>(\n  guards: readonly [\n    ...{\n      [K in keyof TArg]: SingleGuardArg<\n        TContext,\n        TExpressionEvent,\n        unknown,\n        TArg[K]\n      >;\n    }\n  ]\n): GuardPredicate<\n  TContext,\n  TExpressionEvent,\n  unknown,\n  NormalizeGuardArgArray<DoNotInfer<TArg>>\n> {\n  function and(_args: GuardArgs<TContext, TExpressionEvent>, _params: unknown) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  and.check = checkAnd;\n  and.guards = guards;\n\n  return and;\n}\n\nfunction checkOr(\n  snapshot: AnyMachineSnapshot,\n  { context, event }: GuardArgs<any, any>,\n  { guards }: { guards: readonly UnknownGuard[] }\n) {\n  return guards.some((guard) => evaluateGuard(guard, context, event, snapshot));\n}\n\n/**\n * Higher-order guard that evaluates to `true` if any of the `guards` passed to\n * it evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, or } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: or([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if any of the guards in `or(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */\nexport function or<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TArg extends unknown[]\n>(\n  guards: readonly [\n    ...{\n      [K in keyof TArg]: SingleGuardArg<\n        TContext,\n        TExpressionEvent,\n        unknown,\n        TArg[K]\n      >;\n    }\n  ]\n): GuardPredicate<\n  TContext,\n  TExpressionEvent,\n  unknown,\n  NormalizeGuardArgArray<DoNotInfer<TArg>>\n> {\n  function or(_args: GuardArgs<TContext, TExpressionEvent>, _params: unknown) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n    return false;\n  }\n\n  or.check = checkOr;\n  or.guards = guards;\n\n  return or;\n}\n\n// TODO: throw on cycles (depth check should be enough)\nexport function evaluateGuard<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n>(\n  guard: UnknownGuard | UnknownInlineGuard,\n  context: TContext,\n  event: TExpressionEvent,\n  snapshot: AnyMachineSnapshot\n): boolean {\n  const { machine } = snapshot;\n  const isInline = typeof guard === 'function';\n\n  const resolved = isInline\n    ? guard\n    : machine.implementations.guards[\n        typeof guard === 'string' ? guard : guard.type\n      ];\n\n  if (!isInline && !resolved) {\n    throw new Error(\n      `Guard '${\n        typeof guard === 'string' ? guard : guard.type\n      }' is not implemented.'.`\n    );\n  }\n\n  if (typeof resolved !== 'function') {\n    return evaluateGuard(resolved!, context, event, snapshot);\n  }\n\n  const guardArgs = {\n    context,\n    event\n  };\n\n  const guardParams =\n    isInline || typeof guard === 'string'\n      ? undefined\n      : 'params' in guard\n        ? typeof guard.params === 'function'\n          ? guard.params({ context, event })\n          : guard.params\n        : undefined;\n\n  if (!('check' in resolved)) {\n    // the existing type of `.guards` assumes non-nullable `TExpressionGuard`\n    // inline guards expect `TExpressionGuard` to be set to `undefined`\n    // it's fine to cast this here, our logic makes sure that we call those 2 \"variants\" correctly\n    return resolved(guardArgs, guardParams as never);\n  }\n\n  const builtinGuard = resolved as unknown as BuiltinGuard;\n\n  return builtinGuard.check(\n    snapshot,\n    guardArgs,\n    resolved // this holds all params\n  );\n}\n","import isDevelopment from '#is-development';\nimport { MachineSnapshot, cloneMachineSnapshot } from './State.ts';\nimport type { StateNode } from './StateNode.ts';\nimport { raise } from './actions.ts';\nimport { createAfterEvent, createDoneStateEvent } from './eventUtils.ts';\nimport { cancel } from './actions/cancel.ts';\nimport { spawnChild } from './actions/spawnChild.ts';\nimport { stopChild } from './actions/stopChild.ts';\nimport {\n  XSTATE_INIT,\n  NULL_EVENT,\n  STATE_DELIMITER,\n  STATE_IDENTIFIER,\n  XSTATE_STOP,\n  WILDCARD\n} from './constants.ts';\nimport { evaluateGuard } from './guards.ts';\nimport { matchesEventDescriptor } from './utils.ts';\nimport {\n  ActionArgs,\n  AnyEventObject,\n  AnyHistoryValue,\n  AnyMachineSnapshot,\n  AnyStateNode,\n  AnyTransitionDefinition,\n  DelayedTransitionDefinition,\n  EventObject,\n  ExecutableActionObject,\n  HistoryValue,\n  InitialTransitionConfig,\n  InitialTransitionDefinition,\n  MachineContext,\n  StateValue,\n  StateValueMap,\n  TransitionDefinition,\n  TODO,\n  UnknownAction,\n  ParameterizedObject,\n  AnyTransitionConfig,\n  AnyActorScope,\n  ActionExecutor,\n  AnyStateMachine\n} from './types.ts';\nimport {\n  resolveOutput,\n  normalizeTarget,\n  toArray,\n  toStatePath,\n  toTransitionConfigArray,\n  isErrorActorEvent\n} from './utils.ts';\n\ntype StateNodeIterable<\n  TContext extends MachineContext,\n  TE extends EventObject\n> = Iterable<StateNode<TContext, TE>>;\ntype AnyStateNodeIterable = StateNodeIterable<any, any>;\n\ntype AdjList = Map<AnyStateNode, Array<AnyStateNode>>;\n\nexport function isAtomicStateNode(stateNode: StateNode<any, any>) {\n  return stateNode.type === 'atomic' || stateNode.type === 'final';\n}\n\nfunction getChildren<TContext extends MachineContext, TE extends EventObject>(\n  stateNode: StateNode<TContext, TE>\n): Array<StateNode<TContext, TE>> {\n  return Object.values(stateNode.states).filter((sn) => sn.type !== 'history');\n}\n\nexport function getProperAncestors(\n  stateNode: AnyStateNode,\n  toStateNode: AnyStateNode | undefined\n): Array<typeof stateNode> {\n  const ancestors: Array<typeof stateNode> = [];\n\n  if (toStateNode === stateNode) {\n    return ancestors;\n  }\n\n  // add all ancestors\n  let m = stateNode.parent;\n  while (m && m !== toStateNode) {\n    ancestors.push(m);\n    m = m.parent;\n  }\n\n  return ancestors;\n}\n\nexport function getAllStateNodes(\n  stateNodes: Iterable<AnyStateNode>\n): Set<AnyStateNode> {\n  const nodeSet = new Set(stateNodes);\n\n  const adjList = getAdjList(nodeSet);\n\n  // add descendants\n  for (const s of nodeSet) {\n    // if previously active, add existing child nodes\n    if (s.type === 'compound' && (!adjList.get(s) || !adjList.get(s)!.length)) {\n      getInitialStateNodesWithTheirAncestors(s).forEach((sn) =>\n        nodeSet.add(sn)\n      );\n    } else {\n      if (s.type === 'parallel') {\n        for (const child of getChildren(s)) {\n          if (child.type === 'history') {\n            continue;\n          }\n\n          if (!nodeSet.has(child)) {\n            const initialStates = getInitialStateNodesWithTheirAncestors(child);\n            for (const initialStateNode of initialStates) {\n              nodeSet.add(initialStateNode);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // add all ancestors\n  for (const s of nodeSet) {\n    let m = s.parent;\n\n    while (m) {\n      nodeSet.add(m);\n      m = m.parent;\n    }\n  }\n\n  return nodeSet;\n}\n\nfunction getValueFromAdj(baseNode: AnyStateNode, adjList: AdjList): StateValue {\n  const childStateNodes = adjList.get(baseNode);\n\n  if (!childStateNodes) {\n    return {}; // todo: fix?\n  }\n\n  if (baseNode.type === 'compound') {\n    const childStateNode = childStateNodes[0];\n    if (childStateNode) {\n      if (isAtomicStateNode(childStateNode)) {\n        return childStateNode.key;\n      }\n    } else {\n      return {};\n    }\n  }\n\n  const stateValue: StateValue = {};\n  for (const childStateNode of childStateNodes) {\n    stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);\n  }\n\n  return stateValue;\n}\n\nfunction getAdjList<TContext extends MachineContext, TE extends EventObject>(\n  stateNodes: StateNodeIterable<TContext, TE>\n): AdjList {\n  const adjList: AdjList = new Map();\n\n  for (const s of stateNodes) {\n    if (!adjList.has(s)) {\n      adjList.set(s, []);\n    }\n\n    if (s.parent) {\n      if (!adjList.has(s.parent)) {\n        adjList.set(s.parent, []);\n      }\n\n      adjList.get(s.parent)!.push(s);\n    }\n  }\n\n  return adjList;\n}\n\nexport function getStateValue(\n  rootNode: AnyStateNode,\n  stateNodes: AnyStateNodeIterable\n): StateValue {\n  const config = getAllStateNodes(stateNodes);\n  return getValueFromAdj(rootNode, getAdjList(config));\n}\n\nexport function isInFinalState(\n  stateNodeSet: Set<AnyStateNode>,\n  stateNode: AnyStateNode\n): boolean {\n  if (stateNode.type === 'compound') {\n    return getChildren(stateNode).some(\n      (s) => s.type === 'final' && stateNodeSet.has(s)\n    );\n  }\n  if (stateNode.type === 'parallel') {\n    return getChildren(stateNode).every((sn) =>\n      isInFinalState(stateNodeSet, sn)\n    );\n  }\n\n  return stateNode.type === 'final';\n}\n\nexport const isStateId = (str: string) => str[0] === STATE_IDENTIFIER;\n\nexport function getCandidates<TEvent extends EventObject>(\n  stateNode: StateNode<any, TEvent>,\n  receivedEventType: TEvent['type']\n): Array<TransitionDefinition<any, TEvent>> {\n  const candidates =\n    stateNode.transitions.get(receivedEventType) ||\n    [...stateNode.transitions.keys()]\n      .filter((eventDescriptor) =>\n        matchesEventDescriptor(receivedEventType, eventDescriptor)\n      )\n      .sort((a, b) => b.length - a.length)\n      .flatMap((key) => stateNode.transitions.get(key)!);\n\n  return candidates;\n}\n\n/** All delayed transitions from the config. */\nexport function getDelayedTransitions(\n  stateNode: AnyStateNode\n): Array<DelayedTransitionDefinition<MachineContext, EventObject>> {\n  const afterConfig = stateNode.config.after;\n  if (!afterConfig) {\n    return [];\n  }\n\n  const mutateEntryExit = (delay: string | number) => {\n    const afterEvent = createAfterEvent(delay, stateNode.id);\n    const eventType = afterEvent.type;\n\n    stateNode.entry.push(\n      raise(afterEvent, {\n        id: eventType,\n        delay\n      })\n    );\n    stateNode.exit.push(cancel(eventType));\n    return eventType;\n  };\n\n  const delayedTransitions = Object.keys(afterConfig).flatMap((delay) => {\n    const configTransition = afterConfig[delay];\n    const resolvedTransition =\n      typeof configTransition === 'string'\n        ? { target: configTransition }\n        : configTransition;\n    const resolvedDelay = Number.isNaN(+delay) ? delay : +delay;\n    const eventType = mutateEntryExit(resolvedDelay);\n    return toArray(resolvedTransition).map((transition) => ({\n      ...transition,\n      event: eventType,\n      delay: resolvedDelay\n    }));\n  });\n  return delayedTransitions.map((delayedTransition) => {\n    const { delay } = delayedTransition;\n    return {\n      ...formatTransition(\n        stateNode,\n        delayedTransition.event,\n        delayedTransition\n      ),\n      delay\n    };\n  });\n}\n\nexport function formatTransition(\n  stateNode: AnyStateNode,\n  descriptor: string,\n  transitionConfig: AnyTransitionConfig\n): AnyTransitionDefinition {\n  const normalizedTarget = normalizeTarget(transitionConfig.target);\n  const reenter = transitionConfig.reenter ?? false;\n  const target = resolveTarget(stateNode, normalizedTarget);\n\n  // TODO: should this be part of a lint rule instead?\n  if (isDevelopment && (transitionConfig as any).cond) {\n    throw new Error(\n      `State \"${stateNode.id}\" has declared \\`cond\\` for one of its transitions. This property has been renamed to \\`guard\\`. Please update your code.`\n    );\n  }\n\n  const transition = {\n    ...transitionConfig,\n    actions: toArray(transitionConfig.actions),\n    guard: transitionConfig.guard as never,\n    target,\n    source: stateNode,\n    reenter,\n    eventType: descriptor,\n    toJSON: () => ({\n      ...transition,\n      source: `#${stateNode.id}`,\n      target: target ? target.map((t) => `#${t.id}`) : undefined\n    })\n  };\n\n  return transition;\n}\n\nexport function formatTransitions<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode\n): Map<string, TransitionDefinition<TContext, TEvent>[]> {\n  const transitions = new Map<\n    string,\n    TransitionDefinition<TContext, AnyEventObject>[]\n  >();\n  if (stateNode.config.on) {\n    for (const descriptor of Object.keys(stateNode.config.on)) {\n      if (descriptor === NULL_EVENT) {\n        throw new Error(\n          'Null events (\"\") cannot be specified as a transition key. Use `always: { ... }` instead.'\n        );\n      }\n      const transitionsConfig = stateNode.config.on[descriptor];\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(transitionsConfig).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n  }\n  if (stateNode.config.onDone) {\n    const descriptor = `xstate.done.state.${stateNode.id}`;\n    transitions.set(\n      descriptor,\n      toTransitionConfigArray(stateNode.config.onDone).map((t) =>\n        formatTransition(stateNode, descriptor, t)\n      )\n    );\n  }\n  for (const invokeDef of stateNode.invoke) {\n    if (invokeDef.onDone) {\n      const descriptor = `xstate.done.actor.${invokeDef.id}`;\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(invokeDef.onDone).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n    if (invokeDef.onError) {\n      const descriptor = `xstate.error.actor.${invokeDef.id}`;\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(invokeDef.onError).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n    if (invokeDef.onSnapshot) {\n      const descriptor = `xstate.snapshot.${invokeDef.id}`;\n      transitions.set(\n        descriptor,\n        toTransitionConfigArray(invokeDef.onSnapshot).map((t) =>\n          formatTransition(stateNode, descriptor, t)\n        )\n      );\n    }\n  }\n  for (const delayedTransition of stateNode.after) {\n    let existing = transitions.get(delayedTransition.eventType);\n    if (!existing) {\n      existing = [];\n      transitions.set(delayedTransition.eventType, existing);\n    }\n    existing.push(delayedTransition);\n  }\n  return transitions as Map<string, TransitionDefinition<TContext, any>[]>;\n}\n\n/**\n * Collects route transitions from all descendants with explicit IDs. Called\n * once on the root node to avoid O(N²) repeated traversals.\n */\nexport function formatRouteTransitions(rootStateNode: AnyStateNode): void {\n  const routeTransitions: AnyTransitionDefinition[] = [];\n  const collectRoutes = (states: Record<string, AnyStateNode>) => {\n    Object.values(states).forEach((sn) => {\n      if (sn.config.route && sn.config.id) {\n        const routeId = sn.config.id;\n        const userGuard = sn.config.route.guard;\n        const routeGuard = (\n          args: { context: any; event: any },\n          params: any\n        ) => {\n          if (args.event.to !== `#${routeId}`) {\n            return false;\n          }\n          if (!userGuard) {\n            return true;\n          }\n          if (typeof userGuard === 'function') {\n            return userGuard(args, params);\n          }\n          return true;\n        };\n        const transition: AnyTransitionConfig = {\n          ...sn.config.route,\n          guard: routeGuard,\n          target: `#${routeId}`\n        };\n\n        routeTransitions.push(\n          formatTransition(rootStateNode, 'xstate.route', transition)\n        );\n      }\n      if (sn.states) {\n        collectRoutes(sn.states);\n      }\n    });\n  };\n  collectRoutes(rootStateNode.states);\n  if (routeTransitions.length > 0) {\n    rootStateNode.transitions.set('xstate.route', routeTransitions);\n  }\n}\n\nexport function formatInitialTransition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  _target:\n    | string\n    | undefined\n    | InitialTransitionConfig<TContext, TEvent, TODO, TODO, TODO, TODO>\n): InitialTransitionDefinition<TContext, TEvent> {\n  const resolvedTarget =\n    typeof _target === 'string'\n      ? stateNode.states[_target]\n      : _target\n        ? stateNode.states[_target.target]\n        : undefined;\n  if (!resolvedTarget && _target) {\n    throw new Error(\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string\n      `Initial state node \"${_target}\" not found on parent state node #${stateNode.id}`\n    );\n  }\n  const transition: InitialTransitionDefinition<TContext, TEvent> = {\n    source: stateNode,\n    actions:\n      !_target || typeof _target === 'string' ? [] : toArray(_target.actions),\n    eventType: null as any,\n    reenter: false,\n    target: resolvedTarget ? [resolvedTarget] : [],\n    toJSON: () => ({\n      ...transition,\n      source: `#${stateNode.id}`,\n      target: resolvedTarget ? [`#${resolvedTarget.id}`] : []\n    })\n  };\n\n  return transition;\n}\n\nfunction resolveTarget(\n  stateNode: AnyStateNode,\n  targets: ReadonlyArray<string | AnyStateNode> | undefined\n): ReadonlyArray<AnyStateNode> | undefined {\n  if (targets === undefined) {\n    // an undefined target signals that the state node should not transition from that state when receiving that event\n    return undefined;\n  }\n  return targets.map((target) => {\n    if (typeof target !== 'string') {\n      return target;\n    }\n    if (isStateId(target)) {\n      return stateNode.machine.getStateNodeById(target);\n    }\n\n    const isInternalTarget = target[0] === STATE_DELIMITER;\n    // If internal target is defined on machine,\n    // do not include machine key on target\n    if (isInternalTarget && !stateNode.parent) {\n      return getStateNodeByPath(stateNode, target.slice(1));\n    }\n    const resolvedTarget = isInternalTarget ? stateNode.key + target : target;\n    if (stateNode.parent) {\n      try {\n        const targetStateNode = getStateNodeByPath(\n          stateNode.parent,\n          resolvedTarget\n        );\n        return targetStateNode;\n      } catch (err: any) {\n        throw new Error(\n          `Invalid transition definition for state node '${stateNode.id}':\\n${err.message}`\n        );\n      }\n    } else {\n      throw new Error(\n        `Invalid target: \"${target}\" is not a valid target from the root node. Did you mean \".${target}\"?`\n      );\n    }\n  });\n}\n\nfunction resolveHistoryDefaultTransition<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(stateNode: AnyStateNode & { type: 'history' }) {\n  const normalizedTarget = normalizeTarget<TContext, TEvent>(\n    stateNode.config.target\n  );\n  if (!normalizedTarget) {\n    return stateNode.parent!.initial;\n  }\n  return {\n    target: normalizedTarget.map((t) =>\n      typeof t === 'string' ? getStateNodeByPath(stateNode.parent!, t) : t\n    )\n  };\n}\n\nfunction isHistoryNode(\n  stateNode: AnyStateNode\n): stateNode is AnyStateNode & { type: 'history' } {\n  return stateNode.type === 'history';\n}\n\nfunction getInitialStateNodesWithTheirAncestors(stateNode: AnyStateNode) {\n  const states = getInitialStateNodes(stateNode);\n  for (const initialState of states) {\n    for (const ancestor of getProperAncestors(initialState, stateNode)) {\n      states.add(ancestor);\n    }\n  }\n  return states;\n}\n\nfunction getInitialStateNodes(stateNode: AnyStateNode) {\n  const set = new Set<AnyStateNode>();\n\n  function iter(descStateNode: AnyStateNode): void {\n    if (set.has(descStateNode)) {\n      return;\n    }\n    set.add(descStateNode);\n    if (descStateNode.type === 'compound') {\n      iter(descStateNode.initial.target[0]);\n    } else if (descStateNode.type === 'parallel') {\n      for (const child of getChildren(descStateNode)) {\n        iter(child);\n      }\n    }\n  }\n\n  iter(stateNode);\n\n  return set;\n}\n/** Returns the child state node from its relative `stateKey`, or throws. */\nfunction getStateNode(stateNode: AnyStateNode, stateKey: string): AnyStateNode {\n  if (isStateId(stateKey)) {\n    return stateNode.machine.getStateNodeById(stateKey);\n  }\n  if (!stateNode.states) {\n    throw new Error(\n      `Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`\n    );\n  }\n  const result = stateNode.states[stateKey];\n  if (!result) {\n    throw new Error(\n      `Child state '${stateKey}' does not exist on '${stateNode.id}'`\n    );\n  }\n  return result;\n}\n\n/**\n * Returns the relative state node from the given `statePath`, or throws.\n *\n * @param statePath The string or string array relative path to the state node.\n */\nexport function getStateNodeByPath(\n  stateNode: AnyStateNode,\n  statePath: string | string[]\n): AnyStateNode {\n  if (typeof statePath === 'string' && isStateId(statePath)) {\n    try {\n      return stateNode.machine.getStateNodeById(statePath);\n    } catch {\n      // try individual paths\n      // throw e;\n    }\n  }\n  const arrayStatePath = toStatePath(statePath).slice();\n  let currentStateNode: AnyStateNode = stateNode;\n  while (arrayStatePath.length) {\n    const key = arrayStatePath.shift()!;\n    if (!key.length) {\n      break;\n    }\n    currentStateNode = getStateNode(currentStateNode, key);\n  }\n  return currentStateNode;\n}\n\n/**\n * Returns the state nodes represented by the current state value.\n *\n * @param stateValue The state value or State instance\n */\nexport function getStateNodes(\n  stateNode: AnyStateNode,\n  stateValue: StateValue\n): Array<AnyStateNode> {\n  if (typeof stateValue === 'string') {\n    const childStateNode = stateNode.states[stateValue];\n    if (!childStateNode) {\n      throw new Error(\n        `State '${stateValue}' does not exist on '${stateNode.id}'`\n      );\n    }\n    return [stateNode, childStateNode];\n  }\n\n  const childStateKeys = Object.keys(stateValue);\n  const childStateNodes: Array<AnyStateNode> = childStateKeys\n    .map((subStateKey) => getStateNode(stateNode, subStateKey))\n    .filter(Boolean);\n\n  return [stateNode.machine.root, stateNode].concat(\n    childStateNodes,\n    childStateKeys.reduce((allSubStateNodes, subStateKey) => {\n      const subStateNode = getStateNode(stateNode, subStateKey);\n      if (!subStateNode) {\n        return allSubStateNodes;\n      }\n      const subStateNodes = getStateNodes(\n        subStateNode,\n        stateValue[subStateKey]!\n      );\n\n      return allSubStateNodes.concat(subStateNodes);\n    }, [] as Array<AnyStateNode>)\n  );\n}\n\nfunction transitionAtomicNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: string,\n  snapshot: MachineSnapshot<\n    TContext,\n    TEvent,\n    any,\n    any,\n    any,\n    any,\n    any, // TMeta\n    any // TStateSchema\n  >,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  const childStateNode = getStateNode(stateNode, stateValue);\n  const next = childStateNode.next(snapshot, event);\n\n  if (!next || !next.length) {\n    return stateNode.next(snapshot, event);\n  }\n\n  return next;\n}\n\nfunction transitionCompoundNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: StateValueMap,\n  snapshot: MachineSnapshot<\n    TContext,\n    TEvent,\n    any,\n    any,\n    any,\n    any,\n    any, // TMeta\n    any // TStateSchema\n  >,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  const subStateKeys = Object.keys(stateValue);\n\n  const childStateNode = getStateNode(stateNode, subStateKeys[0]);\n  const next = transitionNode(\n    childStateNode,\n    stateValue[subStateKeys[0]]!,\n    snapshot,\n    event\n  );\n\n  if (!next || !next.length) {\n    return stateNode.next(snapshot, event);\n  }\n\n  return next;\n}\n\nfunction transitionParallelNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: StateValueMap,\n  snapshot: MachineSnapshot<\n    TContext,\n    TEvent,\n    any,\n    any,\n    any,\n    any,\n    any, // TMeta\n    any // TStateSchema\n  >,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  const allInnerTransitions: Array<TransitionDefinition<TContext, TEvent>> = [];\n\n  for (const subStateKey of Object.keys(stateValue)) {\n    const subStateValue = stateValue[subStateKey];\n\n    if (!subStateValue) {\n      continue;\n    }\n\n    const subStateNode = getStateNode(stateNode, subStateKey);\n    const innerTransitions = transitionNode(\n      subStateNode,\n      subStateValue,\n      snapshot,\n      event\n    );\n    if (innerTransitions) {\n      allInnerTransitions.push(...innerTransitions);\n    }\n  }\n  if (!allInnerTransitions.length) {\n    return stateNode.next(snapshot, event);\n  }\n\n  return allInnerTransitions;\n}\n\nexport function transitionNode<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  stateValue: StateValue,\n  snapshot: MachineSnapshot<\n    TContext,\n    TEvent,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any // TStateSchema\n  >,\n  event: TEvent\n): Array<TransitionDefinition<TContext, TEvent>> | undefined {\n  // leaf node\n  if (typeof stateValue === 'string') {\n    return transitionAtomicNode(stateNode, stateValue, snapshot, event);\n  }\n\n  // compound node\n  if (Object.keys(stateValue).length === 1) {\n    return transitionCompoundNode(stateNode, stateValue, snapshot, event);\n  }\n\n  // parallel node\n  return transitionParallelNode(stateNode, stateValue, snapshot, event);\n}\n\nfunction getHistoryNodes(stateNode: AnyStateNode): Array<AnyStateNode> {\n  return Object.keys(stateNode.states)\n    .map((key) => stateNode.states[key])\n    .filter((sn) => sn.type === 'history');\n}\n\nfunction isDescendant(\n  childStateNode: AnyStateNode,\n  parentStateNode: AnyStateNode\n): boolean {\n  let marker = childStateNode;\n  while (marker.parent && marker.parent !== parentStateNode) {\n    marker = marker.parent;\n  }\n\n  return marker.parent === parentStateNode;\n}\n\nfunction hasIntersection<T>(s1: Iterable<T>, s2: Iterable<T>): boolean {\n  const set1 = new Set(s1);\n  const set2 = new Set(s2);\n\n  for (const item of set1) {\n    if (set2.has(item)) {\n      return true;\n    }\n  }\n  for (const item of set2) {\n    if (set1.has(item)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction removeConflictingTransitions(\n  enabledTransitions: Array<AnyTransitionDefinition>,\n  stateNodeSet: Set<AnyStateNode>,\n  historyValue: AnyHistoryValue\n): Array<AnyTransitionDefinition> {\n  const filteredTransitions = new Set<AnyTransitionDefinition>();\n\n  for (const t1 of enabledTransitions) {\n    let t1Preempted = false;\n    const transitionsToRemove = new Set<AnyTransitionDefinition>();\n    for (const t2 of filteredTransitions) {\n      if (\n        hasIntersection(\n          computeExitSet([t1], stateNodeSet, historyValue),\n          computeExitSet([t2], stateNodeSet, historyValue)\n        )\n      ) {\n        if (isDescendant(t1.source, t2.source)) {\n          transitionsToRemove.add(t2);\n        } else {\n          t1Preempted = true;\n          break;\n        }\n      }\n    }\n    if (!t1Preempted) {\n      for (const t3 of transitionsToRemove) {\n        filteredTransitions.delete(t3);\n      }\n      filteredTransitions.add(t1);\n    }\n  }\n\n  return Array.from(filteredTransitions);\n}\n\nfunction findLeastCommonAncestor(\n  stateNodes: Array<AnyStateNode>\n): AnyStateNode | undefined {\n  const [head, ...tail] = stateNodes;\n  for (const ancestor of getProperAncestors(head, undefined)) {\n    if (tail.every((sn) => isDescendant(sn, ancestor))) {\n      return ancestor;\n    }\n  }\n}\n\nfunction getEffectiveTargetStates(\n  transition: Pick<AnyTransitionDefinition, 'target'>,\n  historyValue: AnyHistoryValue\n): Array<AnyStateNode> {\n  if (!transition.target) {\n    return [];\n  }\n\n  const targets = new Set<AnyStateNode>();\n\n  for (const targetNode of transition.target) {\n    if (isHistoryNode(targetNode)) {\n      if (historyValue[targetNode.id]) {\n        for (const node of historyValue[targetNode.id]) {\n          targets.add(node);\n        }\n      } else {\n        for (const node of getEffectiveTargetStates(\n          resolveHistoryDefaultTransition(targetNode),\n          historyValue\n        )) {\n          targets.add(node);\n        }\n      }\n    } else {\n      targets.add(targetNode);\n    }\n  }\n\n  return [...targets];\n}\n\nfunction getTransitionDomain(\n  transition: AnyTransitionDefinition,\n  historyValue: AnyHistoryValue\n): AnyStateNode | undefined {\n  const targetStates = getEffectiveTargetStates(transition, historyValue);\n\n  if (!targetStates) {\n    return;\n  }\n\n  if (\n    !transition.reenter &&\n    targetStates.every(\n      (target) =>\n        target === transition.source || isDescendant(target, transition.source)\n    )\n  ) {\n    return transition.source;\n  }\n\n  const lca = findLeastCommonAncestor(targetStates.concat(transition.source));\n\n  if (lca) {\n    return lca;\n  }\n\n  // at this point we know that it's a root transition since LCA couldn't be found\n  if (transition.reenter) {\n    return;\n  }\n\n  return transition.source.machine.root;\n}\n\nfunction computeExitSet(\n  transitions: AnyTransitionDefinition[],\n  stateNodeSet: Set<AnyStateNode>,\n  historyValue: AnyHistoryValue\n): Array<AnyStateNode> {\n  const statesToExit = new Set<AnyStateNode>();\n\n  for (const t of transitions) {\n    if (t.target?.length) {\n      const domain = getTransitionDomain(t, historyValue);\n\n      if (t.reenter && t.source === domain) {\n        statesToExit.add(domain);\n      }\n\n      for (const stateNode of stateNodeSet) {\n        if (isDescendant(stateNode, domain!)) {\n          statesToExit.add(stateNode);\n        }\n      }\n    }\n  }\n\n  return [...statesToExit];\n}\n\nfunction areStateNodeCollectionsEqual(\n  prevStateNodes: StateNode[],\n  nextStateNodeSet: Set<StateNode>\n) {\n  if (prevStateNodes.length !== nextStateNodeSet.size) {\n    return false;\n  }\n  for (const node of prevStateNodes) {\n    if (!nextStateNodeSet.has(node)) {\n      return false;\n    }\n  }\n  return true;\n}\n\ntype Microstep = readonly [AnyMachineSnapshot, ExecutableActionObject[]];\n\nexport function initialMicrostep(\n  root: AnyStateNode,\n  preInitialState: AnyMachineSnapshot,\n  actorScope: AnyActorScope,\n  initEvent: AnyEventObject,\n  internalQueue: AnyEventObject[]\n): Microstep {\n  return microstep(\n    [\n      {\n        target: [...getInitialStateNodes(root)],\n        source: root,\n        reenter: true,\n        actions: [],\n        eventType: null as any,\n        toJSON: null as any\n      }\n    ],\n    preInitialState,\n    actorScope,\n    initEvent,\n    true,\n    internalQueue\n  );\n}\n\n/** https://www.w3.org/TR/scxml/#microstepProcedure */\nfunction microstep(\n  transitions: Array<AnyTransitionDefinition>,\n  currentSnapshot: AnyMachineSnapshot,\n  actorScope: AnyActorScope,\n  event: AnyEventObject,\n  isInitial: boolean,\n  internalQueue: Array<AnyEventObject>\n): Microstep {\n  const actions: ExecutableActionObject[] = [];\n\n  if (!transitions.length) {\n    return [currentSnapshot, actions];\n  }\n\n  const originalExecutor = actorScope.actionExecutor;\n  actorScope.actionExecutor = (action) => {\n    actions.push(action);\n    originalExecutor(action);\n  };\n\n  try {\n    const mutStateNodeSet = new Set(currentSnapshot._nodes);\n    let historyValue = currentSnapshot.historyValue;\n\n    const filteredTransitions = removeConflictingTransitions(\n      transitions,\n      mutStateNodeSet,\n      historyValue\n    );\n\n    let nextState = currentSnapshot;\n\n    // Exit states\n    if (!isInitial) {\n      [nextState, historyValue] = exitStates(\n        nextState,\n        event,\n        actorScope,\n        filteredTransitions,\n        mutStateNodeSet,\n        historyValue,\n        internalQueue,\n        actorScope.actionExecutor\n      );\n    }\n\n    // Execute transition content\n    nextState = resolveActionsAndContext(\n      nextState,\n      event,\n      actorScope,\n      filteredTransitions.flatMap((t) => t.actions),\n      internalQueue,\n      undefined\n    );\n\n    // Enter states\n    nextState = enterStates(\n      nextState,\n      event,\n      actorScope,\n      filteredTransitions,\n      mutStateNodeSet,\n      internalQueue,\n      historyValue,\n      isInitial\n    );\n\n    const nextStateNodes = [...mutStateNodeSet];\n\n    if (nextState.status === 'done') {\n      nextState = resolveActionsAndContext(\n        nextState,\n        event,\n        actorScope,\n        nextStateNodes\n          .sort((a, b) => b.order - a.order)\n          .flatMap((state) => state.exit),\n        internalQueue,\n        undefined\n      );\n    }\n\n    // eslint-disable-next-line no-useless-catch\n    try {\n      if (\n        historyValue === currentSnapshot.historyValue &&\n        areStateNodeCollectionsEqual(currentSnapshot._nodes, mutStateNodeSet)\n      ) {\n        return [nextState, actions];\n      }\n      return [\n        cloneMachineSnapshot(nextState, {\n          _nodes: nextStateNodes,\n          historyValue\n        }),\n        actions\n      ];\n    } catch (e) {\n      // TODO: Refactor this once proper error handling is implemented.\n      // See https://github.com/statelyai/rfcs/pull/4\n      throw e;\n    }\n  } finally {\n    actorScope.actionExecutor = originalExecutor;\n  }\n}\n\nfunction getMachineOutput(\n  snapshot: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope,\n  rootNode: AnyStateNode,\n  rootCompletionNode: AnyStateNode\n) {\n  if (rootNode.output === undefined) {\n    return;\n  }\n  const doneStateEvent = createDoneStateEvent(\n    rootCompletionNode.id,\n    rootCompletionNode.output !== undefined && rootCompletionNode.parent\n      ? resolveOutput(\n          rootCompletionNode.output,\n          snapshot.context,\n          event,\n          actorScope.self\n        )\n      : undefined\n  );\n  return resolveOutput(\n    rootNode.output,\n    snapshot.context,\n    doneStateEvent,\n    actorScope.self\n  );\n}\n\nfunction enterStates(\n  currentSnapshot: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope,\n  filteredTransitions: AnyTransitionDefinition[],\n  mutStateNodeSet: Set<AnyStateNode>,\n  internalQueue: AnyEventObject[],\n  historyValue: HistoryValue<any, any>,\n  isInitial: boolean\n) {\n  let nextSnapshot = currentSnapshot;\n  const statesToEnter = new Set<AnyStateNode>();\n  // those are states that were directly targeted or indirectly targeted by the explicit target\n  // in other words, those are states for which initial actions should be executed\n  // when we target `#deep_child` initial actions of its ancestors shouldn't be executed\n  const statesForDefaultEntry = new Set<AnyStateNode>();\n  computeEntrySet(\n    filteredTransitions,\n    historyValue,\n    statesForDefaultEntry,\n    statesToEnter\n  );\n\n  // In the initial state, the root state node is \"entered\".\n  if (isInitial) {\n    statesForDefaultEntry.add(currentSnapshot.machine.root);\n  }\n\n  const completedNodes = new Set();\n\n  for (const stateNodeToEnter of [...statesToEnter].sort(\n    (a, b) => a.order - b.order\n  )) {\n    mutStateNodeSet.add(stateNodeToEnter);\n    const actions: UnknownAction[] = [];\n\n    // Add entry actions\n    actions.push(...stateNodeToEnter.entry);\n\n    for (const invokeDef of stateNodeToEnter.invoke) {\n      actions.push(\n        spawnChild(invokeDef.src, {\n          ...invokeDef,\n          syncSnapshot: !!invokeDef.onSnapshot\n        })\n      );\n    }\n\n    if (statesForDefaultEntry.has(stateNodeToEnter)) {\n      const initialActions = stateNodeToEnter.initial.actions;\n      actions.push(...initialActions);\n    }\n\n    nextSnapshot = resolveActionsAndContext(\n      nextSnapshot,\n      event,\n      actorScope,\n      actions,\n      internalQueue,\n      stateNodeToEnter.invoke.map((invokeDef) => invokeDef.id)\n    );\n\n    if (stateNodeToEnter.type === 'final') {\n      const parent = stateNodeToEnter.parent;\n\n      let ancestorMarker =\n        parent?.type === 'parallel' ? parent : parent?.parent;\n      let rootCompletionNode = ancestorMarker || stateNodeToEnter;\n\n      if (parent?.type === 'compound') {\n        internalQueue.push(\n          createDoneStateEvent(\n            parent.id,\n            stateNodeToEnter.output !== undefined\n              ? resolveOutput(\n                  stateNodeToEnter.output,\n                  nextSnapshot.context,\n                  event,\n                  actorScope.self\n                )\n              : undefined\n          )\n        );\n      }\n      while (\n        ancestorMarker?.type === 'parallel' &&\n        !completedNodes.has(ancestorMarker) &&\n        isInFinalState(mutStateNodeSet, ancestorMarker)\n      ) {\n        completedNodes.add(ancestorMarker);\n        internalQueue.push(createDoneStateEvent(ancestorMarker.id));\n        rootCompletionNode = ancestorMarker;\n        ancestorMarker = ancestorMarker.parent;\n      }\n      if (ancestorMarker) {\n        continue;\n      }\n\n      nextSnapshot = cloneMachineSnapshot(nextSnapshot, {\n        status: 'done',\n        output: getMachineOutput(\n          nextSnapshot,\n          event,\n          actorScope,\n          nextSnapshot.machine.root,\n          rootCompletionNode\n        )\n      });\n    }\n  }\n\n  return nextSnapshot;\n}\n\nfunction computeEntrySet(\n  transitions: Array<AnyTransitionDefinition>,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>,\n  statesToEnter: Set<AnyStateNode>\n) {\n  for (const t of transitions) {\n    const domain = getTransitionDomain(t, historyValue);\n\n    for (const s of t.target || []) {\n      if (\n        !isHistoryNode(s) &&\n        // if the target is different than the source then it will *definitely* be entered\n        (t.source !== s ||\n          // we know that the domain can't lie within the source\n          // if it's different than the source then it's outside of it and it means that the target has to be entered as well\n          t.source !== domain ||\n          // reentering transitions always enter the target, even if it's the source itself\n          t.reenter)\n      ) {\n        statesToEnter.add(s);\n        statesForDefaultEntry.add(s);\n      }\n      addDescendantStatesToEnter(\n        s,\n        historyValue,\n        statesForDefaultEntry,\n        statesToEnter\n      );\n    }\n    const targetStates = getEffectiveTargetStates(t, historyValue);\n    for (const s of targetStates) {\n      const ancestors = getProperAncestors(s, domain);\n      if (domain?.type === 'parallel') {\n        ancestors.push(domain);\n      }\n      addAncestorStatesToEnter(\n        statesToEnter,\n        historyValue,\n        statesForDefaultEntry,\n        ancestors,\n        !t.source.parent && t.reenter ? undefined : domain\n      );\n    }\n  }\n}\n\nfunction addDescendantStatesToEnter<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  stateNode: AnyStateNode,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>,\n  statesToEnter: Set<AnyStateNode>\n) {\n  if (isHistoryNode(stateNode)) {\n    if (historyValue[stateNode.id]) {\n      const historyStateNodes = historyValue[stateNode.id];\n      for (const s of historyStateNodes) {\n        statesToEnter.add(s);\n\n        addDescendantStatesToEnter(\n          s,\n          historyValue,\n          statesForDefaultEntry,\n          statesToEnter\n        );\n      }\n      for (const s of historyStateNodes) {\n        addProperAncestorStatesToEnter(\n          s,\n          stateNode.parent,\n          statesToEnter,\n          historyValue,\n          statesForDefaultEntry\n        );\n      }\n    } else {\n      const historyDefaultTransition = resolveHistoryDefaultTransition<\n        TContext,\n        TEvent\n      >(stateNode);\n      for (const s of historyDefaultTransition.target) {\n        statesToEnter.add(s);\n\n        if (historyDefaultTransition === stateNode.parent?.initial) {\n          statesForDefaultEntry.add(stateNode.parent);\n        }\n\n        addDescendantStatesToEnter(\n          s,\n          historyValue,\n          statesForDefaultEntry,\n          statesToEnter\n        );\n      }\n\n      for (const s of historyDefaultTransition.target) {\n        addProperAncestorStatesToEnter(\n          s,\n          stateNode.parent,\n          statesToEnter,\n          historyValue,\n          statesForDefaultEntry\n        );\n      }\n    }\n  } else {\n    if (stateNode.type === 'compound') {\n      const [initialState] = stateNode.initial.target;\n\n      if (!isHistoryNode(initialState)) {\n        statesToEnter.add(initialState);\n        statesForDefaultEntry.add(initialState);\n      }\n      addDescendantStatesToEnter(\n        initialState,\n        historyValue,\n        statesForDefaultEntry,\n        statesToEnter\n      );\n\n      addProperAncestorStatesToEnter(\n        initialState,\n        stateNode,\n        statesToEnter,\n        historyValue,\n        statesForDefaultEntry\n      );\n    } else {\n      if (stateNode.type === 'parallel') {\n        for (const child of getChildren(stateNode).filter(\n          (sn) => !isHistoryNode(sn)\n        )) {\n          if (![...statesToEnter].some((s) => isDescendant(s, child))) {\n            if (!isHistoryNode(child)) {\n              statesToEnter.add(child);\n              statesForDefaultEntry.add(child);\n            }\n            addDescendantStatesToEnter(\n              child,\n              historyValue,\n              statesForDefaultEntry,\n              statesToEnter\n            );\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction addAncestorStatesToEnter(\n  statesToEnter: Set<AnyStateNode>,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>,\n  ancestors: AnyStateNode[],\n  reentrancyDomain?: AnyStateNode\n) {\n  for (const anc of ancestors) {\n    if (!reentrancyDomain || isDescendant(anc, reentrancyDomain)) {\n      statesToEnter.add(anc);\n    }\n    if (anc.type === 'parallel') {\n      for (const child of getChildren(anc).filter((sn) => !isHistoryNode(sn))) {\n        if (![...statesToEnter].some((s) => isDescendant(s, child))) {\n          statesToEnter.add(child);\n          addDescendantStatesToEnter(\n            child,\n            historyValue,\n            statesForDefaultEntry,\n            statesToEnter\n          );\n        }\n      }\n    }\n  }\n}\n\nfunction addProperAncestorStatesToEnter(\n  stateNode: AnyStateNode,\n  toStateNode: AnyStateNode | undefined,\n  statesToEnter: Set<AnyStateNode>,\n  historyValue: HistoryValue<any, any>,\n  statesForDefaultEntry: Set<AnyStateNode>\n) {\n  addAncestorStatesToEnter(\n    statesToEnter,\n    historyValue,\n    statesForDefaultEntry,\n    getProperAncestors(stateNode, toStateNode)\n  );\n}\n\nfunction exitStates(\n  currentSnapshot: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope,\n  transitions: AnyTransitionDefinition[],\n  mutStateNodeSet: Set<AnyStateNode>,\n  historyValue: HistoryValue<any, any>,\n  internalQueue: AnyEventObject[],\n  _actionExecutor: ActionExecutor\n) {\n  let nextSnapshot = currentSnapshot;\n  const statesToExit = computeExitSet(\n    transitions,\n    mutStateNodeSet,\n    historyValue\n  );\n\n  statesToExit.sort((a, b) => b.order - a.order);\n\n  let changedHistory: typeof historyValue | undefined;\n\n  // From SCXML algorithm: https://www.w3.org/TR/scxml/#exitStates\n  for (const exitStateNode of statesToExit) {\n    for (const historyNode of getHistoryNodes(exitStateNode)) {\n      let predicate: (sn: AnyStateNode) => boolean;\n      if (historyNode.history === 'deep') {\n        predicate = (sn) =>\n          isAtomicStateNode(sn) && isDescendant(sn, exitStateNode);\n      } else {\n        predicate = (sn) => {\n          return sn.parent === exitStateNode;\n        };\n      }\n      changedHistory ??= { ...historyValue };\n      changedHistory[historyNode.id] =\n        Array.from(mutStateNodeSet).filter(predicate);\n    }\n  }\n\n  for (const s of statesToExit) {\n    nextSnapshot = resolveActionsAndContext(\n      nextSnapshot,\n      event,\n      actorScope,\n      [...s.exit, ...s.invoke.map((def) => stopChild(def.id))],\n      internalQueue,\n      undefined\n    );\n    mutStateNodeSet.delete(s);\n  }\n  return [nextSnapshot, changedHistory || historyValue] as const;\n}\n\nexport interface BuiltinAction {\n  (): void;\n  type: `xstate.${string}`;\n  resolve: (\n    actorScope: AnyActorScope,\n    snapshot: AnyMachineSnapshot,\n    actionArgs: ActionArgs<any, any, any>,\n    actionParams: ParameterizedObject['params'] | undefined,\n    action: unknown,\n    extra: unknown\n  ) => [\n    newState: AnyMachineSnapshot,\n    params: unknown,\n    actions?: UnknownAction[]\n  ];\n  retryResolve: (\n    actorScope: AnyActorScope,\n    snapshot: AnyMachineSnapshot,\n    params: unknown\n  ) => void;\n  execute: (actorScope: AnyActorScope, params: unknown) => void;\n}\n\nfunction getAction(machine: AnyStateMachine, actionType: string) {\n  return machine.implementations.actions[actionType];\n}\n\nfunction resolveAndExecuteActionsWithContext(\n  currentSnapshot: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope,\n  actions: UnknownAction[],\n  extra: {\n    internalQueue: AnyEventObject[];\n    deferredActorIds: string[] | undefined;\n  },\n  retries: (readonly [BuiltinAction, unknown])[] | undefined\n): AnyMachineSnapshot {\n  const { machine } = currentSnapshot;\n  let intermediateSnapshot = currentSnapshot;\n\n  for (const action of actions) {\n    const isInline = typeof action === 'function';\n    const resolvedAction = isInline\n      ? action\n      : // the existing type of `.actions` assumes non-nullable `TExpressionAction`\n        // it's fine to cast this here to get a common type and lack of errors in the rest of the code\n        // our logic below makes sure that we call those 2 \"variants\" correctly\n\n        getAction(machine, typeof action === 'string' ? action : action.type);\n    const actionArgs = {\n      context: intermediateSnapshot.context,\n      event,\n      self: actorScope.self,\n      system: actorScope.system\n    };\n\n    const actionParams =\n      isInline || typeof action === 'string'\n        ? undefined\n        : 'params' in action\n          ? typeof action.params === 'function'\n            ? action.params({ context: intermediateSnapshot.context, event })\n            : action.params\n          : undefined;\n\n    if (!resolvedAction || !('resolve' in resolvedAction)) {\n      actorScope.actionExecutor({\n        type:\n          typeof action === 'string'\n            ? action\n            : typeof action === 'object'\n              ? action.type\n              : action.name || '(anonymous)',\n        info: actionArgs,\n        params: actionParams,\n        exec: resolvedAction\n      });\n      continue;\n    }\n\n    const builtinAction = resolvedAction as BuiltinAction;\n\n    const [nextState, params, actions] = builtinAction.resolve(\n      actorScope,\n      intermediateSnapshot,\n      actionArgs,\n      actionParams,\n      resolvedAction, // this holds all params\n      extra\n    );\n    intermediateSnapshot = nextState;\n\n    if ('retryResolve' in builtinAction) {\n      retries?.push([builtinAction, params]);\n    }\n\n    if ('execute' in builtinAction) {\n      actorScope.actionExecutor({\n        type: builtinAction.type,\n        info: actionArgs,\n        params,\n        exec: builtinAction.execute.bind(null, actorScope, params)\n      });\n    }\n\n    if (actions) {\n      intermediateSnapshot = resolveAndExecuteActionsWithContext(\n        intermediateSnapshot,\n        event,\n        actorScope,\n        actions,\n        extra,\n        retries\n      );\n    }\n  }\n\n  return intermediateSnapshot;\n}\n\nexport function resolveActionsAndContext(\n  currentSnapshot: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope,\n  actions: UnknownAction[],\n  internalQueue: AnyEventObject[],\n  deferredActorIds: string[] | undefined\n): AnyMachineSnapshot {\n  const retries: (readonly [BuiltinAction, unknown])[] | undefined =\n    deferredActorIds ? [] : undefined;\n  const nextState = resolveAndExecuteActionsWithContext(\n    currentSnapshot,\n    event,\n    actorScope,\n    actions,\n    { internalQueue, deferredActorIds },\n    retries\n  );\n  retries?.forEach(([builtinAction, params]) => {\n    builtinAction.retryResolve(actorScope, nextState, params);\n  });\n  return nextState;\n}\n\nexport function macrostep(\n  snapshot: AnyMachineSnapshot,\n  event: EventObject,\n  actorScope: AnyActorScope,\n  internalQueue: AnyEventObject[]\n): {\n  snapshot: typeof snapshot;\n  microsteps: Microstep[];\n} {\n  if (isDevelopment && event.type === WILDCARD) {\n    throw new Error(`An event cannot have the wildcard type ('${WILDCARD}')`);\n  }\n\n  let nextSnapshot = snapshot;\n  const microsteps: Microstep[] = [];\n\n  function addMicrostep(\n    step: Microstep,\n    event: AnyEventObject,\n    transitions: AnyTransitionDefinition[]\n  ) {\n    actorScope.system._sendInspectionEvent({\n      type: '@xstate.microstep',\n      actorRef: actorScope.self,\n      event,\n      snapshot: step[0],\n      _transitions: transitions\n    });\n    microsteps.push(step);\n  }\n\n  // Handle stop event\n  if (event.type === XSTATE_STOP) {\n    nextSnapshot = cloneMachineSnapshot(\n      stopChildren(nextSnapshot, event, actorScope),\n      {\n        status: 'stopped'\n      }\n    );\n    addMicrostep([nextSnapshot, []], event, []);\n    return {\n      snapshot: nextSnapshot,\n      microsteps\n    };\n  }\n\n  let nextEvent = event;\n\n  // Assume the state is at rest (no raised events)\n  // Determine the next state based on the next microstep\n  if (nextEvent.type !== XSTATE_INIT) {\n    const currentEvent = nextEvent;\n    const isErr = isErrorActorEvent(currentEvent);\n\n    const transitions = selectTransitions(currentEvent, nextSnapshot);\n\n    if (isErr && !transitions.length) {\n      // TODO: we should likely only allow transitions selected by very explicit descriptors\n      // `*` shouldn't be matched, likely `xstate.error.*` shouldn't be either\n      // similarly `xstate.error.actor.*` and `xstate.error.actor.todo.*` have to be considered too\n      nextSnapshot = cloneMachineSnapshot<typeof snapshot>(snapshot, {\n        status: 'error',\n        error: currentEvent.error\n      });\n      addMicrostep([nextSnapshot, []], currentEvent, []);\n      return {\n        snapshot: nextSnapshot,\n        microsteps\n      };\n    }\n    const step = microstep(\n      transitions,\n      snapshot,\n      actorScope,\n      nextEvent,\n      false, // isInitial\n      internalQueue\n    );\n    nextSnapshot = step[0];\n    addMicrostep(step, currentEvent, transitions);\n  }\n\n  let shouldSelectEventlessTransitions = true;\n\n  while (nextSnapshot.status === 'active') {\n    let enabledTransitions: AnyTransitionDefinition[] =\n      shouldSelectEventlessTransitions\n        ? selectEventlessTransitions(nextSnapshot, nextEvent)\n        : [];\n\n    // eventless transitions should always be selected after selecting *regular* transitions\n    // by assigning `undefined` to `previousState` we ensure that `shouldSelectEventlessTransitions` gets always computed to true in such a case\n    const previousState = enabledTransitions.length ? nextSnapshot : undefined;\n\n    if (!enabledTransitions.length) {\n      if (!internalQueue.length) {\n        break;\n      }\n      nextEvent = internalQueue.shift()!;\n      enabledTransitions = selectTransitions(nextEvent, nextSnapshot);\n    }\n\n    const step = microstep(\n      enabledTransitions,\n      nextSnapshot,\n      actorScope,\n      nextEvent,\n      false,\n      internalQueue\n    );\n    nextSnapshot = step[0];\n    shouldSelectEventlessTransitions = nextSnapshot !== previousState;\n    addMicrostep(step, nextEvent, enabledTransitions);\n  }\n\n  if (nextSnapshot.status !== 'active') {\n    stopChildren(nextSnapshot, nextEvent, actorScope);\n  }\n\n  return {\n    snapshot: nextSnapshot,\n    microsteps\n  };\n}\n\nfunction stopChildren(\n  nextState: AnyMachineSnapshot,\n  event: AnyEventObject,\n  actorScope: AnyActorScope\n) {\n  return resolveActionsAndContext(\n    nextState,\n    event,\n    actorScope,\n    Object.values(nextState.children).map((child: any) => stopChild(child)),\n    [],\n    undefined\n  );\n}\n\nfunction selectTransitions(\n  event: AnyEventObject,\n  nextState: AnyMachineSnapshot\n): AnyTransitionDefinition[] {\n  return nextState.machine.getTransitionData(nextState as any, event);\n}\n\nfunction selectEventlessTransitions(\n  nextState: AnyMachineSnapshot,\n  event: AnyEventObject\n): AnyTransitionDefinition[] {\n  const enabledTransitionSet: Set<AnyTransitionDefinition> = new Set();\n  const atomicStates = nextState._nodes.filter(isAtomicStateNode);\n\n  for (const stateNode of atomicStates) {\n    loop: for (const s of [stateNode].concat(\n      getProperAncestors(stateNode, undefined)\n    )) {\n      if (!s.always) {\n        continue;\n      }\n      for (const transition of s.always) {\n        if (\n          transition.guard === undefined ||\n          evaluateGuard(transition.guard, nextState.context, event, nextState)\n        ) {\n          enabledTransitionSet.add(transition);\n          break loop;\n        }\n      }\n    }\n  }\n\n  return removeConflictingTransitions(\n    Array.from(enabledTransitionSet),\n    new Set(nextState._nodes),\n    nextState.historyValue\n  );\n}\n\n/**\n * Resolves a partial state value with its full representation in the state\n * node's machine.\n *\n * @param stateValue The partial state value to resolve.\n */\nexport function resolveStateValue(\n  rootNode: AnyStateNode,\n  stateValue: StateValue\n): StateValue {\n  const allStateNodes = getAllStateNodes(getStateNodes(rootNode, stateValue));\n  return getStateValue(rootNode, [...allStateNodes]);\n}\n","import isDevelopment from '#is-development';\nimport { executingCustomAction } from '../createActor.ts';\nimport {\n  ActionArgs,\n  ActionFunction,\n  AnyActorScope,\n  AnyEventObject,\n  AnyMachineSnapshot,\n  DelayExpr,\n  DoNotInfer,\n  EventObject,\n  ExecutableActionObject,\n  MachineContext,\n  ParameterizedObject,\n  RaiseActionOptions,\n  SendExpr,\n  BuiltinActionResolution\n} from '../types.ts';\n\nfunction resolveRaise(\n  _: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  args: ActionArgs<any, any, any>,\n  actionParams: ParameterizedObject['params'] | undefined,\n  {\n    event: eventOrExpr,\n    id,\n    delay\n  }: {\n    event:\n      | EventObject\n      | SendExpr<\n          MachineContext,\n          EventObject,\n          ParameterizedObject['params'] | undefined,\n          EventObject,\n          EventObject\n        >;\n    id: string | undefined;\n    delay:\n      | string\n      | number\n      | DelayExpr<\n          MachineContext,\n          EventObject,\n          ParameterizedObject['params'] | undefined,\n          EventObject\n        >\n      | undefined;\n  },\n  { internalQueue }: { internalQueue: AnyEventObject[] }\n): BuiltinActionResolution {\n  const delaysMap = snapshot.machine.implementations.delays;\n\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      `Only event objects may be used with raise; use raise({ type: \"${eventOrExpr}\" }) instead`\n    );\n  }\n  const resolvedEvent =\n    typeof eventOrExpr === 'function'\n      ? eventOrExpr(args, actionParams)\n      : eventOrExpr;\n\n  let resolvedDelay: number | undefined;\n  if (typeof delay === 'string') {\n    const configDelay = delaysMap && delaysMap[delay];\n    resolvedDelay =\n      typeof configDelay === 'function'\n        ? configDelay(args, actionParams)\n        : configDelay;\n  } else {\n    resolvedDelay =\n      typeof delay === 'function' ? delay(args, actionParams) : delay;\n  }\n  if (typeof resolvedDelay !== 'number') {\n    internalQueue.push(resolvedEvent);\n  }\n  return [\n    snapshot,\n    {\n      event: resolvedEvent,\n      id,\n      delay: resolvedDelay\n    },\n    undefined\n  ];\n}\n\nfunction executeRaise(\n  actorScope: AnyActorScope,\n  params: {\n    event: EventObject;\n    id: string | undefined;\n    delay: number | undefined;\n  }\n) {\n  const { event, delay, id } = params;\n  if (typeof delay === 'number') {\n    actorScope.defer(() => {\n      const self = actorScope.self;\n      actorScope.system.scheduler.schedule(self, self, event, delay, id);\n    });\n    return;\n  }\n}\n\nexport interface RaiseAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TDelay extends string\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n  _out_TEvent?: TEvent;\n  _out_TDelay?: TDelay;\n}\n\n/**\n * Raises an event. This places the event in the internal event queue, so that\n * the event is immediately consumed by the machine in the current step.\n *\n * @param eventType The event to raise.\n */\nexport function raise<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TDelay extends string = never,\n  TUsedDelay extends TDelay = never\n>(\n  eventOrExpr:\n    | DoNotInfer<TEvent>\n    | SendExpr<TContext, TExpressionEvent, TParams, DoNotInfer<TEvent>, TEvent>,\n  options?: RaiseActionOptions<\n    TContext,\n    TExpressionEvent,\n    TParams,\n    DoNotInfer<TEvent>,\n    TUsedDelay\n  >\n): ActionFunction<\n  TContext,\n  TExpressionEvent,\n  TEvent,\n  TParams,\n  never,\n  never,\n  never,\n  TDelay,\n  never\n> {\n  if (isDevelopment && executingCustomAction) {\n    console.warn(\n      'Custom actions should not call `raise()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.'\n    );\n  }\n\n  function raise(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  raise.type = 'xstate.raise';\n  raise.event = eventOrExpr;\n  raise.id = options?.id;\n  raise.delay = options?.delay;\n\n  raise.resolve = resolveRaise;\n  raise.execute = executeRaise;\n\n  return raise;\n}\n\nexport interface ExecutableRaiseAction extends ExecutableActionObject {\n  type: 'xstate.raise';\n  params: {\n    event: EventObject;\n    id: string | undefined;\n    delay: number | undefined;\n  };\n}\n","import isDevelopment from '#is-development';\nimport { $$ACTOR_TYPE } from './createActor.ts';\nimport type { StateNode } from './StateNode.ts';\nimport type { StateMachine } from './StateMachine.ts';\nimport { getStateValue } from './stateUtils.ts';\nimport type {\n  ProvidedActor,\n  AnyMachineSnapshot,\n  AnyStateMachine,\n  EventObject,\n  HistoryValue,\n  MachineContext,\n  StateConfig,\n  StateValue,\n  AnyActorRef,\n  Snapshot,\n  ParameterizedObject,\n  IsNever,\n  MetaObject,\n  StateSchema,\n  StateId,\n  SnapshotStatus,\n  PersistedHistoryValue\n} from './types.ts';\nimport { matchesState } from './utils.ts';\n\ntype ToTestStateValue<TStateValue extends StateValue> =\n  TStateValue extends string\n    ? TStateValue\n    : IsNever<keyof TStateValue> extends true\n      ? never\n      :\n          | keyof TStateValue\n          | {\n              [K in keyof TStateValue]?: ToTestStateValue<\n                NonNullable<TStateValue[K]>\n              >;\n            };\n\nexport function isMachineSnapshot(value: unknown): value is AnyMachineSnapshot {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'machine' in value &&\n    'value' in value\n  );\n}\n\ninterface MachineSnapshotBase<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta,\n  TStateSchema extends StateSchema = StateSchema\n> {\n  /** The state machine that produced this state snapshot. */\n  machine: StateMachine<\n    TContext,\n    TEvent,\n    TChildren,\n    ProvidedActor,\n    ParameterizedObject,\n    ParameterizedObject,\n    string,\n    TStateValue,\n    TTag,\n    unknown,\n    TOutput,\n    EventObject, // TEmitted\n    any, // TMeta\n    TStateSchema\n  >;\n  /** The tags of the active state nodes that represent the current state value. */\n  tags: Set<string>;\n  /**\n   * The current state value.\n   *\n   * This represents the active state nodes in the state machine.\n   *\n   * - For atomic state nodes, it is a string.\n   * - For compound parent state nodes, it is an object where:\n   *\n   *   - The key is the parent state node's key\n   *   - The value is the current state value of the active child state node(s)\n   *\n   * @example\n   *\n   * ```ts\n   * // single-level state node\n   * snapshot.value; // => 'yellow'\n   *\n   * // nested state nodes\n   * snapshot.value; // => { red: 'wait' }\n   * ```\n   */\n  value: TStateValue;\n  /** The current status of this snapshot. */\n  status: SnapshotStatus;\n  error: unknown;\n  context: TContext;\n\n  historyValue: Readonly<HistoryValue<TContext, TEvent>>;\n  /** The enabled state nodes representative of the state value. */\n  _nodes: Array<StateNode<TContext, TEvent>>;\n  /** An object mapping actor names to spawned/invoked actors. */\n  children: TChildren;\n\n  /**\n   * Whether the current state value is a subset of the given partial state\n   * value.\n   *\n   * @param partialStateValue\n   */\n  matches: (partialStateValue: ToTestStateValue<TStateValue>) => boolean;\n\n  /**\n   * Whether the current state nodes has a state node with the specified `tag`.\n   *\n   * @param tag\n   */\n  hasTag: (tag: TTag) => boolean;\n\n  /**\n   * Determines whether sending the `event` will cause a non-forbidden\n   * transition to be selected, even if the transitions have no actions nor\n   * change the state value.\n   *\n   * @param event The event to test\n   * @returns Whether the event will cause a transition\n   */\n  can: (event: TEvent) => boolean;\n\n  getMeta: () => Record<\n    StateId<TStateSchema> & string,\n    TMeta | undefined // States might not have meta defined\n  >;\n\n  toJSON: () => unknown;\n}\n\ninterface ActiveMachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject,\n  TStateSchema extends StateSchema\n> extends MachineSnapshotBase<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TStateSchema\n  > {\n  status: 'active';\n  output: undefined;\n  error: undefined;\n}\n\ninterface DoneMachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject,\n  TStateSchema extends StateSchema\n> extends MachineSnapshotBase<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TStateSchema\n  > {\n  status: 'done';\n  output: TOutput;\n  error: undefined;\n}\n\ninterface ErrorMachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject,\n  TStateSchema extends StateSchema\n> extends MachineSnapshotBase<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TStateSchema\n  > {\n  status: 'error';\n  output: undefined;\n  error: unknown;\n}\n\ninterface StoppedMachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject,\n  TStateSchema extends StateSchema\n> extends MachineSnapshotBase<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TStateSchema\n  > {\n  status: 'stopped';\n  output: undefined;\n  error: undefined;\n}\n\nexport type MachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject,\n  TStateSchema extends StateSchema\n> =\n  | ActiveMachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >\n  | DoneMachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >\n  | ErrorMachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >\n  | StoppedMachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >;\n\nconst machineSnapshotMatches = function matches(\n  this: AnyMachineSnapshot,\n  testValue: StateValue\n) {\n  return matchesState(testValue, this.value);\n};\n\nconst machineSnapshotHasTag = function hasTag(\n  this: AnyMachineSnapshot,\n  tag: string\n) {\n  return this.tags.has(tag);\n};\n\nconst machineSnapshotCan = function can(\n  this: AnyMachineSnapshot,\n  event: EventObject\n) {\n  if (isDevelopment && !this.machine) {\n    console.warn(\n      `state.can(...) used outside of a machine-created State object; this will always return false.`\n    );\n  }\n\n  const transitionData = this.machine.getTransitionData(this, event);\n\n  return (\n    !!transitionData?.length &&\n    // Check that at least one transition is not forbidden\n    transitionData.some((t) => t.target !== undefined || t.actions.length)\n  );\n};\n\nconst machineSnapshotToJSON = function toJSON(this: AnyMachineSnapshot) {\n  const {\n    _nodes: nodes,\n    tags,\n    machine,\n    getMeta,\n    toJSON,\n    can,\n    hasTag,\n    matches,\n    ...jsonValues\n  } = this;\n  return { ...jsonValues, tags: Array.from(tags) };\n};\n\nconst machineSnapshotGetMeta = function getMeta(this: AnyMachineSnapshot) {\n  return this._nodes.reduce(\n    (acc, stateNode) => {\n      if (stateNode.meta !== undefined) {\n        acc[stateNode.id] = stateNode.meta;\n      }\n      return acc;\n    },\n    {} as Record<string, any>\n  );\n};\n\nexport function createMachineSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TMeta extends MetaObject,\n  TStateSchema extends StateSchema\n>(\n  config: StateConfig<TContext, TEvent>,\n  machine: AnyStateMachine\n): MachineSnapshot<\n  TContext,\n  TEvent,\n  TChildren,\n  TStateValue,\n  TTag,\n  undefined,\n  TMeta,\n  TStateSchema\n> {\n  return {\n    status: config.status as never,\n    output: config.output,\n    error: config.error,\n    machine,\n    context: config.context,\n    _nodes: config._nodes,\n    value: getStateValue(machine.root, config._nodes) as never,\n    tags: new Set(config._nodes.flatMap((sn) => sn.tags)),\n    children: config.children as any,\n    historyValue: config.historyValue || {},\n    matches: machineSnapshotMatches as never,\n    hasTag: machineSnapshotHasTag,\n    can: machineSnapshotCan,\n    getMeta: machineSnapshotGetMeta,\n    toJSON: machineSnapshotToJSON\n  };\n}\n\nexport function cloneMachineSnapshot<TState extends AnyMachineSnapshot>(\n  snapshot: TState,\n  config: Partial<StateConfig<any, any>> = {}\n): TState {\n  return createMachineSnapshot(\n    { ...snapshot, ...config } as StateConfig<any, any>,\n    snapshot.machine\n  ) as TState;\n}\n\nfunction serializeHistoryValue<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(historyValue: HistoryValue<TContext, TEvent>): PersistedHistoryValue {\n  if (typeof historyValue !== 'object' || historyValue === null) {\n    return {};\n  }\n  const result: PersistedHistoryValue = {};\n\n  for (const key in historyValue) {\n    const value = historyValue[key];\n    if (Array.isArray(value)) {\n      result[key] = value.map((item) => ({ id: item.id }));\n    }\n  }\n\n  return result;\n}\n\nexport function getPersistedSnapshot<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TOutput,\n  TMeta extends MetaObject\n>(\n  snapshot: MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    any // state schema\n  >,\n  options?: unknown\n): Snapshot<unknown> {\n  const {\n    _nodes: nodes,\n    tags,\n    machine,\n    children,\n    context,\n    can,\n    hasTag,\n    matches,\n    getMeta,\n    toJSON,\n    ...jsonValues\n  } = snapshot;\n\n  const childrenJson: Record<string, unknown> = {};\n\n  for (const id in children) {\n    const child = children[id] as any;\n    if (\n      isDevelopment &&\n      typeof child.src !== 'string' &&\n      (!options || !('__unsafeAllowInlineActors' in (options as object)))\n    ) {\n      throw new Error('An inline child actor cannot be persisted.');\n    }\n    childrenJson[id as keyof typeof childrenJson] = {\n      snapshot: child.getPersistedSnapshot(options),\n      src: child.src,\n      systemId: child.systemId,\n      syncSnapshot: child._syncSnapshot\n    };\n  }\n\n  const persisted = {\n    ...jsonValues,\n    context: persistContext(context) as any,\n    children: childrenJson,\n    historyValue: serializeHistoryValue<TContext, TEvent>(\n      jsonValues.historyValue\n    )\n  };\n\n  return persisted;\n}\n\nfunction persistContext(contextPart: Record<string, unknown>) {\n  let copy: typeof contextPart | undefined;\n  for (const key in contextPart) {\n    const value = contextPart[key];\n    if (value && typeof value === 'object') {\n      if ('sessionId' in value && 'send' in value && 'ref' in value) {\n        copy ??= Array.isArray(contextPart)\n          ? (contextPart.slice() as typeof contextPart)\n          : { ...contextPart };\n        copy[key] = {\n          xstate$$type: $$ACTOR_TYPE,\n          id: (value as any as AnyActorRef).id\n        };\n      } else {\n        const result = persistContext(value as typeof contextPart);\n        if (result !== value) {\n          copy ??= Array.isArray(contextPart)\n            ? (contextPart.slice() as typeof contextPart)\n            : { ...contextPart };\n          copy[key] = result;\n        }\n      }\n    }\n  }\n  return copy ?? contextPart;\n}\n","import { ProcessingStatus, createActor } from './createActor.ts';\nimport {\n  ActorRefFromLogic,\n  AnyActorLogic,\n  AnyActorRef,\n  AnyActorScope,\n  AnyEventObject,\n  AnyMachineSnapshot,\n  ConditionalRequired,\n  GetConcreteByKey,\n  InputFrom,\n  IsLiteralString,\n  IsNotNever,\n  ProvidedActor,\n  RequiredActorOptions,\n  TODO,\n  type RequiredLogicInput\n} from './types.ts';\nimport { resolveReferencedActor } from './utils.ts';\n\ntype SpawnOptions<\n  TActor extends ProvidedActor,\n  TSrc extends TActor['src']\n> = TActor extends {\n  src: TSrc;\n}\n  ? ConditionalRequired<\n      [\n        options?: {\n          id?: TActor['id'];\n          systemId?: string;\n          input?: InputFrom<TActor['logic']>;\n          syncSnapshot?: boolean;\n        } & { [K in RequiredActorOptions<TActor>]: unknown }\n      ],\n      IsNotNever<RequiredActorOptions<TActor>>\n    >\n  : never;\n\nexport type Spawner<TActor extends ProvidedActor> =\n  IsLiteralString<TActor['src']> extends true\n    ? {\n        <TSrc extends TActor['src']>(\n          logic: TSrc,\n          ...[options]: SpawnOptions<TActor, TSrc>\n        ): ActorRefFromLogic<GetConcreteByKey<TActor, 'src', TSrc>['logic']>;\n        <TLogic extends AnyActorLogic>(\n          src: TLogic,\n          ...[options]: ConditionalRequired<\n            [\n              options?: {\n                id?: never;\n                systemId?: string;\n                input?: InputFrom<TLogic>;\n                syncSnapshot?: boolean;\n              } & { [K in RequiredLogicInput<TLogic>]: unknown }\n            ],\n            IsNotNever<RequiredLogicInput<TLogic>>\n          >\n        ): ActorRefFromLogic<TLogic>;\n      }\n    : <TLogic extends AnyActorLogic | string>(\n        src: TLogic,\n        ...[options]: ConditionalRequired<\n          [\n            options?: {\n              id?: string;\n              systemId?: string;\n              input?: TLogic extends string ? unknown : InputFrom<TLogic>;\n              syncSnapshot?: boolean;\n            } & (TLogic extends AnyActorLogic\n              ? { [K in RequiredLogicInput<TLogic>]: unknown }\n              : {})\n          ],\n          IsNotNever<\n            TLogic extends AnyActorLogic ? RequiredLogicInput<TLogic> : never\n          >\n        >\n      ) => TLogic extends AnyActorLogic\n        ? ActorRefFromLogic<TLogic>\n        : AnyActorRef;\n\nexport function createSpawner(\n  actorScope: AnyActorScope,\n  { machine, context }: AnyMachineSnapshot,\n  event: AnyEventObject,\n  spawnedChildren: Record<string, AnyActorRef>\n): Spawner<any> {\n  const spawn: Spawner<any> = ((src, options) => {\n    if (typeof src === 'string') {\n      const logic = resolveReferencedActor(machine, src);\n\n      if (!logic) {\n        throw new Error(\n          `Actor logic '${src}' not implemented in machine '${machine.id}'`\n        );\n      }\n\n      const actorRef = createActor(logic, {\n        id: options?.id,\n        parent: actorScope.self,\n        syncSnapshot: options?.syncSnapshot,\n        input:\n          typeof options?.input === 'function'\n            ? options.input({\n                context,\n                event,\n                self: actorScope.self\n              })\n            : options?.input,\n        src,\n        systemId: options?.systemId\n      }) as any;\n\n      spawnedChildren[actorRef.id] = actorRef;\n\n      return actorRef;\n    } else {\n      const actorRef = createActor(src, {\n        id: options?.id,\n        parent: actorScope.self,\n        syncSnapshot: options?.syncSnapshot,\n        input: options?.input,\n        src,\n        systemId: options?.systemId\n      });\n\n      return actorRef;\n    }\n  }) as Spawner<any>;\n  return ((src, options) => {\n    const actorRef = spawn(src, options) as TODO; // TODO: fix types\n    spawnedChildren[actorRef.id] = actorRef;\n    actorScope.defer(() => {\n      if (actorRef._processingStatus === ProcessingStatus.Stopped) {\n        return;\n      }\n      actorRef.start();\n    });\n    return actorRef;\n  }) as Spawner<any>;\n}\n","import isDevelopment from '#is-development';\nimport { cloneMachineSnapshot } from '../State.ts';\nimport { executingCustomAction } from '../createActor.ts';\nimport { Spawner, createSpawner } from '../spawn.ts';\nimport type {\n  ActionArgs,\n  AnyActorScope,\n  AnyActorRef,\n  AnyEventObject,\n  AnyMachineSnapshot,\n  Assigner,\n  EventObject,\n  LowInfer,\n  MachineContext,\n  ParameterizedObject,\n  PropertyAssigner,\n  ProvidedActor,\n  ActionFunction,\n  BuiltinActionResolution\n} from '../types.ts';\n\nexport interface AssignArgs<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> extends ActionArgs<TContext, TExpressionEvent, TEvent> {\n  spawn: Spawner<TActor>;\n}\n\nfunction resolveAssign(\n  actorScope: AnyActorScope,\n  snapshot: AnyMachineSnapshot,\n  actionArgs: ActionArgs<any, any, any>,\n  actionParams: ParameterizedObject['params'] | undefined,\n  {\n    assignment\n  }: {\n    assignment:\n      | Assigner<any, any, any, any, any>\n      | PropertyAssigner<any, any, any, any, any>;\n  }\n): BuiltinActionResolution {\n  if (!snapshot.context) {\n    throw new Error(\n      'Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.'\n    );\n  }\n  const spawnedChildren: Record<string, AnyActorRef> = {};\n\n  const assignArgs: AssignArgs<any, any, any, any> = {\n    context: snapshot.context,\n    event: actionArgs.event,\n    spawn: createSpawner(\n      actorScope,\n      snapshot,\n      actionArgs.event,\n      spawnedChildren\n    ),\n    self: actorScope.self,\n    system: actorScope.system\n  };\n  let partialUpdate: Record<string, unknown> = {};\n  if (typeof assignment === 'function') {\n    partialUpdate = assignment(assignArgs, actionParams);\n  } else {\n    for (const key of Object.keys(assignment)) {\n      const propAssignment = assignment[key];\n      partialUpdate[key] =\n        typeof propAssignment === 'function'\n          ? propAssignment(assignArgs, actionParams)\n          : propAssignment;\n    }\n  }\n\n  const updatedContext = Object.assign({}, snapshot.context, partialUpdate);\n\n  return [\n    cloneMachineSnapshot(snapshot, {\n      context: updatedContext,\n      children: Object.keys(spawnedChildren).length\n        ? {\n            ...snapshot.children,\n            ...spawnedChildren\n          }\n        : snapshot.children\n    }),\n    undefined,\n    undefined\n  ];\n}\n\nexport interface AssignAction<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject,\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n> {\n  (args: ActionArgs<TContext, TExpressionEvent, TEvent>, params: TParams): void;\n  _out_TActor?: TActor;\n}\n\n/**\n * Updates the current context of the machine.\n *\n * @example\n *\n * ```ts\n * import { createMachine, assign } from 'xstate';\n *\n * const countMachine = createMachine({\n *   context: {\n *     count: 0,\n *     message: ''\n *   },\n *   on: {\n *     inc: {\n *       actions: assign({\n *         count: ({ context }) => context.count + 1\n *       })\n *     },\n *     updateMessage: {\n *       actions: assign(({ context, event }) => {\n *         return {\n *           message: event.message.trim()\n *         };\n *       })\n *     }\n *   }\n * });\n * ```\n *\n * @param assignment An object that represents the partial context to update, or\n *   a function that returns an object that represents the partial context to\n *   update.\n */\nexport function assign<\n  TContext extends MachineContext,\n  TExpressionEvent extends AnyEventObject, // TODO: consider using a stricter `EventObject` here\n  TParams extends ParameterizedObject['params'] | undefined,\n  TEvent extends EventObject,\n  TActor extends ProvidedActor\n>(\n  assignment:\n    | Assigner<LowInfer<TContext>, TExpressionEvent, TParams, TEvent, TActor>\n    | PropertyAssigner<\n        LowInfer<TContext>,\n        TExpressionEvent,\n        TParams,\n        TEvent,\n        TActor\n      >\n): ActionFunction<\n  TContext,\n  TExpressionEvent,\n  TEvent,\n  TParams,\n  TActor,\n  never,\n  never,\n  never,\n  never\n> {\n  if (isDevelopment && executingCustomAction) {\n    console.warn(\n      'Custom actions should not call `assign()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.'\n    );\n  }\n\n  function assign(\n    _args: ActionArgs<TContext, TExpressionEvent, TEvent>,\n    _params: TParams\n  ) {\n    if (isDevelopment) {\n      throw new Error(`This isn't supposed to be called`);\n    }\n  }\n\n  assign.type = 'xstate.assign';\n  assign.assignment = assignment;\n\n  assign.resolve = resolveAssign;\n\n  return assign;\n}\n","import { createActor } from '../createActor.ts';\nimport type { ActorRef, AnyEventObject, Snapshot } from '../types.ts';\nimport { fromTransition } from './transition.ts';\nexport {\n  fromCallback,\n  type CallbackActorLogic,\n  type CallbackActorRef,\n  type CallbackSnapshot,\n  type CallbackLogicFunction\n} from './callback.ts';\nexport {\n  fromEventObservable,\n  fromObservable,\n  type ObservableActorLogic,\n  type ObservableActorRef,\n  type ObservableSnapshot\n} from './observable.ts';\nexport {\n  fromPromise,\n  type PromiseActorLogic,\n  type PromiseActorRef,\n  type PromiseSnapshot\n} from './promise.ts';\nexport {\n  fromTransition,\n  type TransitionActorLogic,\n  type TransitionActorRef,\n  type TransitionSnapshot\n} from './transition.ts';\n\nconst emptyLogic = fromTransition((_) => undefined, undefined);\n\nexport function createEmptyActor(): ActorRef<\n  Snapshot<undefined>,\n  AnyEventObject,\n  AnyEventObject\n> {\n  return createActor(emptyLogic);\n}\n","import { AnyActorSystem } from '../system.ts';\nimport {\n  ActorLogic,\n  ActorRefFromLogic,\n  ActorScope,\n  EventObject,\n  NonReducibleUnknown,\n  Snapshot\n} from '../types.ts';\n\nexport type TransitionSnapshot<TContext> = Snapshot<undefined> & {\n  context: TContext;\n};\n\nexport type TransitionActorLogic<\n  TContext,\n  TEvent extends EventObject,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n> = ActorLogic<\n  TransitionSnapshot<TContext>,\n  TEvent,\n  TInput,\n  AnyActorSystem,\n  TEmitted\n>;\n\n/**\n * Represents an actor created by `fromTransition`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromTransition,\n *   createActor,\n *   type AnyActorSystem\n * } from 'xstate';\n *\n * //* The actor's stored context.\n * type Context = {\n *   // The current count.\n *   count: number;\n *   // The amount to increase `count` by.\n *   step: number;\n * };\n * // The events the actor receives.\n * type Event = { type: 'increment' };\n * // The actor's input.\n * type Input = { step?: number };\n *\n * // Actor logic that increments `count` by `step` when it receives an event of\n * // type `increment`.\n * const logic = fromTransition<Context, Event, AnyActorSystem, Input>(\n *   (state, event, actorScope) => {\n *     actorScope.self;\n *     //         ^? TransitionActorRef<Context, Event>\n *\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + state.step\n *       };\n *     }\n *     return state;\n *   },\n *   ({ input, self }) => {\n *     self;\n *     // ^? TransitionActorRef<Context, Event>\n *\n *     return {\n *       count: 0,\n *       step: input.step ?? 1\n *     };\n *   }\n * );\n *\n * const actor = createActor(logic, { input: { step: 10 } });\n * //    ^? TransitionActorRef<Context, Event>\n * ```\n *\n * @see {@link fromTransition}\n */\nexport type TransitionActorRef<\n  TContext,\n  TEvent extends EventObject\n> = ActorRefFromLogic<\n  TransitionActorLogic<TransitionSnapshot<TContext>, TEvent, unknown>\n>;\n\n/**\n * Returns actor logic given a transition function and its initial state.\n *\n * A “transition function” is a function that takes the current `state` and\n * received `event` object as arguments, and returns the next state, similar to\n * a reducer.\n *\n * Actors created from transition logic (“transition actors”) can:\n *\n * - Receive events\n * - Emit snapshots of its state\n *\n * The transition function’s `state` is used as its transition actor’s\n * `context`.\n *\n * Note that the \"state\" for a transition function is provided by the initial\n * state argument, and is not the same as the State object of an actor or a\n * state within a machine configuration.\n *\n * @example\n *\n * ```ts\n * const transitionLogic = fromTransition(\n *   (state, event) => {\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + 1\n *       };\n *     }\n *     return state;\n *   },\n *   { count: 0 }\n * );\n *\n * const transitionActor = createActor(transitionLogic);\n * transitionActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * transitionActor.start();\n * // => {\n * //   status: 'active',\n * //   context: { count: 0 },\n * //   ...\n * // }\n *\n * transitionActor.send({ type: 'increment' });\n * // => {\n * //   status: 'active',\n * //   context: { count: 1 },\n * //   ...\n * // }\n * ```\n *\n * @param transition The transition function used to describe the transition\n *   logic. It should return the next state given the current state and event.\n *   It receives the following arguments:\n *\n *   - `state` - the current state.\n *   - `event` - the received event.\n *   - `actorScope` - the actor scope object, with properties like `self` and\n *       `system`.\n *\n * @param initialContext The initial state of the transition function, either an\n *   object representing the state, or a function which returns a state object.\n *   If a function, it will receive as its only argument an object with the\n *   following properties:\n *\n *   - `input` - the `input` provided to its parent transition actor.\n *   - `self` - a reference to its parent transition actor.\n *\n * @returns Actor logic\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nexport function fromTransition<\n  TContext,\n  TEvent extends EventObject,\n  TSystem extends AnyActorSystem,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n>(\n  transition: (\n    snapshot: TContext,\n    event: TEvent,\n    actorScope: ActorScope<\n      TransitionSnapshot<TContext>,\n      TEvent,\n      TSystem,\n      TEmitted\n    >\n  ) => TContext,\n  initialContext:\n    | TContext\n    | (({\n        input,\n        self\n      }: {\n        input: TInput;\n        self: TransitionActorRef<TContext, TEvent>;\n      }) => TContext) // TODO: type\n): TransitionActorLogic<TContext, TEvent, TInput, TEmitted> {\n  return {\n    config: transition,\n    transition: (snapshot, event, actorScope) => {\n      return {\n        ...snapshot,\n        context: transition(snapshot.context, event, actorScope as any)\n      };\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context:\n          typeof initialContext === 'function'\n            ? (initialContext as any)({ input })\n            : initialContext\n      };\n    },\n    getPersistedSnapshot: (snapshot) => snapshot,\n    restoreSnapshot: (snapshot: any) => snapshot\n  };\n}\n","const cache = new WeakMap<any, any>();\n\nexport function memo<T>(object: any, key: string, fn: () => T): T {\n  let memoizedData = cache.get(object);\n\n  if (!memoizedData) {\n    memoizedData = { [key]: fn() };\n    cache.set(object, memoizedData);\n  } else if (!(key in memoizedData)) {\n    memoizedData[key] = fn();\n  }\n\n  return memoizedData[key];\n}\n","import { MachineSnapshot } from './State.ts';\nimport type { StateMachine } from './StateMachine.ts';\nimport { NULL_EVENT, STATE_DELIMITER } from './constants.ts';\nimport { evaluateGuard } from './guards.ts';\nimport { memo } from './memo.ts';\nimport {\n  BuiltinAction,\n  formatInitialTransition,\n  formatTransition,\n  formatTransitions,\n  getCandidates,\n  getDelayedTransitions\n} from './stateUtils.ts';\nimport type {\n  DelayedTransitionDefinition,\n  EventObject,\n  InitialTransitionDefinition,\n  InvokeDefinition,\n  MachineContext,\n  Mapper,\n  StateNodeConfig,\n  StateNodeDefinition,\n  StateNodesConfig,\n  StatesDefinition,\n  TransitionDefinition,\n  TransitionDefinitionMap,\n  TODO,\n  UnknownAction,\n  ParameterizedObject,\n  AnyStateMachine,\n  AnyStateNodeConfig,\n  ProvidedActor,\n  NonReducibleUnknown,\n  EventDescriptor\n} from './types.ts';\nimport {\n  createInvokeId,\n  mapValues,\n  toArray,\n  toTransitionConfigArray\n} from './utils.ts';\n\nconst EMPTY_OBJECT = {};\n\nconst toSerializableAction = (action: UnknownAction) => {\n  if (typeof action === 'string') {\n    return { type: action };\n  }\n  if (typeof action === 'function') {\n    if ('resolve' in action) {\n      return { type: (action as BuiltinAction).type };\n    }\n    return {\n      type: action.name\n    };\n  }\n  return action;\n};\n\ninterface StateNodeOptions<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n> {\n  _key: string;\n  _parent?: StateNode<TContext, TEvent>;\n  _machine: AnyStateMachine;\n}\n\nexport class StateNode<\n  TContext extends MachineContext = MachineContext,\n  TEvent extends EventObject = EventObject\n> {\n  /**\n   * The relative key of the state node, which represents its location in the\n   * overall state value.\n   */\n  public key: string;\n  /** The unique ID of the state node. */\n  public id: string;\n  /**\n   * The type of this state node:\n   *\n   * - `'atomic'` - no child state nodes\n   * - `'compound'` - nested child state nodes (XOR)\n   * - `'parallel'` - orthogonal nested child state nodes (AND)\n   * - `'history'` - history state node\n   * - `'final'` - final state node\n   */\n  public type: 'atomic' | 'compound' | 'parallel' | 'final' | 'history';\n  /** The string path from the root machine node to this node. */\n  public path: string[];\n  /** The child state nodes. */\n  public states: StateNodesConfig<TContext, TEvent>;\n  /**\n   * The type of history on this state node. Can be:\n   *\n   * - `'shallow'` - recalls only top-level historical state value\n   * - `'deep'` - recalls historical state value at all levels\n   */\n  public history: false | 'shallow' | 'deep';\n  /** The action(s) to be executed upon entering the state node. */\n  public entry: UnknownAction[];\n  /** The action(s) to be executed upon exiting the state node. */\n  public exit: UnknownAction[];\n  /** The parent state node. */\n  public parent?: StateNode<TContext, TEvent>;\n  /** The root machine node. */\n  public machine: StateMachine<\n    TContext,\n    TEvent,\n    any, // children\n    any, // actor\n    any, // action\n    any, // guard\n    any, // delay\n    any, // state value\n    any, // tag\n    any, // input\n    any, // output\n    any, // emitted\n    any, // meta\n    any // state schema\n  >;\n  /**\n   * The meta data associated with this state node, which will be returned in\n   * State instances.\n   */\n  public meta?: any;\n  /**\n   * The output data sent with the \"xstate.done.state._id_\" event if this is a\n   * final state node.\n   */\n  public output?:\n    | Mapper<MachineContext, EventObject, unknown, EventObject>\n    | NonReducibleUnknown;\n\n  /**\n   * The order this state node appears. Corresponds to the implicit document\n   * order.\n   */\n  public order: number = -1;\n\n  public description?: string;\n\n  public tags: string[] = [];\n  public transitions!: Map<string, TransitionDefinition<TContext, TEvent>[]>;\n  public always?: Array<TransitionDefinition<TContext, TEvent>>;\n\n  constructor(\n    /** The raw config used to create the machine. */\n    public config: StateNodeConfig<\n      TContext,\n      TEvent,\n      TODO, // actors\n      TODO, // actions\n      TODO, // guards\n      TODO, // delays\n      TODO, // tags\n      TODO, // output\n      TODO, // emitted\n      TODO // meta\n    >,\n    options: StateNodeOptions<TContext, TEvent>\n  ) {\n    this.parent = options._parent;\n    this.key = options._key;\n    this.machine = options._machine;\n    this.path = this.parent ? this.parent.path.concat(this.key) : [];\n    this.id =\n      this.config.id || [this.machine.id, ...this.path].join(STATE_DELIMITER);\n    this.type =\n      this.config.type ||\n      (this.config.states && Object.keys(this.config.states).length\n        ? 'compound'\n        : this.config.history\n          ? 'history'\n          : 'atomic');\n    this.description = this.config.description;\n\n    this.order = this.machine.idMap.size;\n    this.machine.idMap.set(this.id, this);\n\n    this.states = (\n      this.config.states\n        ? mapValues(\n            this.config.states,\n            (stateConfig: AnyStateNodeConfig, key) => {\n              const stateNode = new StateNode(stateConfig, {\n                _parent: this,\n                _key: key,\n                _machine: this.machine\n              });\n              return stateNode;\n            }\n          )\n        : EMPTY_OBJECT\n    ) as StateNodesConfig<TContext, TEvent>;\n\n    if (this.type === 'compound' && !this.config.initial) {\n      throw new Error(\n        `No initial state specified for compound state node \"#${\n          this.id\n        }\". Try adding { initial: \"${\n          Object.keys(this.states)[0]\n        }\" } to the state config.`\n      );\n    }\n\n    // History config\n    this.history =\n      this.config.history === true ? 'shallow' : this.config.history || false;\n\n    this.entry = toArray(this.config.entry).slice();\n    this.exit = toArray(this.config.exit).slice();\n\n    this.meta = this.config.meta;\n    this.output =\n      this.type === 'final' || !this.parent ? this.config.output : undefined;\n    this.tags = toArray(config.tags).slice();\n  }\n\n  /** @internal */\n  public _initialize() {\n    this.transitions = formatTransitions(this);\n    if (this.config.always) {\n      this.always = toTransitionConfigArray(this.config.always).map((t) =>\n        formatTransition(this, NULL_EVENT, t)\n      );\n    }\n\n    Object.keys(this.states).forEach((key) => {\n      this.states[key]._initialize();\n    });\n  }\n\n  /** The well-structured state node definition. */\n  public get definition(): StateNodeDefinition<TContext, TEvent> {\n    return {\n      id: this.id,\n      key: this.key,\n      version: this.machine.version,\n      type: this.type,\n      initial: this.initial\n        ? {\n            target: this.initial.target,\n            source: this,\n            actions: this.initial.actions.map(toSerializableAction),\n            eventType: null as any,\n            reenter: false,\n            toJSON: () => ({\n              target: this.initial.target.map((t) => `#${t.id}`),\n              source: `#${this.id}`,\n              actions: this.initial.actions.map(toSerializableAction),\n              eventType: null as any\n            })\n          }\n        : undefined,\n      history: this.history,\n      states: mapValues(this.states, (state: StateNode<TContext, TEvent>) => {\n        return state.definition;\n      }) as StatesDefinition<TContext, TEvent>,\n      on: this.on,\n      transitions: [...this.transitions.values()].flat().map((t) => ({\n        ...t,\n        actions: t.actions.map(toSerializableAction)\n      })),\n      entry: this.entry.map(toSerializableAction),\n      exit: this.exit.map(toSerializableAction),\n      meta: this.meta,\n      order: this.order || -1,\n      output: this.output,\n      invoke: this.invoke,\n      description: this.description,\n      tags: this.tags\n    };\n  }\n\n  /** @internal */\n  public toJSON() {\n    return this.definition;\n  }\n\n  /** The logic invoked as actors by this state node. */\n  public get invoke(): Array<\n    InvokeDefinition<\n      TContext,\n      TEvent,\n      ProvidedActor,\n      ParameterizedObject,\n      ParameterizedObject,\n      string,\n      TODO, // TEmitted\n      TODO // TMeta\n    >\n  > {\n    return memo(this, 'invoke', () =>\n      toArray(this.config.invoke).map((invokeConfig, i) => {\n        const { src, systemId } = invokeConfig;\n        const resolvedId = invokeConfig.id ?? createInvokeId(this.id, i);\n        const sourceName =\n          typeof src === 'string'\n            ? src\n            : `xstate.invoke.${createInvokeId(this.id, i)}`;\n\n        return {\n          ...invokeConfig,\n          src: sourceName,\n          id: resolvedId,\n          systemId: systemId,\n          toJSON() {\n            const { onDone, onError, ...invokeDefValues } = invokeConfig;\n            return {\n              ...invokeDefValues,\n              type: 'xstate.invoke',\n              src: sourceName,\n              id: resolvedId\n            };\n          }\n        } as InvokeDefinition<\n          TContext,\n          TEvent,\n          ProvidedActor,\n          ParameterizedObject,\n          ParameterizedObject,\n          string,\n          TODO, // TEmitted\n          TODO // TMeta\n        >;\n      })\n    );\n  }\n\n  /** The mapping of events to transitions. */\n  public get on(): TransitionDefinitionMap<TContext, TEvent> {\n    return memo(this, 'on', () => {\n      const transitions = this.transitions;\n\n      return [...transitions]\n        .flatMap(([descriptor, t]) => t.map((t) => [descriptor, t] as const))\n        .reduce(\n          (map: any, [descriptor, transition]) => {\n            map[descriptor] = map[descriptor] || [];\n            map[descriptor].push(transition);\n            return map;\n          },\n          {} as TransitionDefinitionMap<TContext, TEvent>\n        );\n    });\n  }\n\n  public get after(): Array<DelayedTransitionDefinition<TContext, TEvent>> {\n    return memo(\n      this,\n      'delayedTransitions',\n      () => getDelayedTransitions(this) as any\n    );\n  }\n\n  public get initial(): InitialTransitionDefinition<TContext, TEvent> {\n    return memo(this, 'initial', () =>\n      formatInitialTransition(this, this.config.initial)\n    );\n  }\n\n  /** @internal */\n  public next(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      any,\n      any,\n      any,\n      any,\n      any, // TMeta\n      any // TStateSchema\n    >,\n    event: TEvent\n  ): TransitionDefinition<TContext, TEvent>[] | undefined {\n    const eventType = event.type;\n    const actions: UnknownAction[] = [];\n\n    let selectedTransition: TransitionDefinition<TContext, TEvent> | undefined;\n\n    const candidates: Array<TransitionDefinition<TContext, TEvent>> = memo(\n      this,\n      `candidates-${eventType}`,\n      () => getCandidates(this, eventType)\n    );\n\n    for (const candidate of candidates) {\n      const { guard } = candidate;\n      const resolvedContext = snapshot.context;\n\n      let guardPassed = false;\n\n      try {\n        guardPassed =\n          !guard ||\n          evaluateGuard<TContext, TEvent>(\n            guard,\n            resolvedContext,\n            event,\n            snapshot\n          );\n      } catch (err: any) {\n        const guardType =\n          typeof guard === 'string'\n            ? guard\n            : typeof guard === 'object'\n              ? guard.type\n              : undefined;\n        throw new Error(\n          `Unable to evaluate guard ${\n            guardType ? `'${guardType}' ` : ''\n          }in transition for event '${eventType}' in state node '${\n            this.id\n          }':\\n${err.message}`\n        );\n      }\n\n      if (guardPassed) {\n        actions.push(...candidate.actions);\n        selectedTransition = candidate;\n        break;\n      }\n    }\n\n    return selectedTransition ? [selectedTransition] : undefined;\n  }\n\n  /** All the event types accepted by this state node and its descendants. */\n  public get events(): Array<EventDescriptor<TEvent>> {\n    return memo(this, 'events', () => {\n      const { states } = this;\n      const events = new Set(this.ownEvents);\n\n      if (states) {\n        for (const stateId of Object.keys(states)) {\n          const state = states[stateId];\n          if (state.states) {\n            for (const event of state.events) {\n              events.add(`${event}`);\n            }\n          }\n        }\n      }\n\n      return Array.from(events);\n    });\n  }\n\n  /**\n   * All the events that have transitions directly from this state node.\n   *\n   * Excludes any inert events.\n   */\n  public get ownEvents(): Array<EventDescriptor<TEvent>> {\n    const keys = Object.keys(Object.fromEntries(this.transitions));\n    const events = new Set(\n      keys.filter((descriptor) => {\n        return this.transitions\n          .get(descriptor)!\n          .some(\n            (transition) =>\n              !(\n                !transition.target &&\n                !transition.actions.length &&\n                !transition.reenter\n              )\n          );\n      })\n    );\n\n    return Array.from(events);\n  }\n}\n","import isDevelopment from '#is-development';\nimport { assign } from './actions.ts';\nimport { $$ACTOR_TYPE, createActor } from './createActor.ts';\nimport { createInitEvent } from './eventUtils.ts';\nimport {\n  createMachineSnapshot,\n  getPersistedSnapshot,\n  MachineSnapshot\n} from './State.ts';\nimport { StateNode } from './StateNode.ts';\nimport {\n  formatRouteTransitions,\n  getAllStateNodes,\n  getStateNodeByPath,\n  getStateNodes,\n  initialMicrostep,\n  isInFinalState,\n  isStateId,\n  macrostep,\n  resolveActionsAndContext,\n  resolveStateValue,\n  transitionNode\n} from './stateUtils.ts';\nimport { AnyActorSystem } from './system.ts';\nimport type {\n  ActorLogic,\n  ActorScope,\n  AnyActorLogic,\n  AnyActorRef,\n  AnyActorScope,\n  AnyEventObject,\n  DoNotInfer,\n  Equals,\n  EventDescriptor,\n  EventObject,\n  HistoryValue,\n  InternalMachineImplementations,\n  MachineConfig,\n  MachineContext,\n  MachineImplementationsSimplified,\n  MetaObject,\n  ParameterizedObject,\n  ProvidedActor,\n  Snapshot,\n  SnapshotFrom,\n  StateMachineDefinition,\n  StateValue,\n  TransitionDefinition,\n  ResolvedStateMachineTypes,\n  StateSchema,\n  SnapshotStatus\n} from './types.ts';\nimport { resolveReferencedActor, toStatePath } from './utils.ts';\n\nconst STATE_IDENTIFIER = '#';\n\nexport class StateMachine<\n  TContext extends MachineContext,\n  TEvent extends EventObject,\n  TChildren extends Record<string, AnyActorRef | undefined>,\n  TActor extends ProvidedActor,\n  TAction extends ParameterizedObject,\n  TGuard extends ParameterizedObject,\n  TDelay extends string,\n  TStateValue extends StateValue,\n  TTag extends string,\n  TInput,\n  TOutput,\n  TEmitted extends EventObject,\n  TMeta extends MetaObject,\n  TStateSchema extends StateSchema\n> implements\n    ActorLogic<\n      MachineSnapshot<\n        TContext,\n        TEvent,\n        TChildren,\n        TStateValue,\n        TTag,\n        TOutput,\n        TMeta,\n        TStateSchema\n      >,\n      TEvent,\n      TInput,\n      AnyActorSystem,\n      TEmitted\n    >\n{\n  /** The machine's own version. */\n  public version?: string;\n\n  public schemas: unknown;\n\n  public implementations: MachineImplementationsSimplified<TContext, TEvent>;\n\n  /** @internal */\n  public __xstatenode = true as const;\n\n  /** @internal */\n  public idMap: Map<string, StateNode<TContext, TEvent>> = new Map();\n\n  public root: StateNode<TContext, TEvent>;\n\n  public id: string;\n\n  public states: StateNode<TContext, TEvent>['states'];\n  public events: Array<EventDescriptor<TEvent>>;\n\n  constructor(\n    /** The raw config used to create the machine. */\n    public config: MachineConfig<\n      TContext,\n      TEvent,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      TOutput,\n      any, // TEmitted\n      any // TMeta\n    > & {\n      schemas?: unknown;\n    },\n    implementations?: MachineImplementationsSimplified<TContext, TEvent>\n  ) {\n    this.id = config.id || '(machine)';\n    this.implementations = {\n      actors: implementations?.actors ?? {},\n      actions: implementations?.actions ?? {},\n      delays: implementations?.delays ?? {},\n      guards: implementations?.guards ?? {}\n    };\n    this.version = this.config.version;\n    this.schemas = this.config.schemas;\n\n    this.transition = this.transition.bind(this);\n    this.getInitialSnapshot = this.getInitialSnapshot.bind(this);\n    this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this);\n    this.restoreSnapshot = this.restoreSnapshot.bind(this);\n    this.start = this.start.bind(this);\n\n    this.root = new StateNode(config, {\n      _key: this.id,\n      _machine: this as any\n    });\n\n    this.root._initialize();\n    formatRouteTransitions(this.root);\n\n    this.states = this.root.states; // TODO: remove!\n    this.events = this.root.events;\n\n    if (\n      isDevelopment &&\n      !('output' in this.root) &&\n      Object.values(this.states).some(\n        (state) => state.type === 'final' && 'output' in state\n      )\n    ) {\n      console.warn(\n        'Missing `machine.output` declaration (top-level final state with output detected)'\n      );\n    }\n  }\n\n  /**\n   * Clones this state machine with the provided implementations.\n   *\n   * @param implementations Options (`actions`, `guards`, `actors`, `delays`) to\n   *   recursively merge with the existing options.\n   * @returns A new `StateMachine` instance with the provided implementations.\n   */\n  public provide(\n    implementations: InternalMachineImplementations<\n      ResolvedStateMachineTypes<\n        TContext,\n        DoNotInfer<TEvent>,\n        TActor,\n        TAction,\n        TGuard,\n        TDelay,\n        TTag,\n        TEmitted\n      >\n    >\n  ): StateMachine<\n    TContext,\n    TEvent,\n    TChildren,\n    TActor,\n    TAction,\n    TGuard,\n    TDelay,\n    TStateValue,\n    TTag,\n    TInput,\n    TOutput,\n    TEmitted,\n    TMeta,\n    TStateSchema\n  > {\n    const { actions, guards, actors, delays } = this.implementations;\n\n    return new StateMachine(this.config, {\n      actions: { ...actions, ...implementations.actions },\n      guards: { ...guards, ...implementations.guards },\n      actors: { ...actors, ...implementations.actors },\n      delays: { ...delays, ...implementations.delays }\n    });\n  }\n\n  public resolveState(\n    config: {\n      value: StateValue;\n      context?: TContext;\n      historyValue?: HistoryValue<TContext, TEvent>;\n      status?: SnapshotStatus;\n      output?: TOutput;\n      error?: unknown;\n    } & (Equals<TContext, MachineContext> extends false\n      ? { context: unknown }\n      : {})\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TStateSchema\n  > {\n    const resolvedStateValue = resolveStateValue(this.root, config.value);\n    const nodeSet = getAllStateNodes(\n      getStateNodes(this.root, resolvedStateValue)\n    );\n\n    return createMachineSnapshot(\n      {\n        _nodes: [...nodeSet],\n        context: config.context || ({} as TContext),\n        children: {},\n        status: isInFinalState(nodeSet, this.root)\n          ? 'done'\n          : config.status || 'active',\n        output: config.output,\n        error: config.error,\n        historyValue: config.historyValue\n      },\n      this\n    ) as MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >;\n  }\n\n  /**\n   * Determines the next snapshot given the current `snapshot` and received\n   * `event`. Calculates a full macrostep from all microsteps.\n   *\n   * @param snapshot The current snapshot\n   * @param event The received event\n   */\n  public transition(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >,\n    event: TEvent,\n    actorScope: ActorScope<typeof snapshot, TEvent, AnyActorSystem, TEmitted>\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TStateSchema\n  > {\n    return macrostep(snapshot, event, actorScope, [])\n      .snapshot as typeof snapshot;\n  }\n\n  /**\n   * Determines the next state given the current `state` and `event`. Calculates\n   * a microstep.\n   *\n   * @param state The current state\n   * @param event The received event\n   */\n  public microstep(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >,\n    event: TEvent,\n    actorScope: AnyActorScope\n  ): Array<\n    MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >\n  > {\n    return macrostep(snapshot, event, actorScope, []).microsteps.map(\n      ([s]) => s\n    );\n  }\n\n  public getTransitionData(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >,\n    event: TEvent\n  ): Array<TransitionDefinition<TContext, TEvent>> {\n    return transitionNode(this.root, snapshot.value, snapshot, event) || [];\n  }\n\n  /**\n   * The initial state _before_ evaluating any microsteps. This \"pre-initial\"\n   * state is provided to initial actions executed in the initial state.\n   *\n   * @internal\n   */\n  _getPreInitialState(\n    actorScope: AnyActorScope,\n    initEvent: any,\n    internalQueue: AnyEventObject[]\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TStateSchema\n  > {\n    const { context } = this.config;\n\n    const preInitial = createMachineSnapshot(\n      {\n        context:\n          typeof context !== 'function' && context ? context : ({} as TContext),\n        _nodes: [this.root],\n        children: {},\n        status: 'active'\n      },\n      this\n    );\n\n    if (typeof context === 'function') {\n      const assignment = ({ spawn, event, self }: any) =>\n        context({ spawn, input: event.input, self });\n      return resolveActionsAndContext(\n        preInitial,\n        initEvent,\n        actorScope,\n        [assign(assignment)],\n        internalQueue,\n        undefined\n      ) as SnapshotFrom<this>;\n    }\n\n    return preInitial as SnapshotFrom<this>;\n  }\n\n  /**\n   * Returns the initial `State` instance, with reference to `self` as an\n   * `ActorRef`.\n   */\n  public getInitialSnapshot(\n    actorScope: ActorScope<\n      MachineSnapshot<\n        TContext,\n        TEvent,\n        TChildren,\n        TStateValue,\n        TTag,\n        TOutput,\n        TMeta,\n        TStateSchema\n      >,\n      TEvent,\n      AnyActorSystem,\n      TEmitted\n    >,\n    input?: TInput\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TStateSchema\n  > {\n    const initEvent = createInitEvent(input) as unknown as TEvent; // TODO: fix;\n    const internalQueue: AnyEventObject[] = [];\n    const preInitialState = this._getPreInitialState(\n      actorScope,\n      initEvent,\n      internalQueue\n    );\n    const [nextState] = initialMicrostep(\n      this.root,\n      preInitialState,\n      actorScope,\n      initEvent,\n      internalQueue\n    );\n\n    const { snapshot: macroState } = macrostep(\n      nextState,\n      initEvent as AnyEventObject,\n      actorScope,\n      internalQueue\n    );\n\n    return macroState as SnapshotFrom<this>;\n  }\n\n  public start(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >\n  ): void {\n    Object.values(snapshot.children as Record<string, AnyActorRef>).forEach(\n      (child: any) => {\n        if (child.getSnapshot().status === 'active') {\n          child.start();\n        }\n      }\n    );\n  }\n\n  public getStateNodeById(stateId: string): StateNode<TContext, TEvent> {\n    const fullPath = toStatePath(stateId);\n    const relativePath = fullPath.slice(1);\n    const resolvedStateId = isStateId(fullPath[0])\n      ? fullPath[0].slice(STATE_IDENTIFIER.length)\n      : fullPath[0];\n\n    const stateNode = this.idMap.get(resolvedStateId);\n    if (!stateNode) {\n      throw new Error(\n        `Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`\n      );\n    }\n    return getStateNodeByPath(stateNode, relativePath);\n  }\n\n  public get definition(): StateMachineDefinition<TContext, TEvent> {\n    return this.root.definition;\n  }\n\n  public toJSON() {\n    return this.definition;\n  }\n\n  public getPersistedSnapshot(\n    snapshot: MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >,\n    options?: unknown\n  ) {\n    return getPersistedSnapshot(snapshot, options);\n  }\n\n  public restoreSnapshot(\n    snapshot: Snapshot<unknown>,\n    _actorScope: ActorScope<\n      MachineSnapshot<\n        TContext,\n        TEvent,\n        TChildren,\n        TStateValue,\n        TTag,\n        TOutput,\n        TMeta,\n        TStateSchema\n      >,\n      TEvent,\n      AnyActorSystem,\n      TEmitted\n    >\n  ): MachineSnapshot<\n    TContext,\n    TEvent,\n    TChildren,\n    TStateValue,\n    TTag,\n    TOutput,\n    TMeta,\n    TStateSchema\n  > {\n    const children: Record<string, AnyActorRef> = {};\n    const snapshotChildren: Record<\n      string,\n      {\n        src: string | AnyActorLogic;\n        snapshot: Snapshot<unknown>;\n        syncSnapshot?: boolean;\n        systemId?: string;\n      }\n    > = (snapshot as any).children;\n\n    Object.keys(snapshotChildren).forEach((actorId) => {\n      const actorData = snapshotChildren[actorId];\n      const childState = actorData.snapshot;\n      const src = actorData.src;\n\n      const logic =\n        typeof src === 'string' ? resolveReferencedActor(this, src) : src;\n\n      if (!logic) {\n        return;\n      }\n\n      const actorRef = createActor(logic, {\n        id: actorId,\n        parent: _actorScope.self,\n        syncSnapshot: actorData.syncSnapshot,\n        snapshot: childState,\n        src,\n        systemId: actorData.systemId\n      });\n\n      children[actorId] = actorRef;\n    });\n\n    function resolveHistoryReferencedState(\n      root: StateNode<TContext, TEvent>,\n      referenced: { id: string } | StateNode<TContext, TEvent>\n    ) {\n      if (referenced instanceof StateNode) {\n        return referenced;\n      }\n      try {\n        return root.machine.getStateNodeById(referenced.id);\n      } catch {\n        if (isDevelopment) {\n          console.warn(`Could not resolve StateNode for id: ${referenced.id}`);\n        }\n      }\n    }\n\n    function reviveHistoryValue(\n      root: StateNode<TContext, TEvent>,\n      historyValue: Record<\n        string,\n        ({ id: string } | StateNode<TContext, TEvent>)[]\n      >\n    ): HistoryValue<TContext, TEvent> {\n      if (!historyValue || typeof historyValue !== 'object') {\n        return {};\n      }\n      const revived: HistoryValue<TContext, TEvent> = {};\n      for (const key in historyValue) {\n        const arr = historyValue[key];\n\n        for (const item of arr) {\n          const resolved = resolveHistoryReferencedState(root, item);\n\n          if (!resolved) {\n            continue;\n          }\n\n          revived[key] ??= [];\n          revived[key].push(resolved);\n        }\n      }\n      return revived;\n    }\n\n    const revivedHistoryValue = reviveHistoryValue(\n      this.root,\n      (snapshot as any).historyValue\n    );\n\n    const restoredSnapshot = createMachineSnapshot(\n      {\n        ...(snapshot as any),\n        children,\n        _nodes: Array.from(\n          getAllStateNodes(getStateNodes(this.root, (snapshot as any).value))\n        ),\n        historyValue: revivedHistoryValue\n      },\n      this\n    ) as MachineSnapshot<\n      TContext,\n      TEvent,\n      TChildren,\n      TStateValue,\n      TTag,\n      TOutput,\n      TMeta,\n      TStateSchema\n    >;\n\n    const seen = new Set();\n\n    function reviveContext(\n      contextPart: Record<string, unknown>,\n      children: Record<string, AnyActorRef>\n    ) {\n      if (seen.has(contextPart)) {\n        return;\n      }\n      seen.add(contextPart);\n      for (const key in contextPart) {\n        const value: unknown = contextPart[key];\n\n        if (value && typeof value === 'object') {\n          if ('xstate$$type' in value && value.xstate$$type === $$ACTOR_TYPE) {\n            contextPart[key] = children[(value as any).id];\n            continue;\n          }\n          reviveContext(value as typeof contextPart, children);\n        }\n      }\n    }\n\n    reviveContext(restoredSnapshot.context, children);\n\n    return restoredSnapshot;\n  }\n}\n","import {\n  SerializationConfig,\n  StatePath,\n  TestMeta,\n  TestPathResult\n} from './types.ts';\nimport { AnyMachineSnapshot, MachineContext } from '../index.ts';\n\ninterface TestResultStringOptions extends SerializationConfig<any, any> {\n  formatColor: (color: string, string: string) => string;\n}\n\nexport function simpleStringify(value: any): string {\n  return JSON.stringify(value);\n}\n\nexport function formatPathTestResult(\n  path: StatePath<any, any>,\n  testPathResult: TestPathResult,\n  options?: Partial<TestResultStringOptions>\n): string {\n  const resolvedOptions: TestResultStringOptions = {\n    formatColor: (_color, string) => string,\n    serializeState: simpleStringify,\n    serializeEvent: simpleStringify,\n    ...options\n  };\n\n  const { formatColor, serializeState, serializeEvent } = resolvedOptions;\n\n  const { state } = path;\n\n  const targetStateString = serializeState(\n    state,\n    path.steps.length ? path.steps[path.steps.length - 1].event : undefined\n  );\n\n  let errMessage = '';\n  let hasFailed = false;\n  errMessage +=\n    '\\nPath:\\n' +\n    testPathResult.steps\n      .map((s, i, steps) => {\n        const stateString = serializeState(\n          s.step.state,\n          i > 0 ? steps[i - 1].step.event : undefined\n        );\n        const eventString = serializeEvent(s.step.event);\n\n        const stateResult = `\\tState: ${\n          hasFailed\n            ? formatColor('gray', stateString)\n            : s.state.error\n              ? ((hasFailed = true), formatColor('redBright', stateString))\n              : formatColor('greenBright', stateString)\n        }`;\n        const eventResult = `\\tEvent: ${\n          hasFailed\n            ? formatColor('gray', eventString)\n            : s.event.error\n              ? ((hasFailed = true), formatColor('red', eventString))\n              : formatColor('green', eventString)\n        }`;\n\n        return [stateResult, eventResult].join('\\n');\n      })\n      .concat(\n        `\\tState: ${\n          hasFailed\n            ? formatColor('gray', targetStateString)\n            : testPathResult.state.error\n              ? formatColor('red', targetStateString)\n              : formatColor('green', targetStateString)\n        }`\n      )\n      .join('\\n\\n');\n\n  return errMessage;\n}\n\nexport function getDescription<T, TContext extends MachineContext>(\n  snapshot: AnyMachineSnapshot\n): string {\n  const contextString = !Object.keys(snapshot.context).length\n    ? ''\n    : `(${JSON.stringify(snapshot.context)})`;\n\n  const stateStrings = snapshot._nodes\n    .filter((sn) => sn.type === 'atomic' || sn.type === 'final')\n    .map(({ id, path }) => {\n      const meta = snapshot.getMeta()[id] as TestMeta<T, TContext>;\n      if (!meta) {\n        return `\"${path.join('.')}\"`;\n      }\n\n      const { description } = meta;\n\n      if (typeof description === 'function') {\n        return description(snapshot);\n      }\n\n      return description ? `\"${description}\"` : JSON.stringify(snapshot.value);\n    });\n\n  return (\n    `state${stateStrings.length === 1 ? '' : 's'} ` +\n    stateStrings.join(', ') +\n    ` ${contextString}`.trim()\n  );\n}\n","import { StatePath } from './index.ts';\nimport { EventObject, Snapshot } from '../index.ts';\nimport { simpleStringify } from './utils.ts';\n\n/**\n * Deduplicates your paths so that A -> B is not executed separately to A -> B\n * -> C\n */\nexport const deduplicatePaths = <\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject\n>(\n  paths: StatePath<TSnapshot, TEvent>[],\n  serializeEvent: (event: TEvent) => string = simpleStringify\n): StatePath<TSnapshot, TEvent>[] => {\n  /** Put all paths on the same level so we can dedup them */\n  const allPathsWithEventSequence: Array<{\n    path: StatePath<TSnapshot, TEvent>;\n    eventSequence: string[];\n  }> = [];\n\n  paths.forEach((path) => {\n    allPathsWithEventSequence.push({\n      path,\n      eventSequence: path.steps.map((step) => serializeEvent(step.event))\n    });\n  });\n\n  // Sort by path length, descending\n  allPathsWithEventSequence.sort(\n    (a, z) => z.path.steps.length - a.path.steps.length\n  );\n\n  const superpathsWithEventSequence: typeof allPathsWithEventSequence = [];\n\n  /** Filter out the paths that are subpaths of superpaths */\n  pathLoop: for (const pathWithEventSequence of allPathsWithEventSequence) {\n    // Check each existing superpath to see if the path is a subpath of it\n    superpathLoop: for (const superpathWithEventSequence of superpathsWithEventSequence) {\n      // eslint-disable-next-line @typescript-eslint/no-for-in-array\n      for (const i in pathWithEventSequence.eventSequence) {\n        // Check event sequence to determine if path is subpath, e.g.:\n        //\n        // This will short-circuit the check\n        // ['a', 'b', 'c', 'd'] (superpath)\n        // ['a', 'b', 'x']      (path)\n        //\n        // This will not short-circuit; path is subpath\n        // ['a', 'b', 'c', 'd'] (superpath)\n        // ['a', 'b', 'c']      (path)\n        if (\n          pathWithEventSequence.eventSequence[i] !==\n          superpathWithEventSequence.eventSequence[i]\n        ) {\n          // If the path is different from the superpath,\n          // continue to the next superpath\n          continue superpathLoop;\n        }\n      }\n\n      // If we reached here, path is subpath of superpath\n      // Continue & do not add path to superpaths\n      continue pathLoop;\n    }\n\n    // If we reached here, path is not a subpath of any existing superpaths\n    // So add it to the superpaths\n    superpathsWithEventSequence.push(pathWithEventSequence);\n  }\n\n  return superpathsWithEventSequence.map((path) => path.path);\n};\n","import { getShortestPaths, getSimplePaths } from './index.ts';\nimport { EventObject, Snapshot } from '../index.ts';\nimport { PathGenerator } from './types.ts';\n\nexport const createShortestPathsGen =\n  <\n    TSnapshot extends Snapshot<unknown>,\n    TEvent extends EventObject,\n    TInput\n  >(): PathGenerator<TSnapshot, TEvent, TInput> =>\n  (logic, defaultOptions) => {\n    const paths = getShortestPaths(logic, defaultOptions);\n\n    return paths;\n  };\n\nexport const createSimplePathsGen =\n  <\n    TSnapshot extends Snapshot<unknown>,\n    TEvent extends EventObject,\n    TInput\n  >(): PathGenerator<TSnapshot, TEvent, TInput> =>\n  (logic, defaultOptions) => {\n    const paths = getSimplePaths(logic, defaultOptions);\n\n    return paths;\n  };\n","import { AnyStateMachine, AnyStateNode } from '../index.ts';\n\nconst validateState = (state: AnyStateNode) => {\n  if (state.invoke.length > 0) {\n    throw new Error('Invocations on test machines are not supported');\n  }\n  if (state.after.length > 0) {\n    throw new Error('After events on test machines are not supported');\n  }\n  // TODO: this doesn't account for always transitions\n  [\n    ...state.entry,\n    ...state.exit,\n    ...[...state.transitions.values()].flatMap((t) =>\n      t.flatMap((t) => t.actions)\n    )\n  ].forEach((action) => {\n    // TODO: this doesn't check referenced actions, only the inline ones\n    if (\n      typeof action === 'function' &&\n      'resolve' in action &&\n      typeof (action as any).delay === 'number'\n    ) {\n      throw new Error('Delayed actions on test machines are not supported');\n    }\n  });\n\n  for (const child of Object.values(state.states)) {\n    validateState(child);\n  }\n};\n\nexport const validateMachine = (machine: AnyStateMachine) => {\n  validateState(machine.root);\n};\n","import {\n  getPathsFromEvents,\n  getAdjacencyMap,\n  joinPaths,\n  serializeSnapshot\n} from './index.ts';\nimport type {\n  AdjacencyMap,\n  SerializedEvent,\n  SerializedSnapshot,\n  StatePath,\n  Step,\n  TraversalOptions,\n  EventExecutor,\n  PathGenerator,\n  TestModelOptions,\n  TestParam,\n  TestPath,\n  TestPathResult,\n  TestStepResult\n} from './types.ts';\nimport {\n  EventObject,\n  ActorLogic,\n  Snapshot,\n  isMachineSnapshot,\n  __unsafe_getAllOwnEventDescriptors,\n  AnyActorRef,\n  AnyEventObject,\n  AnyStateMachine,\n  EventFromLogic,\n  MachineContext,\n  MachineSnapshot,\n  SnapshotFrom,\n  StateValue,\n  TODO,\n  InputFrom\n} from '../index.ts';\nimport { deduplicatePaths } from './deduplicatePaths.ts';\nimport {\n  createShortestPathsGen,\n  createSimplePathsGen\n} from './pathGenerators.ts';\nimport {\n  formatPathTestResult,\n  getDescription,\n  simpleStringify\n} from './utils.ts';\nimport { validateMachine } from './validateMachine.ts';\n\ntype GetPathOptions<\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject,\n  TInput\n> = Partial<TraversalOptions<TSnapshot, TEvent, TInput>> & {\n  /**\n   * Whether to allow deduplicate paths so that paths that are contained by\n   * longer paths are included.\n   *\n   * @default false\n   */\n  allowDuplicatePaths?: boolean;\n};\n\n/**\n * Creates a test model that represents an abstract model of a system under test\n * (SUT).\n *\n * The test model is used to generate test paths, which are used to verify that\n * states in the model are reachable in the SUT.\n */\nexport class TestModel<\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject,\n  TInput\n> {\n  public options: TestModelOptions<TSnapshot, TEvent, TInput>;\n  public defaultTraversalOptions?: TraversalOptions<TSnapshot, TEvent, TInput>;\n  public getDefaultOptions(): TestModelOptions<TSnapshot, TEvent, TInput> {\n    return {\n      serializeState: (state) => simpleStringify(state) as SerializedSnapshot,\n      serializeEvent: (event) => simpleStringify(event) as SerializedEvent,\n      // For non-state-machine test models, we cannot identify\n      // separate transitions, so just use event type\n      serializeTransition: (state, event) =>\n        `${simpleStringify(state)}|${event?.type}`,\n      events: [],\n      stateMatcher: (_, stateKey) => stateKey === '*',\n      logger: {\n        log: console.log.bind(console),\n        error: console.error.bind(console)\n      }\n    };\n  }\n\n  constructor(\n    public testLogic: ActorLogic<TSnapshot, TEvent, TInput>,\n    options?: Partial<TestModelOptions<TSnapshot, TEvent, TInput>>\n  ) {\n    this.options = {\n      ...this.getDefaultOptions(),\n      ...options\n    };\n  }\n\n  public getPaths(\n    pathGenerator: PathGenerator<TSnapshot, TEvent, TInput>,\n    options?: GetPathOptions<TSnapshot, TEvent, TInput>\n  ): Array<TestPath<TSnapshot, TEvent>> {\n    const allowDuplicatePaths = options?.allowDuplicatePaths ?? false;\n    const paths = pathGenerator(this.testLogic, this._resolveOptions(options));\n    return (allowDuplicatePaths ? paths : deduplicatePaths(paths)).map(\n      this._toTestPath\n    );\n  }\n\n  public getShortestPaths(\n    options?: GetPathOptions<TSnapshot, TEvent, TInput>\n  ): Array<TestPath<TSnapshot, TEvent>> {\n    return this.getPaths(createShortestPathsGen(), options);\n  }\n\n  public getShortestPathsFrom(\n    paths: Array<TestPath<TSnapshot, TEvent>>,\n    options?: GetPathOptions<TSnapshot, TEvent, TInput>\n  ): Array<TestPath<TSnapshot, TEvent>> {\n    const resultPaths: TestPath<TSnapshot, TEvent>[] = [];\n\n    for (const path of paths) {\n      const shortestPaths = this.getShortestPaths({\n        ...options,\n        fromState: path.state\n      });\n      for (const shortestPath of shortestPaths) {\n        resultPaths.push(this._toTestPath(joinPaths(path, shortestPath)));\n      }\n    }\n\n    return resultPaths;\n  }\n\n  public getSimplePaths(\n    options?: GetPathOptions<TSnapshot, TEvent, TInput>\n  ): Array<TestPath<TSnapshot, TEvent>> {\n    return this.getPaths(createSimplePathsGen(), options);\n  }\n\n  public getSimplePathsFrom(\n    paths: Array<TestPath<TSnapshot, TEvent>>,\n    options?: GetPathOptions<TSnapshot, TEvent, TInput>\n  ): Array<TestPath<TSnapshot, TEvent>> {\n    const resultPaths: TestPath<TSnapshot, TEvent>[] = [];\n\n    for (const path of paths) {\n      const shortestPaths = this.getSimplePaths({\n        ...options,\n        fromState: path.state\n      });\n      for (const shortestPath of shortestPaths) {\n        resultPaths.push(this._toTestPath(joinPaths(path, shortestPath)));\n      }\n    }\n\n    return resultPaths;\n  }\n\n  private _toTestPath = (\n    statePath: StatePath<TSnapshot, TEvent>\n  ): TestPath<TSnapshot, TEvent> => {\n    function formatEvent(event: EventObject): string {\n      const { type, ...other } = event;\n\n      const propertyString = Object.keys(other).length\n        ? ` (${JSON.stringify(other)})`\n        : '';\n\n      return `${type}${propertyString}`;\n    }\n\n    const eventsString = statePath.steps\n      .map((s) => formatEvent(s.event))\n      .join(' → ');\n    return {\n      ...statePath,\n      test: (params: TestParam<TSnapshot, TEvent>) =>\n        this.testPath(statePath, params),\n      description: isMachineSnapshot(statePath.state)\n        ? `Reaches ${getDescription(\n            statePath.state as any\n          ).trim()}: ${eventsString}`\n        : JSON.stringify(statePath.state)\n    };\n  };\n\n  public getPathsFromEvents(\n    events: TEvent[],\n    options?: GetPathOptions<TSnapshot, TEvent, TInput>\n  ): Array<TestPath<TSnapshot, TEvent>> {\n    const paths = getPathsFromEvents(this.testLogic, events, options);\n\n    return paths.map(this._toTestPath);\n  }\n\n  /**\n   * An array of adjacencies, which are objects that represent each `state` with\n   * the `nextState` given the `event`.\n   */\n  public getAdjacencyMap(): AdjacencyMap<TSnapshot, TEvent> {\n    const adjMap = getAdjacencyMap(this.testLogic, this.options);\n    return adjMap;\n  }\n\n  public async testPath(\n    path: StatePath<TSnapshot, TEvent>,\n    params: TestParam<TSnapshot, TEvent>,\n    options?: Partial<TestModelOptions<TSnapshot, TEvent, TInput>>\n  ): Promise<TestPathResult> {\n    const testPathResult: TestPathResult = {\n      steps: [],\n      state: {\n        error: null\n      }\n    };\n\n    try {\n      for (const step of path.steps) {\n        const testStepResult: TestStepResult = {\n          step,\n          state: { error: null },\n          event: { error: null }\n        };\n\n        testPathResult.steps.push(testStepResult);\n\n        try {\n          await this.testTransition(params, step);\n        } catch (err: any) {\n          testStepResult.event.error = err;\n\n          throw err;\n        }\n\n        try {\n          await this.testState(params, step.state, options);\n        } catch (err: any) {\n          testStepResult.state.error = err;\n\n          throw err;\n        }\n      }\n    } catch (err: any) {\n      // TODO: make option\n      err.message += formatPathTestResult(path, testPathResult, this.options);\n      throw err;\n    }\n\n    return testPathResult;\n  }\n\n  public async testState(\n    params: TestParam<TSnapshot, TEvent>,\n    state: TSnapshot,\n    options?: Partial<TestModelOptions<TSnapshot, TEvent, TInput>>\n  ): Promise<void> {\n    const resolvedOptions = this._resolveOptions(options);\n\n    const stateTestKeys = this._getStateTestKeys(\n      params,\n      state,\n      resolvedOptions\n    );\n\n    for (const stateTestKey of stateTestKeys) {\n      await params.states?.[stateTestKey](state);\n    }\n  }\n\n  private _getStateTestKeys(\n    params: TestParam<TSnapshot, TEvent>,\n    state: TSnapshot,\n    resolvedOptions: TestModelOptions<TSnapshot, TEvent, TInput>\n  ) {\n    const states = params.states || {};\n    const stateTestKeys = Object.keys(states).filter((stateKey) => {\n      return resolvedOptions.stateMatcher(state, stateKey);\n    });\n\n    // Fallthrough state tests\n    if (!stateTestKeys.length && '*' in states) {\n      stateTestKeys.push('*');\n    }\n\n    return stateTestKeys;\n  }\n\n  private _getEventExec(\n    params: TestParam<TSnapshot, TEvent>,\n    step: Step<TSnapshot, TEvent>\n  ) {\n    const eventExec =\n      params.events?.[(step.event as any).type as TEvent['type']];\n\n    return eventExec;\n  }\n\n  public async testTransition(\n    params: TestParam<TSnapshot, TEvent>,\n    step: Step<TSnapshot, TEvent>\n  ): Promise<void> {\n    const eventExec = this._getEventExec(params, step);\n    await (eventExec as EventExecutor<TSnapshot, TEvent>)?.(step);\n  }\n\n  private _resolveOptions(\n    options?: Partial<TestModelOptions<TSnapshot, TEvent, TInput>>\n  ): TestModelOptions<TSnapshot, TEvent, TInput> {\n    return { ...this.defaultTraversalOptions, ...this.options, ...options };\n  }\n}\n\nfunction stateValuesEqual(\n  a: StateValue | undefined,\n  b: StateValue | undefined\n): boolean {\n  if (a === b) {\n    return true;\n  }\n\n  if (a === undefined || b === undefined) {\n    return false;\n  }\n\n  if (typeof a === 'string' || typeof b === 'string') {\n    return a === b;\n  }\n\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n\n  return (\n    aKeys.length === bKeys.length &&\n    aKeys.every((key) => stateValuesEqual(a[key], b[key]))\n  );\n}\n\nfunction serializeMachineTransition(\n  snapshot: MachineSnapshot<\n    MachineContext,\n    EventObject,\n    Record<string, AnyActorRef | undefined>,\n    StateValue,\n    string,\n    unknown,\n    TODO, // TMeta\n    TODO // TStateSchema\n  >,\n  event: AnyEventObject | undefined,\n  previousSnapshot:\n    | MachineSnapshot<\n        MachineContext,\n        EventObject,\n        Record<string, AnyActorRef | undefined>,\n        StateValue,\n        string,\n        unknown,\n        TODO, // TMeta\n        TODO // TStateSchema\n      >\n    | undefined,\n  { serializeEvent }: { serializeEvent: (event: AnyEventObject) => string }\n): string {\n  // TODO: the stateValuesEqual check here is very likely not exactly correct\n  // but I'm not sure what the correct check is and what this is trying to do\n  if (\n    !event ||\n    (previousSnapshot &&\n      stateValuesEqual(previousSnapshot.value, snapshot.value))\n  ) {\n    return '';\n  }\n\n  const prevStateString = previousSnapshot\n    ? ` from ${simpleStringify(previousSnapshot.value)}`\n    : '';\n\n  return ` via ${serializeEvent(event)}${prevStateString}`;\n}\n\n/**\n * Creates a test model that represents an abstract model of a system under test\n * (SUT).\n *\n * The test model is used to generate test paths, which are used to verify that\n * states in the `machine` are reachable in the SUT.\n *\n * @example\n *\n * ```js\n * const toggleModel = createModel(toggleMachine).withEvents({\n *   TOGGLE: {\n *     exec: async (page) => {\n *       await page.click('input');\n *     }\n *   }\n * });\n * ```\n *\n * @param machine The state machine used to represent the abstract model.\n * @param options Options for the created test model:\n *\n *   - `events`: an object mapping string event types (e.g., `SUBMIT`) to an event\n *       test config (e.g., `{exec: () => {...}, cases: [...]}`)\n */\nexport function createTestModel<TMachine extends AnyStateMachine>(\n  machine: TMachine,\n  options?: Partial<\n    TestModelOptions<\n      SnapshotFrom<TMachine>,\n      EventFromLogic<TMachine>,\n      InputFrom<TMachine>\n    >\n  >\n): TestModel<SnapshotFrom<TMachine>, EventFromLogic<TMachine>, unknown> {\n  validateMachine(machine);\n\n  const serializeEvent = (options?.serializeEvent ?? simpleStringify) as (\n    event: AnyEventObject\n  ) => string;\n  const serializeTransition =\n    options?.serializeTransition ?? serializeMachineTransition;\n  const { events: getEvents, ...otherOptions } = options ?? {};\n\n  const testModel = new TestModel<\n    SnapshotFrom<TMachine>,\n    EventFromLogic<TMachine>,\n    unknown\n  >(machine as any, {\n    serializeState: (state, event, prevState) => {\n      // Only consider the `state` if `serializeTransition()` is opted out (empty string)\n      return `${serializeSnapshot(state)}${serializeTransition(\n        state,\n        event,\n        prevState,\n        {\n          serializeEvent\n        }\n      )}` as SerializedSnapshot;\n    },\n    stateMatcher: (state, key) => {\n      return key.startsWith('#')\n        ? (state as any)._nodes.includes(machine.getStateNodeById(key))\n        : (state as any).matches(key);\n    },\n    events: (state) => {\n      const events =\n        typeof getEvents === 'function' ? getEvents(state) : (getEvents ?? []);\n\n      return __unsafe_getAllOwnEventDescriptors(state).flatMap(\n        (eventType: string) => {\n          if (events.some((e) => (e as EventObject).type === eventType)) {\n            return events.filter((e) => (e as EventObject).type === eventType);\n          }\n\n          return [{ type: eventType } as any]; // TODO: fix types\n        }\n      );\n    },\n    ...otherOptions\n  });\n\n  return testModel;\n}\n","import { AnyActorScope, createEmptyActor } from '../index.ts';\n\nexport function createMockActorScope(): AnyActorScope {\n  const emptyActor = createEmptyActor();\n  return {\n    self: emptyActor,\n    logger: console.log,\n    id: '',\n    sessionId: Math.random().toString(32).slice(2),\n    defer: () => {},\n    system: emptyActor.system, // TODO: mock system?\n    stopChild: () => {},\n    emit: () => {},\n    actionExecutor: () => {}\n  };\n}\n","import {\n  EventObject,\n  AnyStateMachine,\n  StateMachine,\n  AnyActorLogic,\n  EventFromLogic,\n  Snapshot,\n  __unsafe_getAllOwnEventDescriptors,\n  InputFrom\n} from '../index.ts';\nimport type {\n  SerializedEvent,\n  SerializedSnapshot,\n  StatePath,\n  DirectedGraphEdge,\n  DirectedGraphNode,\n  TraversalOptions,\n  AnyStateNode,\n  TraversalConfig\n} from './types.ts';\nimport { createMockActorScope } from './actorScope.ts';\n\n/**\n * Returns all state nodes of the given `node`.\n *\n * @param stateNode State node to recursively get child state nodes from\n */\nexport function getStateNodes(\n  stateNode: AnyStateNode | AnyStateMachine\n): AnyStateNode[] {\n  const { states } = stateNode;\n  const nodes = Object.keys(states).reduce((accNodes, stateKey) => {\n    const childStateNode = states[stateKey];\n    const childStateNodes = getStateNodes(childStateNode);\n\n    accNodes.push(childStateNode, ...childStateNodes);\n    return accNodes;\n  }, [] as AnyStateNode[]);\n\n  return nodes;\n}\n\nfunction getChildren(stateNode: AnyStateNode): AnyStateNode[] {\n  if (!stateNode.states) {\n    return [];\n  }\n\n  const children = Object.keys(stateNode.states).map((key) => {\n    return stateNode.states[key];\n  });\n\n  return children;\n}\n\nexport function serializeSnapshot(snapshot: Snapshot<any>): SerializedSnapshot {\n  const { value, context } = snapshot as any;\n  return JSON.stringify({\n    value,\n    context: Object.keys(context ?? {}).length ? context : undefined\n  }) as SerializedSnapshot;\n}\n\nfunction serializeEvent<TEvent extends EventObject>(\n  event: TEvent\n): SerializedEvent {\n  return JSON.stringify(event) as SerializedEvent;\n}\n\nexport function createDefaultMachineOptions<TMachine extends AnyStateMachine>(\n  machine: TMachine,\n  options?: TraversalOptions<\n    ReturnType<TMachine['transition']>,\n    EventFromLogic<TMachine>,\n    InputFrom<TMachine>\n  >\n): TraversalOptions<\n  ReturnType<TMachine['transition']>,\n  EventFromLogic<TMachine>,\n  InputFrom<TMachine>\n> {\n  const { events: getEvents, ...otherOptions } = options ?? {};\n  const traversalOptions: TraversalOptions<\n    ReturnType<TMachine['transition']>,\n    EventFromLogic<TMachine>,\n    InputFrom<TMachine>\n  > = {\n    serializeState: serializeSnapshot,\n    serializeEvent,\n    events: (state) => {\n      const events =\n        typeof getEvents === 'function' ? getEvents(state) : (getEvents ?? []);\n      return __unsafe_getAllOwnEventDescriptors(state).flatMap((type) => {\n        const matchingEvents = events.filter((ev) => (ev as any).type === type);\n        if (matchingEvents.length) {\n          return matchingEvents;\n        }\n        return [{ type }];\n      }) as any[];\n    },\n    fromState: machine.getInitialSnapshot(\n      createMockActorScope(),\n      options?.input\n    ) as ReturnType<TMachine['transition']>,\n    ...otherOptions\n  };\n\n  return traversalOptions;\n}\n\nexport function createDefaultLogicOptions(): TraversalOptions<any, any, any> {\n  return {\n    serializeState: (state) => JSON.stringify(state),\n    serializeEvent\n  };\n}\n\nexport function toDirectedGraph(\n  stateMachine: AnyStateNode | AnyStateMachine\n): DirectedGraphNode {\n  const stateNode =\n    stateMachine instanceof StateMachine ? stateMachine.root : stateMachine; // TODO: accept only machines\n\n  const edges: DirectedGraphEdge[] = [...stateNode.transitions.values()]\n    .flat()\n    .flatMap((t, transitionIndex) => {\n      const targets = t.target ? t.target : [stateNode];\n\n      return targets.map((target, targetIndex) => {\n        const edge: DirectedGraphEdge = {\n          id: `${stateNode.id}:${transitionIndex}:${targetIndex}`,\n          source: stateNode,\n          target: target as AnyStateNode,\n          transition: t,\n          label: {\n            text: t.eventType,\n            toJSON: () => ({ text: t.eventType })\n          },\n          toJSON: () => {\n            const { label } = edge;\n\n            return { source: stateNode.id, target: target.id, label };\n          }\n        };\n\n        return edge;\n      });\n    });\n\n  const graph = {\n    id: stateNode.id,\n    stateNode: stateNode,\n    children: getChildren(stateNode).map(toDirectedGraph),\n    edges,\n    toJSON: () => {\n      const { id, children, edges: graphEdges } = graph;\n      return { id, children, edges: graphEdges };\n    }\n  };\n\n  return graph;\n}\n\nfunction isMachineLogic(logic: AnyActorLogic): logic is AnyStateMachine {\n  return 'getStateNodeById' in logic;\n}\n\nexport function resolveTraversalOptions<TLogic extends AnyActorLogic>(\n  logic: TLogic,\n  traversalOptions?: TraversalOptions<\n    ReturnType<TLogic['transition']>,\n    EventFromLogic<TLogic>,\n    InputFrom<TLogic>\n  >,\n  defaultOptions?: TraversalOptions<\n    ReturnType<TLogic['transition']>,\n    EventFromLogic<TLogic>,\n    InputFrom<TLogic>\n  >\n): TraversalConfig<ReturnType<TLogic['transition']>, EventFromLogic<TLogic>> {\n  const resolvedDefaultOptions =\n    defaultOptions ??\n    (isMachineLogic(logic)\n      ? (createDefaultMachineOptions(\n          logic,\n          traversalOptions as any\n        ) as TraversalOptions<\n          ReturnType<TLogic['transition']>,\n          EventFromLogic<TLogic>,\n          InputFrom<TLogic>\n        >)\n      : undefined);\n  const serializeState =\n    traversalOptions?.serializeState ??\n    resolvedDefaultOptions?.serializeState ??\n    ((state) => JSON.stringify(state));\n  const traversalConfig: TraversalConfig<\n    ReturnType<TLogic['transition']>,\n    EventFromLogic<TLogic>\n  > = {\n    serializeState,\n    serializeEvent,\n    events: [],\n    limit: Infinity,\n    fromState: undefined,\n    toState: undefined,\n    // Traversal should not continue past the `toState` predicate\n    // since the target state has already been reached at that point\n    stopWhen: traversalOptions?.toState,\n    ...resolvedDefaultOptions,\n    ...traversalOptions\n  };\n\n  return traversalConfig;\n}\n\nexport function joinPaths<\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject\n>(\n  headPath: StatePath<TSnapshot, TEvent>,\n  tailPath: StatePath<TSnapshot, TEvent>\n): StatePath<TSnapshot, TEvent> {\n  const secondPathSource = tailPath.steps[0].state;\n\n  if (secondPathSource !== headPath.state) {\n    throw new Error(`Paths cannot be joined`);\n  }\n\n  return {\n    state: tailPath.state,\n    // e.g. [A, B, C] + [C, D, E] = [A, B, C, D, E]\n    steps: headPath.steps.concat(tailPath.steps.slice(1)),\n    weight: headPath.weight + tailPath.weight\n  };\n}\n","import {\n  ActorScope,\n  ActorLogic,\n  ActorSystem,\n  EventObject,\n  Snapshot\n} from '../index.ts';\nimport {\n  SerializedEvent,\n  SerializedSnapshot,\n  TraversalOptions,\n  AdjacencyMap,\n  AdjacencyValue\n} from './types';\nimport { resolveTraversalOptions } from './graph.ts';\nimport { createMockActorScope } from './actorScope.ts';\n\nexport function getAdjacencyMap<\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject,\n  TInput,\n  TSystem extends ActorSystem<any> = ActorSystem<any>\n>(\n  logic: ActorLogic<TSnapshot, TEvent, TInput, TSystem>,\n  options: TraversalOptions<TSnapshot, TEvent, TInput>\n): AdjacencyMap<TSnapshot, TEvent> {\n  const { transition } = logic;\n  const {\n    serializeEvent,\n    serializeState,\n    events: getEvents,\n    limit,\n    fromState: customFromState,\n    stopWhen\n  } = resolveTraversalOptions(logic, options);\n  const actorScope = createMockActorScope() as ActorScope<\n    TSnapshot,\n    TEvent,\n    TSystem\n  >;\n  const fromState =\n    customFromState ??\n    logic.getInitialSnapshot(\n      actorScope,\n      // TODO: fix this\n      options.input as TInput\n    );\n  const adj: AdjacencyMap<TSnapshot, TEvent> = {};\n\n  let iterations = 0;\n  const queue: Array<{\n    nextState: TSnapshot;\n    event: TEvent | undefined;\n    prevState: TSnapshot | undefined;\n  }> = [{ nextState: fromState, event: undefined, prevState: undefined }];\n  const stateMap = new Map<SerializedSnapshot, TSnapshot>();\n\n  while (queue.length) {\n    const { nextState: state, event, prevState } = queue.shift()!;\n\n    if (iterations++ > limit) {\n      throw new Error('Traversal limit exceeded');\n    }\n\n    const serializedState = serializeState(\n      state,\n      event,\n      prevState\n    ) as SerializedSnapshot;\n    if (adj[serializedState]) {\n      continue;\n    }\n    stateMap.set(serializedState, state);\n\n    adj[serializedState] = {\n      state,\n      transitions: {}\n    };\n\n    if (stopWhen && stopWhen(state)) {\n      continue;\n    }\n\n    const events =\n      typeof getEvents === 'function' ? getEvents(state) : getEvents;\n\n    for (const nextEvent of events) {\n      const nextSnapshot = transition(state, nextEvent, actorScope);\n\n      adj[serializedState].transitions[\n        serializeEvent(nextEvent) as SerializedEvent\n      ] = {\n        event: nextEvent,\n        state: nextSnapshot\n      };\n      queue.push({\n        nextState: nextSnapshot,\n        event: nextEvent,\n        prevState: state\n      });\n    }\n  }\n\n  return adj;\n}\n\nexport function adjacencyMapToArray<TSnapshot, TEvent>(\n  adjMap: AdjacencyMap<TSnapshot, TEvent>\n): Array<{\n  state: TSnapshot;\n  event: TEvent;\n  nextState: TSnapshot;\n}> {\n  const adjList: Array<{\n    state: TSnapshot;\n    event: TEvent;\n    nextState: TSnapshot;\n  }> = [];\n\n  for (const adjValue of Object.values(adjMap)) {\n    for (const transition of Object.values(\n      (adjValue as AdjacencyValue<TSnapshot, TEvent>).transitions\n    )) {\n      adjList.push({\n        state: (adjValue as AdjacencyValue<TSnapshot, TEvent>).state,\n        event: transition.event,\n        nextState: transition.state\n      });\n    }\n  }\n\n  return adjList;\n}\n","import { StatePath } from './types.ts';\n\n// TODO: rewrite parts of the algorithm leading to this to make this function obsolete\nexport function alterPath<T extends StatePath<any, any>>(path: T): T {\n  let steps: T['steps'] = [];\n\n  if (!path.steps.length) {\n    steps = [\n      {\n        state: path.state,\n        event: { type: 'xstate.init' } as any\n      }\n    ];\n  } else {\n    for (let i = 0; i < path.steps.length; i++) {\n      const step = path.steps[i];\n\n      steps.push({\n        state: step.state,\n        event: i === 0 ? { type: 'xstate.init' } : path.steps[i - 1].event\n      });\n    }\n    steps.push({\n      state: path.state,\n      event: path.steps[path.steps.length - 1].event\n    });\n  }\n  return {\n    ...path,\n    steps\n  };\n}\n","import {\n  ActorScope,\n  ActorLogic,\n  ActorSystem,\n  AnyStateMachine,\n  EventObject,\n  Snapshot\n} from '../index.ts';\nimport { getAdjacencyMap } from './adjacency.ts';\nimport {\n  SerializedEvent,\n  SerializedSnapshot,\n  StatePath,\n  Steps,\n  TraversalOptions\n} from './types.ts';\nimport {\n  resolveTraversalOptions,\n  createDefaultMachineOptions,\n  createDefaultLogicOptions\n} from './graph.ts';\nimport { alterPath } from './alterPath.ts';\nimport { createMockActorScope } from './actorScope.ts';\n\nfunction isMachine(value: any): value is AnyStateMachine {\n  return !!value && '__xstatenode' in value;\n}\n\nexport function getPathsFromEvents<\n  TSnapshot extends Snapshot<unknown>,\n  TEvent extends EventObject,\n  TInput,\n  TSystem extends ActorSystem<any> = ActorSystem<any>\n>(\n  logic: ActorLogic<TSnapshot, TEvent, TInput, TSystem>,\n  events: TEvent[],\n  options?: TraversalOptions<TSnapshot, TEvent, TInput>\n): Array<StatePath<TSnapshot, TEvent>> {\n  const resolvedOptions = resolveTraversalOptions(\n    logic,\n    {\n      events,\n      ...options\n    },\n    (isMachine(logic)\n      ? createDefaultMachineOptions(logic)\n      : createDefaultLogicOptions()) as TraversalOptions<\n      TSnapshot,\n      TEvent,\n      TInput\n    >\n  );\n  const actorScope = createMockActorScope() as ActorScope<\n    TSnapshot,\n    TEvent,\n    TSystem\n  >;\n  const fromState =\n    resolvedOptions.fromState ??\n    logic.getInitialSnapshot(\n      actorScope,\n      // TODO: fix this\n      options?.input as TInput\n    );\n\n  const { serializeState, serializeEvent } = resolvedOptions;\n\n  const adjacency = getAdjacencyMap(logic, resolvedOptions);\n\n  const stateMap = new Map<SerializedSnapshot, TSnapshot>();\n  const steps: Steps<TSnapshot, TEvent> = [];\n\n  const serializedFromState = serializeState(\n    fromState,\n    undefined,\n    undefined\n  ) as SerializedSnapshot;\n  stateMap.set(serializedFromState, fromState);\n\n  let stateSerial = serializedFromState;\n  let state = fromState;\n  for (const event of events) {\n    steps.push({\n      state: stateMap.get(stateSerial)!,\n      event\n    });\n\n    const eventSerial = serializeEvent(event) as SerializedEvent;\n    const { state: nextState, event: _nextEvent } =\n      adjacency[stateSerial].transitions[eventSerial];\n\n    if (!nextState) {\n      throw new Error(\n        `Invalid transition from ${stateSerial} with ${eventSerial}`\n      );\n    }\n    const prevState = stateMap.get(stateSerial);\n    const nextStateSerial = serializeState(\n      nextState,\n      event,\n      prevState\n    ) as SerializedSnapshot;\n    stateMap.set(nextStateSerial, nextState);\n\n    stateSerial = nextStateSerial;\n    state = nextState;\n  }\n\n  // If it is expected to reach a specific state (`toState`) and that state\n  // isn't reached, there are no paths\n  if (resolvedOptions.toState && !resolvedOptions.toState(state)) {\n    return [];\n  }\n\n  return [\n    alterPath({\n      state,\n      steps,\n      weight: steps.length\n    })\n  ];\n}\n","import { AnyActorLogic, EventFromLogic, InputFrom } from '../index.ts';\nimport { getAdjacencyMap } from './adjacency.ts';\nimport { alterPath } from './alterPath.ts';\nimport { resolveTraversalOptions } from './graph.ts';\nimport {\n  SerializedEvent,\n  SerializedSnapshot,\n  StatePath,\n  StatePlanMap,\n  TraversalOptions\n} from './types.ts';\nimport { createMockActorScope } from './actorScope.ts';\n\nexport function getShortestPaths<TLogic extends AnyActorLogic>(\n  logic: TLogic,\n  options?: TraversalOptions<\n    ReturnType<TLogic['transition']>,\n    EventFromLogic<TLogic>,\n    InputFrom<TLogic>\n  >\n): Array<StatePath<ReturnType<TLogic['transition']>, EventFromLogic<TLogic>>> {\n  type TInternalState = ReturnType<TLogic['transition']>;\n  type TEvent = EventFromLogic<TLogic>;\n\n  const resolvedOptions = resolveTraversalOptions(logic, options);\n  const serializeState = resolvedOptions.serializeState as (\n    ...args: Parameters<typeof resolvedOptions.serializeState>\n  ) => SerializedSnapshot;\n  const fromState =\n    resolvedOptions.fromState ??\n    logic.getInitialSnapshot(createMockActorScope(), options?.input);\n  const adjacency = getAdjacencyMap(logic, resolvedOptions);\n\n  // weight, state, event\n  const weightMap = new Map<\n    SerializedSnapshot,\n    {\n      weight: number;\n      state: SerializedSnapshot | undefined;\n      event: TEvent | undefined;\n    }\n  >();\n  const stateMap = new Map<SerializedSnapshot, TInternalState>();\n  const serializedFromState = serializeState(fromState, undefined, undefined);\n  stateMap.set(serializedFromState, fromState);\n\n  weightMap.set(serializedFromState, {\n    weight: 0,\n    state: undefined,\n    event: undefined\n  });\n  const unvisited = new Set<SerializedSnapshot>();\n  const visited = new Set<SerializedSnapshot>();\n\n  unvisited.add(serializedFromState);\n  for (const serializedState of unvisited) {\n    const prevState = stateMap.get(serializedState);\n    const { weight } = weightMap.get(serializedState)!;\n    for (const event of Object.keys(\n      adjacency[serializedState].transitions\n    ) as SerializedEvent[]) {\n      const { state: nextState, event: eventObject } =\n        adjacency[serializedState].transitions[event];\n      const nextSerializedState = serializeState(\n        nextState,\n        eventObject,\n        prevState\n      );\n      stateMap.set(nextSerializedState, nextState);\n      if (!weightMap.has(nextSerializedState)) {\n        weightMap.set(nextSerializedState, {\n          weight: weight + 1,\n          state: serializedState,\n          event: eventObject\n        });\n      } else {\n        const { weight: nextWeight } = weightMap.get(nextSerializedState)!;\n        if (nextWeight > weight + 1) {\n          weightMap.set(nextSerializedState, {\n            weight: weight + 1,\n            state: serializedState,\n            event: eventObject\n          });\n        }\n      }\n      if (!visited.has(nextSerializedState)) {\n        unvisited.add(nextSerializedState);\n      }\n    }\n    visited.add(serializedState);\n    unvisited.delete(serializedState);\n  }\n\n  const statePlanMap: StatePlanMap<TInternalState, TEvent> = {};\n  const paths: Array<StatePath<TInternalState, TEvent>> = [];\n\n  weightMap.forEach(\n    ({ weight, state: fromState, event: fromEvent }, stateSerial) => {\n      const state = stateMap.get(stateSerial)!;\n      const steps = !fromState\n        ? []\n        : statePlanMap[fromState].paths[0].steps.concat({\n            state: stateMap.get(fromState)!,\n            event: fromEvent!\n          });\n\n      paths.push({\n        state,\n        steps,\n        weight\n      });\n      statePlanMap[stateSerial] = {\n        state,\n        paths: [\n          {\n            state,\n            steps,\n            weight\n          }\n        ]\n      };\n    }\n  );\n\n  if (resolvedOptions.toState) {\n    return paths\n      .filter((path) => resolvedOptions.toState!(path.state))\n      .map(alterPath);\n  }\n\n  return paths.map(alterPath);\n}\n","import { AnyActorLogic, EventFromLogic, InputFrom } from '../index.ts';\nimport {\n  SerializedEvent,\n  SerializedSnapshot,\n  StatePath,\n  Steps,\n  TraversalOptions,\n  VisitedContext\n} from './types.ts';\nimport { resolveTraversalOptions } from './graph.ts';\nimport { getAdjacencyMap } from './adjacency.ts';\nimport { alterPath } from './alterPath.ts';\nimport { createMockActorScope } from './actorScope.ts';\n\nexport function getSimplePaths<TLogic extends AnyActorLogic>(\n  logic: TLogic,\n  options?: TraversalOptions<\n    ReturnType<TLogic['transition']>,\n    EventFromLogic<TLogic>,\n    InputFrom<TLogic>\n  >\n): Array<StatePath<ReturnType<TLogic['transition']>, EventFromLogic<TLogic>>> {\n  type TState = ReturnType<TLogic['transition']>;\n  type TEvent = EventFromLogic<TLogic>;\n\n  const resolvedOptions = resolveTraversalOptions(logic, options);\n  const actorScope = createMockActorScope();\n  const fromState =\n    resolvedOptions.fromState ??\n    logic.getInitialSnapshot(actorScope, options?.input);\n  const serializeState = resolvedOptions.serializeState as (\n    ...args: Parameters<typeof resolvedOptions.serializeState>\n  ) => SerializedSnapshot;\n  const adjacency = getAdjacencyMap(logic, resolvedOptions);\n  const stateMap = new Map<SerializedSnapshot, TState>();\n  const visitCtx: VisitedContext<TState, TEvent> = {\n    vertices: new Set(),\n    edges: new Set()\n  };\n  const steps: Steps<TState, TEvent> = [];\n  const pathMap: Record<\n    SerializedSnapshot,\n    { state: TState; paths: Array<StatePath<TState, TEvent>> }\n  > = {};\n\n  function util(\n    fromStateSerial: SerializedSnapshot,\n    toStateSerial: SerializedSnapshot\n  ) {\n    const fromState = stateMap.get(fromStateSerial)!;\n    visitCtx.vertices.add(fromStateSerial);\n\n    if (fromStateSerial === toStateSerial) {\n      if (!pathMap[toStateSerial]) {\n        pathMap[toStateSerial] = {\n          state: stateMap.get(toStateSerial)!,\n          paths: []\n        };\n      }\n\n      const toStatePlan = pathMap[toStateSerial];\n\n      const path2: StatePath<TState, TEvent> = {\n        state: fromState,\n        weight: steps.length,\n        steps: [...steps]\n      };\n\n      toStatePlan.paths.push(path2);\n    } else {\n      for (const serializedEvent of Object.keys(\n        adjacency[fromStateSerial].transitions\n      ) as SerializedEvent[]) {\n        const { state: nextState, event: subEvent } =\n          adjacency[fromStateSerial].transitions[serializedEvent];\n\n        if (!(serializedEvent in adjacency[fromStateSerial].transitions)) {\n          continue;\n        }\n        const prevState = stateMap.get(fromStateSerial);\n\n        const nextStateSerial = serializeState(nextState, subEvent, prevState);\n        stateMap.set(nextStateSerial, nextState);\n\n        if (!visitCtx.vertices.has(nextStateSerial)) {\n          visitCtx.edges.add(serializedEvent);\n          steps.push({\n            state: stateMap.get(fromStateSerial)!,\n            event: subEvent\n          });\n          util(nextStateSerial, toStateSerial);\n        }\n      }\n    }\n\n    steps.pop();\n    visitCtx.vertices.delete(fromStateSerial);\n  }\n\n  const fromStateSerial = serializeState(fromState, undefined);\n  stateMap.set(fromStateSerial, fromState);\n\n  for (const nextStateSerial of Object.keys(\n    adjacency\n  ) as SerializedSnapshot[]) {\n    util(fromStateSerial, nextStateSerial);\n  }\n\n  const simplePaths = Object.values(pathMap).flatMap((p) => p.paths);\n\n  if (resolvedOptions.toState) {\n    return simplePaths\n      .filter((path) => resolvedOptions.toState!(path.state))\n      .map(alterPath);\n  }\n\n  return simplePaths.map(alterPath);\n}\n"],"names":["Mailbox","constructor","_process","this","_active","_current","_last","start","flush","clear","next","enqueue","event","enqueued","value","consumed","XSTATE_INIT","XSTATE_STOP","getDevTools","w","globalThis","self","window","__xstate__","devToolsAdapter","service","devTools","register","createDoneStateEvent","id","output","type","createInitEvent","input","reportUnhandledError","err","setTimeout","symbolObservable","Symbol","observable","matchesState","parentStateId","childStateId","parentStateValue","toStateValue","childStateValue","Object","keys","every","key","toStatePath","stateId","isArray","result","segment","i","length","charCodeAt","push","stateValue","isMachineSnapshot","statePath","marker","previous","pathToStateValue","mapValues","collection","iteratee","collectionKeys","toArrayStrict","toArray","undefined","resolveOutput","mapper","context","Array","toTransitionConfigArray","configLike","map","transitionLike","target","normalizeTarget","toObserver","nextHandler","errorHandler","completionHandler","isObserver","bind","error","complete","createInvokeId","stateNodeId","index","resolveReferencedActor","machine","src","match","implementations","actors","indexStr","nodeId","invokeConfig","getStateNodeById","config","invoke","getAllOwnEventDescriptors","snapshot","Set","_nodes","flatMap","sn","ownEvents","createScheduledEventId","actorRef","sessionId","idCounter","executingCustomAction","ProcessingStatus","defaultOptions","clock","fn","ms","clearTimeout","logger","console","log","Actor","logic","options","_snapshot","mailbox","observers","eventListeners","Map","_processingStatus","NotStarted","_parent","_syncSnapshot","ref","_actorScope","systemId","system","_doneEvent","_deferred","resolvedOptions","parent","syncSnapshot","inspect","rootActor","children","keyedActors","reverseKeyedActors","WeakMap","inspectionObservers","timerMap","scheduler","schedule","source","delay","Math","random","toString","slice","scheduledEvent","startedAt","Date","now","scheduledEventId","_scheduledEvents","timeout","_relay","cancel","cancelAll","_bookId","_register","set","_unregister","delete","get","getAll","fromEntries","entries","_set","existing","Error","observerOrFn","observer","add","unsubscribe","_sendInspectionEvent","size","resolvedInspectionEvent","rootId","forEach","sourceRef","_send","getSnapshot","scheduledEvents","scheduledId","_clock","_logger","createSystem","defer","stopChild","child","_stop","emit","emittedEvent","listeners","wildcardListener","allListeners","values","handler","actionExecutor","action","exec","params","saveExecutingCustomAction","info","Running","send","_initState","state","status","persistedState","restoreSnapshot","getInitialSnapshot","update","deferredFn","shift","_stopProcedure","_complete","invokeId","actorId","_error","subscribe","nextListenerOrObserver","errorListener","completeListener","Stopped","on","wrappedHandler","initEvent","attachDevTools","nextState","caughtError","transition","stop","_reportError","reportError","err2","toJSON","xstate$$type","getPersistedSnapshot","createActor","resolveCancel","_","actionArgs","actionParams","sendId","executeCancel","actorScope","resolveSpawn","_actionParams","resolvedId","resolvedInput","cloneMachineSnapshot","executeSpawn","spawnChild","_args","_params","resolve","execute","resolveStop","args","actorRefOrString","resolvedActorRef","unregisterRecursively","executeStop","evaluateGuard","guard","isInline","resolved","guards","guardArgs","guardParams","check","isAtomicStateNode","stateNode","getChildren","states","filter","getProperAncestors","toStateNode","ancestors","m","getAllStateNodes","stateNodes","nodeSet","adjList","getAdjList","s","has","initialStates","getInitialStateNodesWithTheirAncestors","initialStateNode","getValueFromAdj","baseNode","childStateNodes","childStateNode","getStateValue","rootNode","isInFinalState","stateNodeSet","some","isStateId","str","getDelayedTransitions","afterConfig","after","mutateEntryExit","afterEvent","delayRef","eventType","entry","eventOrExpr","raise","resolveRaise","executeRaise","exit","configTransition","resolvedTransition","resolvedDelay","Number","isNaN","delayedTransition","formatTransition","descriptor","transitionConfig","normalizedTarget","reenter","targets","isInternalTarget","getStateNodeByPath","resolvedTarget","message","resolveTarget","actions","t","resolveHistoryDefaultTransition","initial","isHistoryNode","getInitialStateNodes","initialState","ancestor","iter","descStateNode","getStateNode","stateKey","arrayStatePath","currentStateNode","getStateNodes","childStateKeys","subStateKey","Boolean","root","concat","reduce","allSubStateNodes","subStateNode","subStateNodes","transitionNode","transitionAtomicNode","subStateKeys","transitionCompoundNode","allInnerTransitions","subStateValue","innerTransitions","transitionParallelNode","getHistoryNodes","isDescendant","parentStateNode","hasIntersection","s1","s2","set1","set2","item","removeConflictingTransitions","enabledTransitions","historyValue","filteredTransitions","t1","t1Preempted","transitionsToRemove","t2","computeExitSet","t3","from","getEffectiveTargetStates","targetNode","node","getTransitionDomain","targetStates","lca","head","tail","findLeastCommonAncestor","transitions","statesToExit","domain","microstep","currentSnapshot","isInitial","internalQueue","originalExecutor","mutStateNodeSet","nextSnapshot","changedHistory","sort","a","b","order","exitStateNode","historyNode","predicate","history","resolveActionsAndContext","def","exitStates","statesToEnter","statesForDefaultEntry","addDescendantStatesToEnter","addAncestorStatesToEnter","computeEntrySet","completedNodes","stateNodeToEnter","invokeDef","onSnapshot","initialActions","ancestorMarker","rootCompletionNode","getMachineOutput","enterStates","nextStateNodes","prevStateNodes","nextStateNodeSet","areStateNodeCollectionsEqual","e","doneStateEvent","historyStateNodes","addProperAncestorStatesToEnter","historyDefaultTransition","reentrancyDomain","anc","getAction","actionType","resolveAndExecuteActionsWithContext","extra","retries","intermediateSnapshot","resolvedAction","name","builtinAction","deferredActorIds","retryResolve","macrostep","microsteps","addMicrostep","step","_transitions","stopChildren","nextEvent","currentEvent","isErr","startsWith","isErrorActorEvent","selectTransitions","shouldSelectEventlessTransitions","selectEventlessTransitions","previousState","getTransitionData","enabledTransitionSet","atomicStates","loop","always","machineSnapshotMatches","testValue","machineSnapshotHasTag","tag","tags","machineSnapshotCan","transitionData","machineSnapshotToJSON","nodes","getMeta","can","hasTag","matches","jsonValues","machineSnapshotGetMeta","acc","meta","createMachineSnapshot","serializeHistoryValue","persistContext","contextPart","copy","createSpawner","spawnedChildren","spawn","resolveAssign","assignment","assignArgs","partialUpdate","propAssignment","assign","delaysMap","delays","resolvedEvent","configDelay","emptyLogic","initialContext","cache","memo","object","memoizedData","EMPTY_OBJECT","toSerializableAction","StateNode","path","description","_key","_machine","join","idMap","stateConfig","_initialize","transitionsConfig","onDone","onError","formatTransitions","definition","version","flat","sourceName","invokeDefValues","_target","formatInitialTransition","selectedTransition","candidates","getCandidates","receivedEventType","eventDescriptor","endsWith","partialEventTokens","split","eventTokens","tokenIndex","partialEventToken","eventToken","matchesEventDescriptor","candidate","resolvedContext","guardPassed","guardType","events","StateMachine","schemas","__xstatenode","rootStateNode","routeTransitions","collectRoutes","route","routeId","userGuard","routeGuard","to","formatRouteTransitions","provide","resolveState","resolvedStateValue","_getPreInitialState","preInitial","preInitialState","initialMicrostep","macroState","fullPath","relativePath","resolvedStateId","STATE_IDENTIFIER","childrenJson","snapshotChildren","resolveHistoryReferencedState","referenced","actorData","childState","revivedHistoryValue","revived","arr","reviveHistoryValue","restoredSnapshot","seen","reviveContext","simpleStringify","JSON","stringify","getDescription","contextString","stateStrings","trim","createShortestPathsGen","getShortestPaths","createSimplePathsGen","getSimplePaths","validateState","TestModel","getDefaultOptions","serializeState","serializeEvent","serializeTransition","stateMatcher","testLogic","defaultTraversalOptions","_toTestPath","eventsString","steps","other","formatEvent","test","testPath","getPaths","pathGenerator","allowDuplicatePaths","paths","_resolveOptions","deduplicatePaths","allPathsWithEventSequence","eventSequence","z","superpathsWithEventSequence","pathLoop","pathWithEventSequence","superpathLoop","superpathWithEventSequence","getShortestPathsFrom","resultPaths","shortestPaths","fromState","shortestPath","joinPaths","getSimplePathsFrom","getPathsFromEvents","getAdjacencyMap","testPathResult","testStepResult","testTransition","testState","formatColor","_color","string","targetStateString","errMessage","hasFailed","stateString","eventString","formatPathTestResult","stateTestKeys","_getStateTestKeys","stateTestKey","_getEventExec","eventExec","stateValuesEqual","aKeys","bKeys","serializeMachineTransition","previousSnapshot","prevStateString","createMockActorScope","emptyActor","serializeSnapshot","createDefaultMachineOptions","getEvents","otherOptions","__unsafe_getAllOwnEventDescriptors","matchingEvents","ev","createDefaultLogicOptions","resolveTraversalOptions","traversalOptions","resolvedDefaultOptions","isMachineLogic","limit","Infinity","toState","stopWhen","headPath","tailPath","weight","customFromState","adj","iterations","queue","prevState","stateMap","serializedState","alterPath","adjacency","serializedFromState","stateSerial","eventSerial","_nextEvent","nextStateSerial","weightMap","unvisited","visited","eventObject","nextSerializedState","nextWeight","statePlanMap","fromEvent","visitCtx","vertices","edges","pathMap","util","fromStateSerial","toStateSerial","toStatePlan","path2","serializedEvent","subEvent","pop","simplePaths","p","adjMap","adjValue","validateMachine","includes","accNodes","toDirectedGraph","stateMachine","transitionIndex","targetIndex","edge","label","text","graph","graphEdges"],"mappings":"kPAKO,MAAMA,EAKXC,WAAAA,CAAoBC,GAA2BC,KAA3BD,SAAAA,EAAyBC,KAJrCC,SAAmB,EAAKD,KACxBE,SAAkC,KAAIF,KACtCG,MAA+B,IAES,CAEzCC,KAAAA,GACLJ,KAAKC,SAAU,EACfD,KAAKK,OACP,CAEOC,KAAAA,GAGDN,KAAKE,WACPF,KAAKE,SAASK,KAAO,KACrBP,KAAKG,MAAQH,KAAKE,SAEtB,CAEOM,OAAAA,CAAQC,GACb,MAAMC,EAAW,CACfC,MAAOF,EACPF,KAAM,MAGR,GAAIP,KAAKE,SAGP,OAFAF,KAAKG,MAAOI,KAAOG,OACnBV,KAAKG,MAAQO,GAIfV,KAAKE,SAAWQ,EAChBV,KAAKG,MAAQO,EAETV,KAAKC,SACPD,KAAKK,OAET,CAEQA,KAAAA,GACN,KAAOL,KAAKE,UAAU,CAGpB,MAAMU,EAAWZ,KAAKE,SACtBF,KAAKD,SAASa,EAASD,OACvBX,KAAKE,SAAWU,EAASL,IAC3B,CACAP,KAAKG,MAAQ,IACf,ECvDK,MAKMU,EAAc,cAEdC,EAAc,cCiC3B,SAASC,IACP,MAAMC,EApBoB,oBAAfC,WACFA,WAEW,oBAATC,KACFA,KAGAC,OAcT,GAAKH,EAAUI,WACb,OAAQJ,EAAUI,UAItB,CAcO,MAAMC,EAAoCC,IAK/C,MAAMC,EAAWR,IAEbQ,GACFA,EAASC,SAASF,IChDf,SAASG,EACdC,EACAC,GAEA,MAAO,CACLC,KAAM,qBAAqBF,IAC3BC,SAEJ,CA6BO,SAASE,EAAgBC,GAC9B,MAAO,CAAEF,KAAMf,EAAaiB,QAC9B,CCpDO,SAASC,EAAqBC,GACnCC,WAAW,KACT,MAAMD,GAEV,CCZO,MAAME,EACQ,mBAAXC,QAAyBA,OAAOC,YACxC,eCqBK,SAASC,EACdC,EACAC,GAEA,MAAMC,EAAmBC,EAAaH,GAChCI,EAAkBD,EAAaF,GAErC,MAA+B,iBAApBG,EACuB,iBAArBF,GACFE,IAAoBF,EAOC,iBAArBA,EACFA,KAAoBE,EAGtBC,OAAOC,KAAKJ,GAAkBK,MAAOC,GACpCA,KAAOJ,GAINL,EAAaG,EAAiBM,GAAOJ,EAAgBI,IAEhE,CAEO,SAASC,EAAYC,GAC1B,GAAIC,EAAQD,GACV,OAAOA,EAGT,MAAME,EAAmB,GACzB,IAAIC,EAAU,GAEd,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAQK,OAAQD,IAAK,CAEvC,OADaJ,EAAQM,WAAWF,IAG9B,KAAK,GAEHD,GAAWH,EAAQI,EAAI,GAEvBA,IACA,SAEF,KAAK,GACHF,EAAOK,KAAKJ,GACZA,EAAU,GACV,SAEJA,GAAWH,EAAQI,EACrB,CAIA,OAFAF,EAAOK,KAAKJ,GAELD,CACT,CAEA,SAAST,EAAae,GACpB,GAAIC,GAAkBD,GACpB,OAAOA,EAAW7C,MAGpB,GAA0B,iBAAf6C,EACT,OAAOA,EAKT,OAGK,SAA0BE,GAC/B,GAAyB,IAArBA,EAAUL,OACZ,OAAOK,EAAU,GAGnB,MAAM/C,EAAoB,CAAA,EAC1B,IAAIgD,EAAShD,EAEb,IAAK,IAAIyC,EAAI,EAAGA,EAAIM,EAAUL,OAAS,EAAGD,IACxC,GAAIA,IAAMM,EAAUL,OAAS,EAC3BM,EAAOD,EAAUN,IAAMM,EAAUN,EAAI,OAChC,CACL,MAAMQ,EAAWD,EACjBA,EAAS,CAAA,EACTC,EAASF,EAAUN,IAAMO,CAC3B,CAGF,OAAOhD,CACT,CAtBSkD,CAFWd,EAAYS,GAGhC,CA2BO,SAASM,EACdC,EACAC,GAOA,MAAMd,EAAkC,CAAA,EAElCe,EAAiBtB,OAAOC,KAAKmB,GACnC,IAAK,IAAIX,EAAI,EAAGA,EAAIa,EAAeZ,OAAQD,IAAK,CAC9C,MAAMN,EAAMmB,EAAeb,GAC3BF,EAAOJ,GAAOkB,EAASD,EAAWjB,GAAMA,EAAKiB,EAAYX,EAC3D,CAEA,OAAOF,CACT,CAEA,SAASgB,EAAiBvD,GACxB,OAAIsC,EAAQtC,GACHA,EAEF,CAACA,EACV,CAEO,SAASwD,EAAWxD,GACzB,YAAcyD,IAAVzD,EACK,GAEFuD,EAAcvD,EACvB,CAEO,SAAS0D,EAIdC,EAGAC,EACA9D,EACAS,GAEA,MAAsB,mBAAXoD,EACFA,EAAO,CAAEC,UAAS9D,QAAOS,SAwB3BoD,CACT,CAEA,SAASrB,EAAQtC,GACf,OAAO6D,MAAMvB,QAAQtC,EACvB,CAQO,SAAS8D,EACdC,GAEA,OAAOR,EAAcQ,GAAYC,IAAKC,QAER,IAAnBA,GACmB,iBAAnBA,EAEA,CAAEC,OAAQD,GAGZA,EAEX,CAEO,SAASE,EAIdD,GAEA,QAAeT,IAAXS,GLlOwB,KKkOAA,EAG5B,OAAOV,EAAQU,EACjB,CAEO,SAASE,EACdC,EACAC,EACAC,GAEA,MAAMC,EAAoC,iBAAhBH,EACpB9D,EAAOiE,EAAaH,OAAcZ,EAExC,MAAO,CACL7D,MAAO4E,EAAaH,EAAYzE,KAAOyE,IAAcI,KAAKlE,GAC1DmE,OAAQF,EAAaH,EAAYK,MAAQJ,IAAeG,KAAKlE,GAC7DoE,UAAWH,EAAaH,EAAYM,SAAWJ,IAAoBE,KACjElE,GAGN,CAEO,SAASqE,EAAeC,EAAqBC,GAClD,MAAO,GAAGA,KAASD,GACrB,CAEO,SAASE,EAAuBC,EAA0BC,GAC/D,MAAMC,EAAQD,EAAIC,MAAM,gCACxB,IAAKA,EACH,OAAOF,EAAQG,gBAAgBC,OAAOH,GAExC,OAASI,EAAUC,GAAUJ,EAEvBK,EADOP,EAAQQ,iBAAiBF,GACZG,OAAOC,OACjC,OACE7B,MAAMvB,QAAQiD,GACVA,EAAaF,GACZE,GAULN,GACJ,CAEO,SAASU,EAA0BC,GACxC,MAAO,IAAI,IAAIC,IAAI,IAAID,EAASE,OAAOC,QAASC,GAAOA,EAAGC,aAC5D,CChPA,SAASC,EACPC,EACApF,GAEA,MAAO,GAAGoF,EAASC,aAAarF,GAClC,CA4CA,IAAIsF,EAAY,EClET,IAAIC,GAAiC,EA4BhCC,IAAAA,WAAAA,GAAgB,OAAhBA,EAAAA,EAAgB,WAAA,GAAA,aAAhBA,EAAAA,EAAgB,QAAA,GAAA,UAAhBA,EAAAA,EAAgB,QAAA,GAAA,UAAhBA,CAAgB,EAAA,CAAA,GAM5B,MAAMC,EAAiB,CACrBC,MAAO,CACLnF,WAAYA,CAACoF,EAAIC,IACRrF,WAAWoF,EAAIC,GAExBC,aAAe7F,GACN6F,aAAa7F,IAGxB8F,OAAQC,QAAQC,IAAItC,KAAKqC,SACzBlG,UAAU,GAQL,MAAMoG,EAiEX7H,WAAAA,CACS8H,EACPC,GACA7H,KAFO4H,MAAAA,EA9DT5H,KACQ8H,eAAS,EACjB9H,KAIOoH,WAAK,EAAApH,KACL6H,aAAO,EAEd7H,KACO0B,QAAE,EAAA1B,KAED+H,QAA2C,IAAIlI,EACrDG,KAAKD,SAASqF,KAAKpF,OACpBA,KAEOgI,UAAiD,IAAIxB,IAAKxG,KAC1DiI,eAGJ,IAAIC,IAAKlI,KACLwH,YAAM,EAEdxH,KACOmI,kBAAsCjB,EAAiBkB,WAE9DpI,KACOqI,aAAO,EACdrI,KACOsI,mBAAa,EAAAtI,KACbuI,SAAG,EAKVvI,KACQwI,iBAAW,EAAAxI,KAOZyI,cAAQ,EAEfzI,KACO+G,eAAS,EAEhB/G,KACO0I,YAAM,EAAA1I,KACL2I,gBAAU,EAAA3I,KAEX4F,SAAG,EAmJV5F,KACQ4I,UAA+B,GAvIrC,MAAMC,EAAkB,IACnB1B,KACAU,IAGCT,MAAEA,EAAKI,OAAEA,EAAMsB,OAAEA,EAAMC,aAAEA,EAAYrH,GAAEA,EAAE+G,SAAEA,EAAQO,QAAEA,GACzDH,EAEF7I,KAAK0I,OAASI,EACVA,EAAOJ,OD/DR,SACLO,EACApB,GAMA,MAAMqB,EAAW,IAAIhB,IACfiB,EAAc,IAAIjB,IAClBkB,EAAqB,IAAIC,QACzBC,EAAsB,IAAI9C,IAC1B+C,EAA+C,CAAA,GAC/CnC,MAAEA,EAAKI,OAAEA,GAAWK,EAEpB2B,EAAuB,CAC3BC,SAAUA,CACRC,EACA7E,EACApE,EACAkJ,EACAjI,EAAKkI,KAAKC,SAASC,SAAS,IAAIC,MAAM,MAEtC,MAAMC,EAAiC,CACrCN,SACA7E,SACApE,QACAkJ,QACAjI,KACAuI,UAAWC,KAAKC,OAEZC,EAAmBvD,EAAuB6C,EAAQhI,GACxDgH,EAAOZ,UAAUuC,iBAAiBD,GAAoBJ,EAEtD,MAAMM,EAAUlD,EAAMnF,WAAW,YACxBsH,EAASa,UACT1B,EAAOZ,UAAUuC,iBAAiBD,GAEzC1B,EAAO6B,OAAOb,EAAQ7E,EAAQpE,IAC7BkJ,GAEHJ,EAASa,GAAoBE,GAE/BE,OAAQA,CAACd,EAAQhI,KACf,MAAM0I,EAAmBvD,EAAuB6C,EAAQhI,GAClD4I,EAAUf,EAASa,UAElBb,EAASa,UACT1B,EAAOZ,UAAUuC,iBAAiBD,QAEzBhG,IAAZkG,GACFlD,EAAMG,aAAa+C,IAGvBG,UAAY3D,IACV,IAAK,MAAMsD,KAAoB1B,EAAOZ,UAAUuC,iBAAkB,CAChE,MAAML,EACJtB,EAAOZ,UAAUuC,iBACfD,GAEAJ,EAAeN,SAAW5C,GAC5B0C,EAAUgB,OAAO1D,EAAUkD,EAAetI,GAE9C,IAgBEgH,EAAyB,CAC7BZ,UAAW,CACTuC,kBACGxC,GAAStB,UAAasB,EAAQtB,SAAiBiD,YAAc,CAAC,GAEnEkB,QAASA,IAAM,KAAK1D,IACpB2D,UAAWA,CAAC5D,EAAWD,KACrBoC,EAAS0B,IAAI7D,EAAWD,GACjBC,GAET8D,YAAc/D,IACZoC,EAAS4B,OAAOhE,EAASC,WACzB,MAAM0B,EAAWW,EAAmB2B,IAAIjE,QAEvB1C,IAAbqE,IACFU,EAAY2B,OAAOrC,GACnBW,EAAmB0B,OAAOhE,KAG9BiE,IAAMtC,GACGU,EAAY4B,IAAItC,GAEzBuC,OAAQA,IACCrI,OAAOsI,YAAY9B,EAAY+B,WAExCC,KAAMA,CAAC1C,EAAU3B,KACf,MAAMsE,EAAWjC,EAAY4B,IAAItC,GACjC,GAAI2C,GAAYA,IAAatE,EAC3B,MAAM,IAAIuE,MACR,yBAAyB5C,sBAI7BU,EAAYyB,IAAInC,EAAU3B,GAC1BsC,EAAmBwB,IAAI9D,EAAU2B,IAEnCO,QAAUsC,IACR,MAAMC,EAAWxG,EAAWuG,GAG5B,OAFAhC,EAAoBkC,IAAID,GAEjB,CACLE,WAAAA,GACEnC,EAAoBwB,OAAOS,EAC7B,IAGJG,qBA3D2BjL,IAC3B,IAAK6I,EAAoBqC,KACvB,OAEF,MAAMC,EAA2C,IAC5CnL,EACHoL,OAAQ5C,EAAUlC,WAEpBuC,EAAoBwC,QAASP,GAC3BA,EAAShL,OAAOqL,KAmDlBrB,OAAQA,CAACb,EAAQ7E,EAAQpE,KACvBiI,EAAOgD,qBAAqB,CAC1B9J,KAAM,gBACNmK,UAAWrC,EACX5C,SAAUjC,EACVpE,UAGFoE,EAAOmH,MAAMvL,IAEf+I,YACAyC,YAAaA,KACJ,CACL5B,iBAAkB,IAAK3B,EAAOZ,UAAUuC,oBAG5CjK,MAAOA,KACL,MAAM8L,EAAkBxD,EAAOZ,UAAUuC,iBACzC3B,EAAOZ,UAAUuC,iBAAmB,GACpC,IAAK,MAAM8B,KAAeD,EAAiB,CACzC,MAAMxC,OAAEA,EAAM7E,OAAEA,EAAMpE,MAAEA,EAAKkJ,MAAEA,EAAKjI,GAAEA,GACpCwK,EAAgBC,GAClB3C,EAAUC,SAASC,EAAQ7E,EAAQpE,EAAOkJ,EAAOjI,EACnD,GAEF0K,OAAQhF,EACRiF,QAAS7E,GAGX,OAAOkB,CACT,CC5FQ4D,CAAatM,KAAM,CACjBoH,QACAI,WAGFwB,IAAYF,GAEd9I,KAAK0I,OAAOM,QAAQjE,EAAWiE,IAGjChJ,KAAK+G,UAAY/G,KAAK0I,OAAOgC,UAC7B1K,KAAK0B,GAAKA,GAAM1B,KAAK+G,UACrB/G,KAAKwH,OAASK,GAASL,QAAUxH,KAAK0I,OAAO2D,QAC7CrM,KAAKoH,MAAQS,GAAST,OAASpH,KAAK0I,OAAO0D,OAC3CpM,KAAKqI,QAAUS,EACf9I,KAAKsI,cAAgBS,EACrB/I,KAAK6H,QAAUgB,EAEf7I,KAAK4F,IAAMiD,EAAgBjD,KAAOgC,EAClC5H,KAAKuI,IAAMvI,KACXA,KAAKwI,YAAc,CACjBtH,KAAMlB,KACN0B,GAAI1B,KAAK0B,GACTqF,UAAW/G,KAAK+G,UAChBS,OAAQxH,KAAKwH,OACb+E,MAAQlF,IACNrH,KAAK4I,UAAUrF,KAAK8D,IAEtBqB,OAAQ1I,KAAK0I,OACb8D,UAAYC,IACV,GAAIA,EAAMpE,UAAYrI,KACpB,MAAM,IAAIqL,MACR,2BAA2BoB,EAAM/K,SAAS1B,KAAK0B,gCAGlD+K,EAAcC,SAEjBC,KAAOC,IACL,MAAMC,EAAY7M,KAAKiI,eAAe8C,IAAI6B,EAAahL,MACjDkL,EAAmB9M,KAAKiI,eAAe8C,IAAI,KACjD,IAAK8B,IAAcC,EACjB,OAEF,MAAMC,EAAe,IACfF,EAAYA,EAAUG,SAAW,MACjCF,EAAmBA,EAAiBE,SAAW,IAErD,IAAK,MAAMC,KAAWF,EACpB,IACEE,EAAQL,EACT,CAAC,MAAO5K,GACPD,EAAqBC,EACvB,GAGJkL,eAAiBC,IACf,MAAMC,EAAOA,KASX,GARApN,KAAKwI,YAAYE,OAAOgD,qBAAqB,CAC3C9J,KAAM,iBACNkF,SAAU9G,KACVmN,OAAQ,CACNvL,KAAMuL,EAAOvL,KACbyL,OAAQF,EAAOE,WAGdF,EAAOC,KACV,OAEF,MAAME,EAA4BrG,EAClC,IACEA,GAAwB,EACxBkG,EAAOC,KAAKD,EAAOI,KAAMJ,EAAOE,OAClC,CAAU,QACRpG,EAAwBqG,CAC1B,GAEEtN,KAAKmI,oBAAsBjB,EAAiBsG,QAC9CJ,IAEApN,KAAK4I,UAAUrF,KAAK6J,KAO1BpN,KAAKyN,KAAOzN,KAAKyN,KAAKrI,KAAKpF,MAE3BA,KAAK0I,OAAOgD,qBAAqB,CAC/B9J,KAAM,gBACNkF,SAAU9G,OAGRyI,IACFzI,KAAKyI,SAAWA,EAChBzI,KAAK0I,OAAOyC,KAAK1C,EAAUzI,OAG7BA,KAAK0N,WAAW7F,GAAStB,UAAYsB,GAAS8F,OAE1ClF,GAA+C,WAAlCzI,KAAK8H,UAAkB8F,QACtC5N,KAAK0I,OAAOmC,YAAY7K,KAE5B,CAEQ0N,UAAAA,CAAWG,GACjB,IACE7N,KAAK8H,UAAY+F,EACb7N,KAAK4H,MAAMkG,gBACT9N,KAAK4H,MAAMkG,gBAAgBD,EAAgB7N,KAAKwI,aAChDqF,EACF7N,KAAK4H,MAAMmG,mBAAmB/N,KAAKwI,YAAaxI,KAAK6H,SAAS/F,MACnE,CAAC,MAAOE,GAIPhC,KAAK8H,UAAY,CACf8F,OAAQ,QACRjM,YAAQyC,EACRiB,MAAOrD,EAEX,CACF,CAKQgM,MAAAA,CAAOzH,EAAgC9F,GAK7C,IAAIwN,EAEJ,IALAjO,KAAK8H,UAAYvB,EAKT0H,EAAajO,KAAK4I,UAAUsF,SAClC,IACED,GACD,CAAC,MAAOjM,GAMPhC,KAAK4I,UAAUvF,OAAS,EACxBrD,KAAK8H,UAAY,IACXvB,EACJqH,OAAQ,QACRvI,MAAOrD,EAEX,CAGF,OAAShC,KAAK8H,UAAkB8F,QAC9B,IAAK,SACH,IAAK,MAAMrC,KAAYvL,KAAKgI,UAC1B,IACEuD,EAAShL,OAAOgG,EACjB,CAAC,MAAOvE,GACPD,EAAqBC,EACvB,CAEF,MACF,IAAK,OAOH,IAAK,MAAMuJ,KAAYvL,KAAKgI,UAC1B,IACEuD,EAAShL,OAAOgG,EACjB,CAAC,MAAOvE,GACPD,EAAqBC,EACvB,CAGFhC,KAAKmO,iBACLnO,KAAKoO,YACLpO,KAAK2I,YLpSX0F,EKqSQrO,KAAK0B,GLpSbC,EKqSS3B,KAAK8H,UAAkBnG,OLnSzB,CACLC,KAAM,qBAAqByM,IAC3B1M,SACA2M,QAASD,IKkSDrO,KAAKqI,SACPrI,KAAK0I,OAAO6B,OAAOvK,KAAMA,KAAKqI,QAASrI,KAAK2I,YAG9C,MACF,IAAK,QACH3I,KAAKuO,OAAQvO,KAAK8H,UAAkBzC,OL/SrC,IACLgJ,EACA1M,EKgTE3B,KAAK0I,OAAOgD,qBAAqB,CAC/B9J,KAAM,mBACNkF,SAAU9G,KACVS,QACA8F,YAEJ,CAmEOiI,SAAAA,CACLC,EAGAC,EACAC,GAEA,MAAMpD,EAAWxG,EACf0J,EACAC,EACAC,GAGF,GAAI3O,KAAKmI,oBAAsBjB,EAAiB0H,QAC9C5O,KAAKgI,UAAUwD,IAAID,QAEnB,OAASvL,KAAK8H,UAAkB8F,QAC9B,IAAK,OACH,IACErC,EAASjG,YACV,CAAC,MAAOtD,GACPD,EAAqBC,EACvB,CACA,MACF,IAAK,QAAS,CACZ,MAAMA,EAAOhC,KAAK8H,UAAkBzC,MACpC,GAAKkG,EAASlG,MAGZ,IACEkG,EAASlG,MAAMrD,EAChB,CAAC,MAAOA,GACPD,EAAqBC,EACvB,MANAD,EAAqBC,GAQvB,KACF,EAIJ,MAAO,CACLyJ,YAAaA,KACXzL,KAAKgI,UAAU8C,OAAOS,IAG5B,CAEOsD,EAAAA,CACLjN,EACAqL,GAKA,IAAIJ,EAAY7M,KAAKiI,eAAe8C,IAAInJ,GACnCiL,IACHA,EAAY,IAAIrG,IAChBxG,KAAKiI,eAAe2C,IAAIhJ,EAAMiL,IAEhC,MAAMiC,EAAiB7B,EAAQ7H,UAAKhB,GAGpC,OAFAyI,EAAUrB,IAAIsD,GAEP,CACLrD,YAAaA,KACXoB,EAAU/B,OAAOgE,IAGvB,CAGO1O,KAAAA,GACL,GAAIJ,KAAKmI,oBAAsBjB,EAAiBsG,QAE9C,OAAOxN,KAGLA,KAAKsI,eACPtI,KAAKwO,UAAU,CACbjO,KAAOgG,IACmB,WAApBA,EAASqH,QACX5N,KAAK0I,OAAO6B,OAAOvK,KAAMA,KAAKqI,QAAU,CACtCzG,KAAM,mBAAmB5B,KAAK0B,KAC9B6E,cAINlB,MAAOA,SAIXrF,KAAK0I,OAAOiC,UAAU3K,KAAK+G,UAAW/G,MAClCA,KAAKyI,UACPzI,KAAK0I,OAAOyC,KAAKnL,KAAKyI,SAAUzI,MAElCA,KAAKmI,kBAAoBjB,EAAiBsG,QAG1C,MAAMuB,EAAYlN,EAAgB7B,KAAK6H,QAAQ/F,OAE/C9B,KAAK0I,OAAOgD,qBAAqB,CAC/B9J,KAAM,gBACNmK,UAAW/L,KAAKqI,QAChBvB,SAAU9G,KACVS,MAAOsO,IAKT,OAFgB/O,KAAK8H,UAAkB8F,QAGrC,IAAK,OAQH,OALA5N,KAAKgO,OACHhO,KAAK8H,UACLiH,GAGK/O,KACT,IAAK,QAEH,OADAA,KAAKuO,OAAQvO,KAAK8H,UAAkBzC,OAC7BrF,KAOX,GAJKA,KAAKqI,SACRrI,KAAK0I,OAAOtI,QAGVJ,KAAK4H,MAAMxH,MACb,IACEJ,KAAK4H,MAAMxH,MAAMJ,KAAK8H,UAAW9H,KAAKwI,YACvC,CAAC,MAAOxG,GAOP,OANAhC,KAAK8H,UAAY,IACX9H,KAAK8H,UACT8F,OAAQ,QACRvI,MAAOrD,GAEThC,KAAKuO,OAAOvM,GACLhC,IACT,CAcF,OARAA,KAAKgO,OAAOhO,KAAK8H,UAAWiH,GAExB/O,KAAK6H,QAAQtG,UACfvB,KAAKgP,iBAGPhP,KAAK+H,QAAQ3H,QAENJ,IACT,CAEQD,QAAAA,CAASU,GACf,IAAIwO,EACAC,EACJ,IACED,EAAYjP,KAAK4H,MAAMuH,WACrBnP,KAAK8H,UACLrH,EACAT,KAAKwI,YAER,CAAC,MAAOxG,GAEPkN,EAAc,CAAElN,MAClB,CAEA,GAAIkN,EAAa,CACf,MAAMlN,IAAEA,GAAQkN,EAQhB,OANAlP,KAAK8H,UAAY,IACX9H,KAAK8H,UACT8F,OAAQ,QACRvI,MAAOrD,QAEThC,KAAKuO,OAAOvM,EAEd,CAEAhC,KAAKgO,OAAOiB,EAAWxO,GACnBA,EAAMmB,OAASd,IACjBd,KAAKmO,iBACLnO,KAAKoO,YAET,CAEQ1B,KAAAA,GACN,OAAI1M,KAAKmI,oBAAsBjB,EAAiB0H,QACvC5O,MAETA,KAAK+H,QAAQzH,QACTN,KAAKmI,oBAAsBjB,EAAiBkB,YAC9CpI,KAAKmI,kBAAoBjB,EAAiB0H,QACnC5O,OAETA,KAAK+H,QAAQvH,QAAQ,CAAEoB,KAAMd,IAEtBd,MACT,CAGOoP,IAAAA,GACL,GAAIpP,KAAKqI,QACP,MAAM,IAAIgD,MAAM,gDAElB,OAAOrL,KAAK0M,OACd,CACQ0B,SAAAA,GACN,IAAK,MAAM7C,KAAYvL,KAAKgI,UAC1B,IACEuD,EAASjG,YACV,CAAC,MAAOtD,GACPD,EAAqBC,EACvB,CAEFhC,KAAKgI,UAAU1H,QACfN,KAAKiI,eAAe3H,OACtB,CACQ+O,YAAAA,CAAarN,GACnB,IAAKhC,KAAKgI,UAAU2D,KAKlB,OAJK3L,KAAKqI,SACRtG,EAAqBC,QAEvBhC,KAAKiI,eAAe3H,QAGtB,IAAIgP,GAAc,EAElB,IAAK,MAAM/D,KAAYvL,KAAKgI,UAAW,CACrC,MAAM0G,EAAgBnD,EAASlG,MAC/BiK,KAAiBZ,EACjB,IACEA,IAAgB1M,EACjB,CAAC,MAAOuN,GACPxN,EAAqBwN,EACvB,CACF,CACAvP,KAAKgI,UAAU1H,QACfN,KAAKiI,eAAe3H,QAChBgP,GACFvN,EAAqBC,EAEzB,CACQuM,MAAAA,CAAOvM,GLrmBV,IACLN,EKqmBE1B,KAAKmO,iBACLnO,KAAKqP,aAAarN,GACdhC,KAAKqI,SACPrI,KAAK0I,OAAO6B,OACVvK,KACAA,KAAKqI,QLvmBJ,CAAEzG,KAAM,sBAHfF,EK2mB4B1B,KAAK0B,KLxmBU2D,MKwmBNrD,ELxmBasM,QAAS5M,GK2mB3D,CAMQyM,cAAAA,GACN,OAAInO,KAAKmI,oBAAsBjB,EAAiBsG,UAMhDxN,KAAK0I,OAAOc,UAAUiB,UAAUzK,MAGhCA,KAAK+H,QAAQzH,QAKbN,KAAK+H,QAAU,IAAIlI,EAAQG,KAAKD,SAASqF,KAAKpF,OAE9CA,KAAKmI,kBAAoBjB,EAAiB0H,QAC1C5O,KAAK0I,OAAOmC,YAAY7K,OAffA,IAkBX,CAGOgM,KAAAA,CAAMvL,GACPT,KAAKmI,oBAAsBjB,EAAiB0H,SAYhD5O,KAAK+H,QAAQvH,QAAQC,EACvB,CAOOgN,IAAAA,CAAKhN,GAMVT,KAAK0I,OAAO6B,YAAOnG,EAAWpE,KAAMS,EACtC,CAEQuO,cAAAA,GACN,MAAMzN,SAAEA,GAAavB,KAAK6H,QAC1B,GAAItG,EAAU,EAEU,mBAAbA,EAA0BA,EAAWF,GAEtBrB,KAC1B,CACF,CACOwP,MAAAA,GACL,MAAO,CACLC,aAzrBsB,EA0rBtB/N,GAAI1B,KAAK0B,GAEb,CAgBOgO,oBAAAA,CAAqB7H,GAC1B,OAAO7H,KAAK4H,MAAM8H,qBAAqB1P,KAAK8H,UAAWD,EACzD,CAEA,CAAQ3F,KACN,OAAOlC,IACT,CAgBOiM,WAAAA,GAML,OAAOjM,KAAK8H,SACd,EA4CK,SAAS6H,EACd/H,MACIC,IASJ,OAAO,IAAIF,EAAMC,EAAOC,EAC1B,CC1zBA,SAAS+H,EACPC,EACAtJ,EACAuJ,EACAC,GACAC,OAAEA,IAIF,MAAO,CAACzJ,EAAU,CAAEyJ,OADA,mBAAXA,EAAwBA,EAAOF,EAAYC,GAAgBC,QACtB5L,EAChD,CAEA,SAAS6L,EAAcC,EAA2B7C,GAChD6C,EAAW3D,MAAM,KACf2D,EAAWxH,OAAOc,UAAUgB,OAAO0F,EAAWhP,KAAMmM,EAAO2C,SAE/D,CCPA,SAASG,EACPD,EACA3J,EACAuJ,EACAM,GACA1O,GACEA,EAAE+G,SACFA,EAAQ7C,IACRA,EAAG9D,MACHA,EAAKiH,aACLA,IASF,MAAMnB,EACW,iBAARhC,EACHF,EAAuBa,EAASZ,QAASC,GACzCA,EACAyK,EAA2B,mBAAP3O,EAAoBA,EAAGoO,GAAcpO,EAC/D,IAAIoF,EACAwJ,EA2BJ,OAzBI1I,IACF0I,EACmB,mBAAVxO,EACHA,EAAM,CACJyC,QAASgC,EAAShC,QAClB9D,MAAOqP,EAAWrP,MAClBS,KAAMgP,EAAWhP,OAEnBY,EACNgF,EAAW6I,EAAY/H,EAAO,CAC5BlG,GAAI2O,EACJzK,MACAkD,OAAQoH,EAAWhP,KACnB6H,eACAN,WACA3G,MAAOwO,KAUJ,CACLC,GAAqBhK,EAAU,CAC7B2C,SAAU,IACL3C,EAAS2C,SACZmH,CAACA,GAAavJ,KAGlB,CACEpF,KACA+G,WACA3B,WACAlB,MACA9D,MAAOwO,QAETlM,EAEJ,CAEA,SAASoM,EACPN,GACApJ,SAAEA,IAEGA,GAILoJ,EAAW3D,MAAM,KACXzF,EAASqB,oBAAsBjB,EAAiB0H,SAGpD9H,EAAS1G,SAEb,CA6EO,SAASqQ,MAQZ7K,GACAlE,GAAEA,EAAE+G,SAAEA,EAAQ3G,MAAEA,EAAKiH,aAAEA,GAAe,GAAU,CAAS,IAa3D,SAAS0H,EACPC,EACAC,GAKF,CAYA,OAVAF,EAAW7O,KAAO,oBAClB6O,EAAW/O,GAAKA,EAChB+O,EAAWhI,SAAWA,EACtBgI,EAAW7K,IAAMA,EACjB6K,EAAW3O,MAAQA,EACnB2O,EAAW1H,aAAeA,EAE1B0H,EAAWG,QAAUT,EACrBM,EAAWI,QAAUL,EAEdC,CACT,CChNA,SAASK,EACPjB,EACAtJ,EACAwK,EACAhB,GACAjJ,SAAEA,IAEF,MAAMkK,EACgB,mBAAblK,EAA0BA,EAASiK,EAAMhB,GAAgBjJ,EAC5DmK,EACwB,iBAArBD,EACHzK,EAAS2C,SAAS8H,GAClBA,EAEN,IAAI9H,EAAW3C,EAAS2C,SAKxB,OAJI+H,IACF/H,EAAW,IAAKA,UACTA,EAAS+H,EAAiBvP,KAE5B,CACL6O,GAAqBhK,EAAU,CAC7B2C,aAEF+H,OACA7M,EAEJ,CACA,SAAS8M,EACPhB,EACApJ,GAGA,MAAMP,EAAWO,EAASmF,cAC1B,GAAI1F,GAAY,aAAcA,EAC5B,IAAK,MAAMkG,KAAS9J,OAAOqK,OACzBzG,EAAS2C,UAETgI,EAAsBhB,EAAYzD,GAGtCyD,EAAWxH,OAAOmC,YAAY/D,EAChC,CAEA,SAASqK,EACPjB,EACApJ,GAEKA,IAQLoK,EAAsBhB,EAAYpJ,GAI9BA,EAASqB,oBAAsBjB,EAAiBsG,QAQpD0C,EAAW3D,MAAM,KACf2D,EAAW1D,UAAU1F,KARrBoJ,EAAW1D,UAAU1F,GAUzB,CAgBO,SAAS0F,EAMd1F,GAEA,SAASsI,EACPsB,EACAC,GAKF,CAQA,OANAvB,EAAKxN,KAAO,mBACZwN,EAAKtI,SAAWA,EAEhBsI,EAAKwB,QAAUE,EACf1B,EAAKyB,QAAUM,EAER/B,CACT,CCuMO,SAASgC,EAIdC,EACA9M,EACA9D,EACA8F,GAEA,MAAMZ,QAAEA,GAAYY,EACd+K,EAA4B,mBAAVD,EAElBE,EAAWD,EACbD,EACA1L,EAAQG,gBAAgB0L,OACL,iBAAVH,EAAqBA,EAAQA,EAAMzP,MAGhD,IAAK0P,IAAaC,EAChB,MAAM,IAAIlG,MACR,UACmB,iBAAVgG,EAAqBA,EAAQA,EAAMzP,+BAKhD,GAAwB,mBAAb2P,EACT,OAAOH,EAAcG,EAAWhN,EAAS9D,EAAO8F,GAGlD,MAAMkL,EAAY,CAChBlN,UACA9D,SAGIiR,EACJJ,GAA6B,iBAAVD,OACfjN,EACA,WAAYiN,EACc,mBAAjBA,EAAMhE,OACXgE,EAAMhE,OAAO,CAAE9I,UAAS9D,UACxB4Q,EAAMhE,YACRjJ,EAER,KAAM,UAAWmN,GAIf,OAAOA,EAASE,EAAWC,GAK7B,OAFqBH,EAEDI,MAClBpL,EACAkL,EACAF,EAEJ,CC9UO,SAASK,EAAkBC,GAChC,MAA0B,WAAnBA,EAAUjQ,MAAwC,UAAnBiQ,EAAUjQ,IAClD,CAEA,SAASkQ,EACPD,GAEA,OAAOlP,OAAOqK,OAAO6E,EAAUE,QAAQC,OAAQrL,GAAmB,YAAZA,EAAG/E,KAC3D,CAEO,SAASqQ,EACdJ,EACAK,GAEA,MAAMC,EAAqC,GAE3C,GAAID,IAAgBL,EAClB,OAAOM,EAIT,IAAIC,EAAIP,EAAU/I,OAClB,KAAOsJ,GAAKA,IAAMF,GAChBC,EAAU5O,KAAK6O,GACfA,EAAIA,EAAEtJ,OAGR,OAAOqJ,CACT,CAEO,SAASE,EACdC,GAEA,MAAMC,EAAU,IAAI/L,IAAI8L,GAElBE,EAAUC,EAAWF,GAG3B,IAAK,MAAMG,KAAKH,EAEd,GAAe,aAAXG,EAAE9Q,MAAyB4Q,EAAQzH,IAAI2H,IAAOF,EAAQzH,IAAI2H,GAAIrP,QAKhE,GAAe,aAAXqP,EAAE9Q,KACJ,IAAK,MAAM6K,KAASqF,EAAYY,GAC9B,GAAmB,YAAfjG,EAAM7K,OAIL2Q,EAAQI,IAAIlG,GAAQ,CACvB,MAAMmG,EAAgBC,GAAuCpG,GAC7D,IAAK,MAAMqG,KAAoBF,EAC7BL,EAAQ/G,IAAIsH,EAEhB,OAfJD,GAAuCH,GAAG5G,QAASnF,GACjD4L,EAAQ/G,IAAI7E,IAqBlB,IAAK,MAAM+L,KAAKH,EAAS,CACvB,IAAIH,EAAIM,EAAE5J,OAEV,KAAOsJ,GACLG,EAAQ/G,IAAI4G,GACZA,EAAIA,EAAEtJ,MAEV,CAEA,OAAOyJ,CACT,CAEA,SAASQ,EAAgBC,EAAwBR,GAC/C,MAAMS,EAAkBT,EAAQzH,IAAIiI,GAEpC,IAAKC,EACH,MAAO,GAGT,GAAsB,aAAlBD,EAASpR,KAAqB,CAChC,MAAMsR,EAAiBD,EAAgB,GACvC,IAAIC,EAKF,MAAO,GAJP,GAAItB,EAAkBsB,GACpB,OAAOA,EAAepQ,GAK5B,CAEA,MAAMU,EAAyB,CAAA,EAC/B,IAAK,MAAM0P,KAAkBD,EAC3BzP,EAAW0P,EAAepQ,KAAOiQ,EAAgBG,EAAgBV,GAGnE,OAAOhP,CACT,CAEA,SAASiP,EACPH,GAEA,MAAME,EAAmB,IAAItK,IAE7B,IAAK,MAAMwK,KAAKJ,EACTE,EAAQG,IAAID,IACfF,EAAQ5H,IAAI8H,EAAG,IAGbA,EAAE5J,SACC0J,EAAQG,IAAID,EAAE5J,SACjB0J,EAAQ5H,IAAI8H,EAAE5J,OAAQ,IAGxB0J,EAAQzH,IAAI2H,EAAE5J,QAASvF,KAAKmP,IAIhC,OAAOF,CACT,CAEO,SAASW,EACdC,EACAd,GAGA,OAAOS,EAAgBK,EAAUX,EADlBJ,EAAiBC,IAElC,CAEO,SAASe,EACdC,EACAzB,GAEA,MAAuB,aAAnBA,EAAUjQ,KACLkQ,EAAYD,GAAW0B,KAC3Bb,GAAiB,UAAXA,EAAE9Q,MAAoB0R,EAAaX,IAAID,IAG3B,aAAnBb,EAAUjQ,KACLkQ,EAAYD,GAAWhP,MAAO8D,GACnC0M,EAAeC,EAAc3M,IAIP,UAAnBkL,EAAUjQ,IACnB,CAEO,MAAM4R,EAAaC,GZ9MM,MY8MUA,EAAI,GAmBvC,SAASC,EACd7B,GAEA,MAAM8B,EAAc9B,EAAUzL,OAAOwN,MACrC,IAAKD,EACH,MAAO,GAGT,MAAME,EAAmBlK,IACvB,MAAMmK,GVnOuBC,EUmOOpK,EVnOoBjI,EUmObmQ,EAAUnQ,GVlOhD,CAAEE,KAAM,gBAAgBmS,KAAYrS,MADtC,IAA0BqS,EAA2BrS,EUoOxD,MAAMsS,EAAYF,EAAWlS,KAS7B,OAPAiQ,EAAUoC,MAAM1Q,KClHb,SAQL2Q,EAGArM,GAwBA,SAASsM,EACPzD,EACAC,GAKF,CAUA,OARAwD,EAAMvS,KAAO,eACbuS,EAAM1T,MAAQyT,EACdC,EAAMzS,GAAKmG,GAASnG,GACpByS,EAAMxK,MAAQ9B,GAAS8B,MAEvBwK,EAAMvD,QAAUwD,GAChBD,EAAMtD,QAAUwD,GAETF,CACT,CD8DMA,CAAML,EAAY,CAChBpS,GAAIsS,EACJrK,WAGJkI,EAAUyC,KAAK/Q,KJpKZ,SAMLyM,GAEA,SAASxF,EACPkG,EACAC,GAKF,CAQA,OANAnG,EAAO5I,KAAO,gBACd4I,EAAOwF,OAASA,EAEhBxF,EAAOoG,QAAUhB,EACjBpF,EAAOqG,QAAUZ,EAEVzF,CACT,CI4IwBA,CAAOwJ,IACpBA,GAiBT,OAd2BrR,OAAOC,KAAK+Q,GAAajN,QAASiD,IAC3D,MAAM4K,EAAmBZ,EAAYhK,GAC/B6K,EACwB,iBAArBD,EACH,CAAE1P,OAAQ0P,GACVA,EACAE,EAAgBC,OAAOC,OAAOhL,GAASA,GAASA,EAChDqK,EAAYH,EAAgBY,GAClC,OAAOtQ,EAAQqQ,GAAoB7P,IAAKwK,IAAgB,IACnDA,EACH1O,MAAOuT,EACPrK,MAAO8K,OAGe9P,IAAKiQ,IAC7B,MAAMjL,MAAEA,GAAUiL,EAClB,MAAO,IACFC,EACDhD,EACA+C,EAAkBnU,MAClBmU,GAEFjL,UAGN,CAEO,SAASkL,EACdhD,EACAiD,EACAC,GAEA,MAAMC,EAAmBlQ,EAAgBiQ,EAAiBlQ,QACpDoQ,EAAUF,EAAiBE,UAAW,EACtCpQ,EA4LR,SACEgN,EACAqD,GAEA,QAAgB9Q,IAAZ8Q,EAEF,OAEF,OAAOA,EAAQvQ,IAAKE,IAClB,GAAsB,iBAAXA,EACT,OAAOA,EAET,GAAI2O,EAAU3O,GACZ,OAAOgN,EAAUlM,QAAQQ,iBAAiBtB,GAG5C,MAAMsQ,EZxeqB,MYweFtQ,EAAO,GAGhC,GAAIsQ,IAAqBtD,EAAU/I,OACjC,OAAOsM,GAAmBvD,EAAWhN,EAAOkF,MAAM,IAEpD,MAAMsL,EAAiBF,EAAmBtD,EAAU/O,IAAM+B,EAASA,EACnE,IAAIgN,EAAU/I,OAaZ,MAAM,IAAIuC,MACR,oBAAoBxG,+DAAoEA,OAb1F,IAKE,OAJwBuQ,GACtBvD,EAAU/I,OACVuM,EAGH,CAAC,MAAOrT,GACP,MAAM,IAAIqJ,MACR,iDAAiDwG,EAAUnQ,SAASM,EAAIsT,UAE5E,GAON,CArOiBC,CAAc1D,EAAWmD,GASlC7F,EAAa,IACd4F,EACHS,QAASrR,EAAQ4Q,EAAiBS,SAClCnE,MAAO0D,EAAiB1D,MACxBxM,SACA6E,OAAQmI,EACRoD,UACAjB,UAAWc,EACXtF,OAAQA,KAAO,IACVL,EACHzF,OAAQ,IAAImI,EAAUnQ,KACtBmD,OAAQA,EAASA,EAAOF,IAAK8Q,GAAM,IAAIA,EAAE/T,WAAQ0C,KAIrD,OAAO+K,CACT,CA8MA,SAASuG,EAGP7D,GACA,MAAMmD,EAAmBlQ,EACvB+M,EAAUzL,OAAOvB,QAEnB,OAAKmQ,EAGE,CACLnQ,OAAQmQ,EAAiBrQ,IAAK8Q,GACf,iBAANA,EAAiBL,GAAmBvD,EAAU/I,OAAS2M,GAAKA,IAJ9D5D,EAAU/I,OAAQ6M,OAO7B,CAEA,SAASC,EACP/D,GAEA,MAA0B,YAAnBA,EAAUjQ,IACnB,CAEA,SAASiR,GAAuChB,GAC9C,MAAME,EAAS8D,GAAqBhE,GACpC,IAAK,MAAMiE,KAAgB/D,EACzB,IAAK,MAAMgE,KAAY9D,EAAmB6D,EAAcjE,GACtDE,EAAOvG,IAAIuK,GAGf,OAAOhE,CACT,CAEA,SAAS8D,GAAqBhE,GAC5B,MAAMjH,EAAM,IAAIpE,IAkBhB,OAhBA,SAASwP,EAAKC,GACZ,IAAIrL,EAAI+H,IAAIsD,GAIZ,GADArL,EAAIY,IAAIyK,GACmB,aAAvBA,EAAcrU,KAChBoU,EAAKC,EAAcN,QAAQ9Q,OAAO,SAC7B,GAA2B,aAAvBoR,EAAcrU,KACvB,IAAK,MAAM6K,KAASqF,EAAYmE,GAC9BD,EAAKvJ,EAGX,CAEAuJ,CAAKnE,GAEEjH,CACT,CAEA,SAASsL,GAAarE,EAAyBsE,GAC7C,GAAI3C,EAAU2C,GACZ,OAAOtE,EAAUlM,QAAQQ,iBAAiBgQ,GAE5C,IAAKtE,EAAUE,OACb,MAAM,IAAI1G,MACR,mCAAmC8K,YAAmBtE,EAAUnQ,+BAGpE,MAAMwB,EAAS2O,EAAUE,OAAOoE,GAChC,IAAKjT,EACH,MAAM,IAAImI,MACR,gBAAgB8K,yBAAgCtE,EAAUnQ,OAG9D,OAAOwB,CACT,CAOO,SAASkS,GACdvD,EACAnO,GAEA,GAAyB,iBAAdA,GAA0B8P,EAAU9P,GAC7C,IACE,OAAOmO,EAAUlM,QAAQQ,iBAAiBzC,EAC5C,CAAE,MAEA,CAGJ,MAAM0S,EAAiBrT,EAAYW,GAAWqG,QAC9C,IAAIsM,EAAiCxE,EACrC,KAAOuE,EAAe/S,QAAQ,CAC5B,MAAMP,EAAMsT,EAAelI,QAC3B,IAAKpL,EAAIO,OACP,MAEFgT,EAAmBH,GAAaG,EAAkBvT,EACpD,CACA,OAAOuT,CACT,CAOO,SAASC,GACdzE,EACArO,GAEA,GAA0B,iBAAfA,EAAyB,CAClC,MAAM0P,EAAiBrB,EAAUE,OAAOvO,GACxC,IAAK0P,EACH,MAAM,IAAI7H,MACR,UAAU7H,yBAAkCqO,EAAUnQ,OAG1D,MAAO,CAACmQ,EAAWqB,EACrB,CAEA,MAAMqD,EAAiB5T,OAAOC,KAAKY,GAC7ByP,EAAuCsD,EAC1C5R,IAAK6R,GAAgBN,GAAarE,EAAW2E,IAC7CxE,OAAOyE,SAEV,MAAO,CAAC5E,EAAUlM,QAAQ+Q,KAAM7E,GAAW8E,OACzC1D,EACAsD,EAAeK,OAAO,CAACC,EAAkBL,KACvC,MAAMM,EAAeZ,GAAarE,EAAW2E,GAC7C,IAAKM,EACH,OAAOD,EAET,MAAME,EAAgBT,GACpBQ,EACAtT,EAAWgT,IAGb,OAAOK,EAAiBF,OAAOI,IAC9B,IAEP,CA8GO,SAASC,GAIdnF,EACArO,EACA+C,EAUA9F,GAGA,MAA0B,iBAAf+C,EA/Hb,SAIEqO,EACArO,EACA+C,EAUA9F,GAEA,MACMF,EADiB2V,GAAarE,EAAWrO,GACnBjD,KAAKgG,EAAU9F,GAE3C,OAAKF,GAASA,EAAK8C,OAIZ9C,EAHEsR,EAAUtR,KAAKgG,EAAU9F,EAIpC,CAsGWwW,CAAqBpF,EAAWrO,EAAY+C,EAAU9F,GAIxB,IAAnCkC,OAAOC,KAAKY,GAAYH,OAxG9B,SAIEwO,EACArO,EACA+C,EAUA9F,GAEA,MAAMyW,EAAevU,OAAOC,KAAKY,GAG3BjD,EAAOyW,GADUd,GAAarE,EAAWqF,EAAa,IAG1D1T,EAAW0T,EAAa,IACxB3Q,EACA9F,GAGF,OAAKF,GAASA,EAAK8C,OAIZ9C,EAHEsR,EAAUtR,KAAKgG,EAAU9F,EAIpC,CAwEW0W,CAAuBtF,EAAWrO,EAAY+C,EAAU9F,GAtEnE,SAIEoR,EACArO,EACA+C,EAUA9F,GAEA,MAAM2W,EAAqE,GAE3E,IAAK,MAAMZ,KAAe7T,OAAOC,KAAKY,GAAa,CACjD,MAAM6T,EAAgB7T,EAAWgT,GAEjC,IAAKa,EACH,SAGF,MACMC,EAAmBN,GADJd,GAAarE,EAAW2E,GAG3Ca,EACA9Q,EACA9F,GAEE6W,GACFF,EAAoB7T,QAAQ+T,EAEhC,CACA,OAAKF,EAAoB/T,OAIlB+T,EAHEvF,EAAUtR,KAAKgG,EAAU9F,EAIpC,CA+BS8W,CAAuB1F,EAAWrO,EAAY+C,EAAU9F,EACjE,CAEA,SAAS+W,GAAgB3F,GACvB,OAAOlP,OAAOC,KAAKiP,EAAUE,QAC1BpN,IAAK7B,GAAQ+O,EAAUE,OAAOjP,IAC9BkP,OAAQrL,GAAmB,YAAZA,EAAG/E,KACvB,CAEA,SAAS6V,GACPvE,EACAwE,GAEA,IAAI/T,EAASuP,EACb,KAAOvP,EAAOmF,QAAUnF,EAAOmF,SAAW4O,GACxC/T,EAASA,EAAOmF,OAGlB,OAAOnF,EAAOmF,SAAW4O,CAC3B,CAEA,SAASC,GAAmBC,EAAiBC,GAC3C,MAAMC,EAAO,IAAItR,IAAIoR,GACfG,EAAO,IAAIvR,IAAIqR,GAErB,IAAK,MAAMG,KAAQF,EACjB,GAAIC,EAAKpF,IAAIqF,GACX,OAAO,EAGX,IAAK,MAAMA,KAAQD,EACjB,GAAID,EAAKnF,IAAIqF,GACX,OAAO,EAGX,OAAO,CACT,CAEA,SAASC,GACPC,EACA5E,EACA6E,GAEA,MAAMC,EAAsB,IAAI5R,IAEhC,IAAK,MAAM6R,KAAMH,EAAoB,CACnC,IAAII,GAAc,EAClB,MAAMC,EAAsB,IAAI/R,IAChC,IAAK,MAAMgS,KAAMJ,EACf,GACET,GACEc,GAAe,CAACJ,GAAK/E,EAAc6E,GACnCM,GAAe,CAACD,GAAKlF,EAAc6E,IAErC,CACA,IAAIV,GAAaY,EAAG3O,OAAQ8O,EAAG9O,QAExB,CACL4O,GAAc,EACd,KACF,CAJEC,EAAoB/M,IAAIgN,EAK5B,CAEF,IAAKF,EAAa,CAChB,IAAK,MAAMI,KAAMH,EACfH,EAAoBtN,OAAO4N,GAE7BN,EAAoB5M,IAAI6M,EAC1B,CACF,CAEA,OAAO7T,MAAMmU,KAAKP,EACpB,CAaA,SAASQ,GACPzJ,EACAgJ,GAEA,IAAKhJ,EAAWtK,OACd,MAAO,GAGT,MAAMqQ,EAAU,IAAI1O,IAEpB,IAAK,MAAMqS,KAAc1J,EAAWtK,OAClC,GAAI+Q,EAAciD,GAChB,GAAIV,EAAaU,EAAWnX,IAC1B,IAAK,MAAMoX,KAAQX,EAAaU,EAAWnX,IACzCwT,EAAQ1J,IAAIsN,QAGd,IAAK,MAAMA,KAAQF,GACjBlD,EAAgCmD,GAChCV,GAEAjD,EAAQ1J,IAAIsN,QAIhB5D,EAAQ1J,IAAIqN,GAIhB,MAAO,IAAI3D,EACb,CAEA,SAAS6D,GACP5J,EACAgJ,GAEA,MAAMa,EAAeJ,GAAyBzJ,EAAYgJ,GAE1D,IAAKa,EACH,OAGF,IACG7J,EAAW8F,SACZ+D,EAAanW,MACVgC,GACCA,IAAWsK,EAAWzF,QAAU+N,GAAa5S,EAAQsK,EAAWzF,SAGpE,OAAOyF,EAAWzF,OAGpB,MAAMuP,EA/DR,SACE3G,GAEA,MAAO4G,KAASC,GAAQ7G,EACxB,IAAK,MAAMyD,KAAY9D,EAAmBiH,OAAM9U,GAC9C,GAAI+U,EAAKtW,MAAO8D,GAAO8Q,GAAa9Q,EAAIoP,IACtC,OAAOA,CAGb,CAsDcqD,CAAwBJ,EAAarC,OAAOxH,EAAWzF,SAEnE,OAAIuP,IAKA9J,EAAW8F,aAAf,EAIO9F,EAAWzF,OAAO/D,QAAQ+Q,KACnC,CAEA,SAAS+B,GACPY,EACA/F,EACA6E,GAEA,MAAMmB,EAAe,IAAI9S,IAEzB,IAAK,MAAMiP,KAAK4D,EACd,GAAI5D,EAAE5Q,QAAQxB,OAAQ,CACpB,MAAMkW,EAASR,GAAoBtD,EAAG0C,GAElC1C,EAAER,SAAWQ,EAAE/L,SAAW6P,GAC5BD,EAAa9N,IAAI+N,GAGnB,IAAK,MAAM1H,KAAayB,EAClBmE,GAAa5F,EAAW0H,IAC1BD,EAAa9N,IAAIqG,EAGvB,CAGF,MAAO,IAAIyH,EACb,CA8CA,SAASE,GACPH,EACAI,EACAvJ,EACAzP,EACAiZ,EACAC,GAEA,MAAMnE,EAAoC,GAE1C,IAAK6D,EAAYhW,OACf,MAAO,CAACoW,EAAiBjE,GAG3B,MAAMoE,EAAmB1J,EAAWhD,eACpCgD,EAAWhD,eAAkBC,IAC3BqI,EAAQjS,KAAK4J,GACbyM,EAAiBzM,IAGnB,IACE,MAAM0M,EAAkB,IAAIrT,IAAIiT,EAAgBhT,QAChD,IAAI0R,EAAesB,EAAgBtB,aAEnC,MAAMC,EAAsBH,GAC1BoB,EACAQ,EACA1B,GAGF,IAAIlJ,EAAYwK,EAGXC,KACFzK,EAAWkJ,GA4ZlB,SACEsB,EACAhZ,EACAyP,EACAmJ,EACAQ,EACA1B,EACAwB,GAGA,IAAIG,EAAeL,EACnB,MAAMH,EAAeb,GACnBY,EACAQ,EACA1B,GAKF,IAAI4B,EAFJT,EAAaU,KAAK,CAACC,EAAGC,IAAMA,EAAEC,MAAQF,EAAEE,OAKxC,IAAK,MAAMC,KAAiBd,EAC1B,IAAK,MAAMe,KAAe7C,GAAgB4C,GAAgB,CACxD,IAAIE,EAEFA,EAD0B,SAAxBD,EAAYE,QACD5T,GACXiL,EAAkBjL,IAAO8Q,GAAa9Q,EAAIyT,GAE/BzT,GACJA,EAAGmC,SAAWsR,EAGzBL,IAAmB,IAAK5B,GACxB4B,EAAeM,EAAY3Y,IACzB8C,MAAMmU,KAAKkB,GAAiB7H,OAAOsI,EACvC,CAGF,IAAK,MAAM5H,KAAK4G,EACdQ,EAAeU,GACbV,EACArZ,EACAyP,EACA,IAAIwC,EAAE4B,QAAS5B,EAAErM,OAAO1B,IAAK8V,GAAQjO,EAAUiO,EAAI/Y,MACnDiY,OACAvV,GAEFyV,EAAgB/O,OAAO4H,GAEzB,MAAO,CAACoH,EAAcC,GAAkB5B,EAC1C,CA/ckCuC,CAC1BzL,EACAxO,EACAyP,EACAkI,EACAyB,EACA1B,EACAwB,EACAzJ,EAAWhD,iBAKf+B,EAAYuL,GACVvL,EACAxO,EACAyP,EACAkI,EAAoB1R,QAAS+O,GAAMA,EAAED,SACrCmE,OACAvV,GAIF6K,EAgFJ,SACEwK,EACAhZ,EACAyP,EACAkI,EACAyB,EACAF,EACAxB,EACAuB,GAEA,IAAII,EAAeL,EACnB,MAAMkB,EAAgB,IAAInU,IAIpBoU,EAAwB,IAAIpU,KAmGpC,SACE6S,EACAlB,EACAyC,EACAD,GAEA,IAAK,MAAMlF,KAAK4D,EAAa,CAC3B,MAAME,EAASR,GAAoBtD,EAAG0C,GAEtC,IAAK,MAAMzF,KAAK+C,EAAE5Q,QAAU,GAEvB+Q,EAAclD,IAEd+C,EAAE/L,SAAWgJ,GAGZ+C,EAAE/L,SAAW6P,IAEb9D,EAAER,UAEJ0F,EAAcnP,IAAIkH,GAClBkI,EAAsBpP,IAAIkH,IAE5BmI,GACEnI,EACAyF,EACAyC,EACAD,GAGJ,MAAM3B,EAAeJ,GAAyBnD,EAAG0C,GACjD,IAAK,MAAMzF,KAAKsG,EAAc,CAC5B,MAAM7G,EAAYF,EAAmBS,EAAG6G,GACnB,aAAjBA,GAAQ3X,MACVuQ,EAAU5O,KAAKgW,GAEjBuB,GACEH,EACAxC,EACAyC,EACAzI,GACCsD,EAAE/L,OAAOZ,QAAU2M,EAAER,aAAU7Q,EAAYmV,EAEhD,CACF,CACF,EA/IEwB,CACE3C,EACAD,EACAyC,EACAD,GAIEjB,GACFkB,EAAsBpP,IAAIiO,EAAgB9T,QAAQ+Q,MAGpD,MAAMsE,EAAiB,IAAIxU,IAE3B,IAAK,MAAMyU,IAAoB,IAAIN,GAAeX,KAChD,CAACC,EAAGC,IAAMD,EAAEE,MAAQD,EAAEC,OACrB,CACDN,EAAgBrO,IAAIyP,GACpB,MAAMzF,EAA2B,GAGjCA,EAAQjS,QAAQ0X,EAAiBhH,OAEjC,IAAK,MAAMiH,KAAaD,EAAiB5U,OACvCmP,EAAQjS,KACNkN,EAAWyK,EAAUtV,IAAK,IACrBsV,EACHnS,eAAgBmS,EAAUC,cAKhC,GAAIP,EAAsBjI,IAAIsI,GAAmB,CAC/C,MAAMG,EAAiBH,EAAiBtF,QAAQH,QAChDA,EAAQjS,QAAQ6X,EAClB,CAWA,GATAtB,EAAeU,GACbV,EACArZ,EACAyP,EACAsF,EACAmE,EACAsB,EAAiB5U,OAAO1B,IAAKuW,GAAcA,EAAUxZ,KAGzB,UAA1BuZ,EAAiBrZ,KAAkB,CACrC,MAAMkH,EAASmS,EAAiBnS,OAEhC,IAAIuS,EACe,aAAjBvS,GAAQlH,KAAsBkH,EAASA,GAAQA,OAC7CwS,EAAqBD,GAAkBJ,EAiB3C,IAfqB,aAAjBnS,GAAQlH,MACV+X,EAAcpW,KACZ9B,EACEqH,EAAOpH,QACqB0C,IAA5B6W,EAAiBtZ,OACb0C,EACE4W,EAAiBtZ,OACjBmY,EAAavV,QACb9D,EACAyP,EAAWhP,WAEbkD,IAKiB,aAAzBiX,GAAgBzZ,OACfoZ,EAAerI,IAAI0I,IACpBhI,EAAewG,EAAiBwB,IAEhCL,EAAexP,IAAI6P,GACnB1B,EAAcpW,KAAK9B,EAAqB4Z,EAAe3Z,KACvD4Z,EAAqBD,EACrBA,EAAiBA,EAAevS,OAElC,GAAIuS,EACF,SAGFvB,EAAevJ,GAAqBuJ,EAAc,CAChDlM,OAAQ,OACRjM,OAAQ4Z,GACNzB,EACArZ,EACAyP,EACA4J,EAAanU,QAAQ+Q,KACrB4E,IAGN,CACF,CAEA,OAAOxB,CACT,CAhMgB0B,CACVvM,EACAxO,EACAyP,EACAkI,EACAyB,EACAF,EACAxB,EACAuB,GAGF,MAAM+B,EAAiB,IAAI5B,GAEF,SAArB5K,EAAUrB,SACZqB,EAAYuL,GACVvL,EACAxO,EACAyP,EACAuL,EACGzB,KAAK,CAACC,EAAGC,IAAMA,EAAEC,MAAQF,EAAEE,OAC3BzT,QAASiH,GAAUA,EAAM2G,MAC5BqF,OACAvV,IAKJ,IACE,OACE+T,IAAiBsB,EAAgBtB,cAlIzC,SACEuD,EACAC,GAEA,GAAID,EAAerY,SAAWsY,EAAiBhQ,KAC7C,OAAO,EAET,IAAK,MAAMmN,KAAQ4C,EACjB,IAAKC,EAAiBhJ,IAAImG,GACxB,OAAO,EAGX,OAAO,CACT,CAsHQ8C,CAA6BnC,EAAgBhT,OAAQoT,GAE9C,CAAC5K,EAAWuG,GAEd,CACLjF,GAAqBtB,EAAW,CAC9BxI,OAAQgV,EACRtD,iBAEF3C,EAEH,CAAC,MAAOqG,GAGP,MAAMA,CACR,CACF,CAAU,QACR3L,EAAWhD,eAAiB0M,CAC9B,CACF,CAEA,SAAS2B,GACPhV,EACA9F,EACAyP,EACAkD,EACAkI,GAEA,QAAwBlX,IAApBgP,EAASzR,OACX,OAEF,MAAMma,EAAiBra,EACrB6Z,EAAmB5Z,QACW0C,IAA9BkX,EAAmB3Z,QAAwB2Z,EAAmBxS,OAC1DzE,EACEiX,EAAmB3Z,OACnB4E,EAAShC,QACT9D,EACAyP,EAAWhP,WAEbkD,GAEN,OAAOC,EACL+O,EAASzR,OACT4E,EAAShC,QACTuX,EACA5L,EAAWhP,KAEf,CAmKA,SAAS2Z,GAIPhJ,EACAsG,EACAyC,EACAD,GAEA,GAAI/E,EAAc/D,GAChB,GAAIsG,EAAatG,EAAUnQ,IAAK,CAC9B,MAAMqa,EAAoB5D,EAAatG,EAAUnQ,IACjD,IAAK,MAAMgR,KAAKqJ,EACdpB,EAAcnP,IAAIkH,GAElBmI,GACEnI,EACAyF,EACAyC,EACAD,GAGJ,IAAK,MAAMjI,KAAKqJ,EACdC,GACEtJ,EACAb,EAAU/I,OACV6R,EACAxC,EACAyC,EAGN,KAAO,CACL,MAAMqB,EAA2BvG,EAG/B7D,GACF,IAAK,MAAMa,KAAKuJ,EAAyBpX,OACvC8V,EAAcnP,IAAIkH,GAEduJ,IAA6BpK,EAAU/I,QAAQ6M,SACjDiF,EAAsBpP,IAAIqG,EAAU/I,QAGtC+R,GACEnI,EACAyF,EACAyC,EACAD,GAIJ,IAAK,MAAMjI,KAAKuJ,EAAyBpX,OACvCmX,GACEtJ,EACAb,EAAU/I,OACV6R,EACAxC,EACAyC,EAGN,MAEA,GAAuB,aAAnB/I,EAAUjQ,KAAqB,CACjC,MAAOkU,GAAgBjE,EAAU8D,QAAQ9Q,OAEpC+Q,EAAcE,KACjB6E,EAAcnP,IAAIsK,GAClB8E,EAAsBpP,IAAIsK,IAE5B+E,GACE/E,EACAqC,EACAyC,EACAD,GAGFqB,GACElG,EACAjE,EACA8I,EACAxC,EACAyC,EAEJ,MACE,GAAuB,aAAnB/I,EAAUjQ,KACZ,IAAK,MAAM6K,KAASqF,EAAYD,GAAWG,OACxCrL,IAAQiP,EAAcjP,IAElB,IAAIgU,GAAepH,KAAMb,GAAM+E,GAAa/E,EAAGjG,MAC7CmJ,EAAcnJ,KACjBkO,EAAcnP,IAAIiB,GAClBmO,EAAsBpP,IAAIiB,IAE5BoO,GACEpO,EACA0L,EACAyC,EACAD,GAOd,CAEA,SAASG,GACPH,EACAxC,EACAyC,EACAzI,EACA+J,GAEA,IAAK,MAAMC,KAAOhK,EAIhB,GAHK+J,IAAoBzE,GAAa0E,EAAKD,IACzCvB,EAAcnP,IAAI2Q,GAEH,aAAbA,EAAIva,KACN,IAAK,MAAM6K,KAASqF,EAAYqK,GAAKnK,OAAQrL,IAAQiP,EAAcjP,IAC5D,IAAIgU,GAAepH,KAAMb,GAAM+E,GAAa/E,EAAGjG,MAClDkO,EAAcnP,IAAIiB,GAClBoO,GACEpO,EACA0L,EACAyC,EACAD,GAMZ,CAEA,SAASqB,GACPnK,EACAK,EACAyI,EACAxC,EACAyC,GAEAE,GACEH,EACAxC,EACAyC,EACA3I,EAAmBJ,EAAWK,GAElC,CA8EA,SAASkK,GAAUzW,EAA0B0W,GAC3C,OAAO1W,EAAQG,gBAAgB0P,QAAQ6G,EACzC,CAEA,SAASC,GACP7C,EACAhZ,EACAyP,EACAsF,EACA+G,EAIAC,GAEA,MAAM7W,QAAEA,GAAY8T,EACpB,IAAIgD,EAAuBhD,EAE3B,IAAK,MAAMtM,KAAUqI,EAAS,CAC5B,MAAMlE,EAA6B,mBAAXnE,EAClBuP,EAAiBpL,EACnBnE,EAKAiP,GAAUzW,EAA2B,iBAAXwH,EAAsBA,EAASA,EAAOvL,MAC9DkO,EAAa,CACjBvL,QAASkY,EAAqBlY,QAC9B9D,QACAS,KAAMgP,EAAWhP,KACjBwH,OAAQwH,EAAWxH,QAGfqH,EACJuB,GAA8B,iBAAXnE,OACf/I,EACA,WAAY+I,EACe,mBAAlBA,EAAOE,OACZF,EAAOE,OAAO,CAAE9I,QAASkY,EAAqBlY,QAAS9D,UACvD0M,EAAOE,YACTjJ,EAER,IAAKsY,KAAoB,YAAaA,GAAiB,CACrDxM,EAAWhD,eAAe,CACxBtL,KACoB,iBAAXuL,EACHA,EACkB,iBAAXA,EACLA,EAAOvL,KACPuL,EAAOwP,MAAQ,cACvBpP,KAAMuC,EACNzC,OAAQ0C,EACR3C,KAAMsP,IAER,QACF,CAEA,MAAME,EAAgBF,GAEfzN,EAAW5B,EAAQmI,GAAWoH,EAAchM,QACjDV,EACAuM,EACA3M,EACAC,EACA2M,EACAH,GAEFE,EAAuBxN,EAEnB,iBAAkB2N,GACpBJ,GAASjZ,KAAK,CAACqZ,EAAevP,IAG5B,YAAauP,GACf1M,EAAWhD,eAAe,CACxBtL,KAAMgb,EAAchb,KACpB2L,KAAMuC,EACNzC,SACAD,KAAMwP,EAAc/L,QAAQzL,KAAK,KAAM8K,EAAY7C,KAInDmI,IACFiH,EAAuBH,GACrBG,EACAhc,EACAyP,EACAsF,EACA+G,EACAC,GAGN,CAEA,OAAOC,CACT,CAEO,SAASjC,GACdf,EACAhZ,EACAyP,EACAsF,EACAmE,EACAkD,GAEA,MAAML,EACJK,EAAmB,QAAKzY,EACpB6K,EAAYqN,GAChB7C,EACAhZ,EACAyP,EACAsF,EACA,CAAEmE,gBAAekD,oBACjBL,GAKF,OAHAA,GAAS1Q,QAAQ,EAAE8Q,EAAevP,MAChCuP,EAAcE,aAAa5M,EAAYjB,EAAW5B,KAE7C4B,CACT,CAEO,SAAS8N,GACdxW,EACA9F,EACAyP,EACAyJ,GASA,IAAIG,EAAevT,EACnB,MAAMyW,EAA0B,GAEhC,SAASC,EACPC,EACAzc,EACA4Y,GAEAnJ,EAAWxH,OAAOgD,qBAAqB,CACrC9J,KAAM,oBACNkF,SAAUoJ,EAAWhP,KACrBT,QACA8F,SAAU2W,EAAK,GACfC,aAAc9D,IAEhB2D,EAAWzZ,KAAK2Z,EAClB,CAGA,GAAIzc,EAAMmB,OAASd,EAQjB,OAPAgZ,EAAevJ,GACb6M,GAAatD,EAAcrZ,EAAOyP,GAClC,CACEtC,OAAQ,YAGZqP,EAAa,CAACnD,EAAc,IAAKrZ,EAAO,IACjC,CACL8F,SAAUuT,EACVkD,cAIJ,IAAIK,EAAY5c,EAIhB,GAAI4c,EAAUzb,OAASf,EAAa,CAClC,MAAMyc,EAAeD,EACfE,EPx+CH,SACL9c,GAEA,OAAOA,EAAMmB,KAAK4b,WAAW,qBAC/B,COo+CkBC,CAAkBH,GAE1BjE,EAAcqE,GAAkBJ,EAAcxD,GAEpD,GAAIyD,IAAUlE,EAAYhW,OASxB,OALAyW,EAAevJ,GAAsChK,EAAU,CAC7DqH,OAAQ,QACRvI,MAAOiY,EAAajY,QAEtB4X,EAAa,CAACnD,EAAc,IAAKwD,EAAc,IACxC,CACL/W,SAAUuT,EACVkD,cAGJ,MAAME,EAAO1D,GACXH,EACA9S,EACA2J,EACAmN,GACA,EACA1D,GAEFG,EAAeoD,EAAK,GACpBD,EAAaC,EAAMI,EAAcjE,EACnC,CAEA,IAAIsE,GAAmC,EAEvC,KAA+B,WAAxB7D,EAAalM,QAAqB,CACvC,IAAIsK,EACFyF,EACIC,GAA2B9D,EAAcuD,GACzC,GAIN,MAAMQ,EAAgB3F,EAAmB7U,OAASyW,OAAe1V,EAEjE,IAAK8T,EAAmB7U,OAAQ,CAC9B,IAAKsW,EAActW,OACjB,MAEFga,EAAY1D,EAAczL,QAC1BgK,EAAqBwF,GAAkBL,EAAWvD,EACpD,CAEA,MAAMoD,EAAO1D,GACXtB,EACA4B,EACA5J,EACAmN,GACA,EACA1D,GAEFG,EAAeoD,EAAK,GACpBS,EAAmC7D,IAAiB+D,EACpDZ,EAAaC,EAAMG,EAAWnF,EAChC,CAMA,MAJ4B,WAAxB4B,EAAalM,QACfwP,GAAatD,EAAcuD,EAAWnN,GAGjC,CACL3J,SAAUuT,EACVkD,aAEJ,CAEA,SAASI,GACPnO,EACAxO,EACAyP,GAEA,OAAOsK,GACLvL,EACAxO,EACAyP,EACAvN,OAAOqK,OAAOiC,EAAU/F,UAAUvE,IAAK8H,GAAeD,EAAUC,IAChE,QACArI,EAEJ,CAEA,SAASsZ,GACPjd,EACAwO,GAEA,OAAOA,EAAUtJ,QAAQmY,kBAAkB7O,EAAkBxO,EAC/D,CAEA,SAASmd,GACP3O,EACAxO,GAEA,MAAMsd,EAAqD,IAAIvX,IACzDwX,EAAe/O,EAAUxI,OAAOuL,OAAOJ,GAE7C,IAAK,MAAMC,KAAamM,EACtBC,EAAM,IAAK,MAAMvL,IAAK,CAACb,GAAW8E,OAChC1E,EAAmBJ,OAAWzN,IAE9B,GAAKsO,EAAEwL,OAGP,IAAK,MAAM/O,KAAcuD,EAAEwL,OACzB,QACuB9Z,IAArB+K,EAAWkC,OACXD,EAAcjC,EAAWkC,MAAOpC,EAAU1K,QAAS9D,EAAOwO,GAC1D,CACA8O,EAAqBvS,IAAI2D,GACzB,MAAM8O,CACR,CAKN,OAAOhG,GACLzT,MAAMmU,KAAKoF,GACX,IAAIvX,IAAIyI,EAAUxI,QAClBwI,EAAUkJ,aAEd,CEvwDO,SAAS1U,GAAkB9C,GAChC,QACIA,GACe,iBAAVA,GACP,YAAaA,GACb,UAAWA,CAEf,CAoPA,MAAMwd,GAAyB,SAE7BC,GAEA,OAAO/b,EAAa+b,EAAWpe,KAAKW,MACtC,EAEM0d,GAAwB,SAE5BC,GAEA,OAAOte,KAAKue,KAAK5L,IAAI2L,EACvB,EAEME,GAAqB,SAEzB/d,GAQA,MAAMge,EAAiBze,KAAK2F,QAAQmY,kBAAkB9d,KAAMS,GAE5D,QACIge,GAAgBpb,QAElBob,EAAelL,KAAMkC,QAAmBrR,IAAbqR,EAAE5Q,QAAwB4Q,EAAED,QAAQnS,OAEnE,EAEMqb,GAAwB,WAC5B,MACEjY,OAAQkY,EAAKJ,KACbA,EAAI5Y,QACJA,EAAOiZ,QACPA,EAAOpP,OACPA,EAAMqP,IACNA,EAAGC,OACHA,EAAMC,QACNA,KACGC,GACDhf,KACJ,MAAO,IAAKgf,EAAYT,KAAM/Z,MAAMmU,KAAK4F,GAC3C,EAEMU,GAAyB,WAC7B,OAAOjf,KAAKyG,OAAOmQ,OACjB,CAACsI,EAAKrN,UACmBzN,IAAnByN,EAAUsN,OACZD,EAAIrN,EAAUnQ,IAAMmQ,EAAUsN,MAEzBD,GAET,CACF,EACF,EAEO,SAASE,GASdhZ,EACAT,GAWA,MAAO,CACLiI,OAAQxH,EAAOwH,OACfjM,OAAQyE,EAAOzE,OACf0D,MAAOe,EAAOf,MACdM,UACApB,QAAS6B,EAAO7B,QAChBkC,OAAQL,EAAOK,OACf9F,MAAOwS,EAAcxN,EAAQ+Q,KAAMtQ,EAAOK,QAC1C8X,KAAM,IAAI/X,IAAIJ,EAAOK,OAAOC,QAASC,GAAOA,EAAG4X,OAC/CrV,SAAU9C,EAAO8C,SACjBiP,aAAc/R,EAAO+R,cAAgB,CAAE,EACvC4G,QAASZ,GACTW,OAAQT,GACRQ,IAAKL,GACLI,QAASK,GACTzP,OAAQkP,GAEZ,CAEO,SAASnO,GACdhK,EACAH,EAAyC,IAEzC,OAAOgZ,GACL,IAAK7Y,KAAaH,GAClBG,EAASZ,QAEb,CAEA,SAAS0Z,GAGPlH,GACA,GAA4B,iBAAjBA,GAA8C,OAAjBA,EACtC,MAAO,GAET,MAAMjV,EAAgC,CAAA,EAEtC,IAAK,MAAMJ,KAAOqV,EAAc,CAC9B,MAAMxX,EAAQwX,EAAarV,GACvB0B,MAAMvB,QAAQtC,KAChBuC,EAAOJ,GAAOnC,EAAMgE,IAAKqT,IAAU,CAAEtW,GAAIsW,EAAKtW,MAElD,CAEA,OAAOwB,CACT,CAoEA,SAASoc,GAAeC,GACtB,IAAIC,EACJ,IAAK,MAAM1c,KAAOyc,EAAa,CAC7B,MAAM5e,EAAQ4e,EAAYzc,GAC1B,GAAInC,GAA0B,iBAAVA,EAClB,GAAI,cAAeA,GAAS,SAAUA,GAAS,QAASA,EACtD6e,IAAShb,MAAMvB,QAAQsc,GAClBA,EAAYxV,QACb,IAAKwV,GACTC,EAAK1c,GAAO,CACV2M,aP/bkB,EOgclB/N,GAAKf,EAA6Be,QAE/B,CACL,MAAMwB,EAASoc,GAAe3e,GAC1BuC,IAAWvC,IACb6e,IAAShb,MAAMvB,QAAQsc,GAClBA,EAAYxV,QACb,IAAKwV,GACTC,EAAK1c,GAAOI,EAEhB,CAEJ,CACA,OAAOsc,GAAQD,CACjB,CC5aO,SAASE,GACdvP,GACAvK,QAAEA,EAAOpB,QAAEA,GACX9D,EACAif,GA4CA,MAAQ,CAAC9Z,EAAKiC,KACZ,MAAMf,EA3CqB6Y,EAAC/Z,EAAKiC,KACjC,GAAmB,iBAARjC,EAAkB,CAC3B,MAAMgC,EAAQlC,EAAuBC,EAASC,GAE9C,IAAKgC,EACH,MAAM,IAAIyD,MACR,gBAAgBzF,kCAAoCD,EAAQjE,OAIhE,MAAMoF,EAAW6I,EAAY/H,EAAO,CAClClG,GAAImG,GAASnG,GACboH,OAAQoH,EAAWhP,KACnB6H,aAAclB,GAASkB,aACvBjH,MAC4B,mBAAnB+F,GAAS/F,MACZ+F,EAAQ/F,MAAM,CACZyC,UACA9D,QACAS,KAAMgP,EAAWhP,OAEnB2G,GAAS/F,MACf8D,MACA6C,SAAUZ,GAASY,WAKrB,OAFAiX,EAAgB5Y,EAASpF,IAAMoF,EAExBA,CACT,CAUE,OATiB6I,EAAY/J,EAAK,CAChClE,GAAImG,GAASnG,GACboH,OAAQoH,EAAWhP,KACnB6H,aAAclB,GAASkB,aACvBjH,MAAO+F,GAAS/F,MAChB8D,MACA6C,SAAUZ,GAASY,YAONkX,CAAM/Z,EAAKiC,GAQ5B,OAPA6X,EAAgB5Y,EAASpF,IAAMoF,EAC/BoJ,EAAW3D,MAAM,KACXzF,EAASqB,oBAAsBjB,EAAiB0H,SAGpD9H,EAAS1G,UAEJ0G,EAEX,CC/GA,SAAS8Y,GACP1P,EACA3J,EACAuJ,EACAC,GACA8P,WACEA,IAOF,IAAKtZ,EAAShC,QACZ,MAAM,IAAI8G,MACR,iGAGJ,MAAMqU,EAA+C,CAAA,EAE/CI,EAA6C,CACjDvb,QAASgC,EAAShC,QAClB9D,MAAOqP,EAAWrP,MAClBkf,MAAOF,GACLvP,EACA3J,EACAuJ,EAAWrP,MACXif,GAEFxe,KAAMgP,EAAWhP,KACjBwH,OAAQwH,EAAWxH,QAErB,IAAIqX,EAAyC,CAAA,EAC7C,GAA0B,mBAAfF,EACTE,EAAgBF,EAAWC,EAAY/P,QAEvC,IAAK,MAAMjN,KAAOH,OAAOC,KAAKid,GAAa,CACzC,MAAMG,EAAiBH,EAAW/c,GAClCid,EAAcjd,GACc,mBAAnBkd,EACHA,EAAeF,EAAY/P,GAC3BiQ,CACR,CAKF,MAAO,CACLzP,GAAqBhK,EAAU,CAC7BhC,QAJmB5B,OAAOsd,OAAO,CAAE,EAAE1Z,EAAShC,QAASwb,GAKvD7W,SAAUvG,OAAOC,KAAK8c,GAAiBrc,OACnC,IACKkD,EAAS2C,YACTwW,GAELnZ,EAAS2C,gBAEf9E,OACAA,EAEJ,CA+CO,SAAS6b,GAOdJ,GA0BA,SAASI,EACPvP,EACAC,GAKF,CAOA,OALAsP,EAAOre,KAAO,gBACdqe,EAAOJ,WAAaA,EAEpBI,EAAOrP,QAAUgP,GAEVK,CACT,CHtKA,SAAS7L,GACPvE,EACAtJ,EACAwK,EACAhB,GAEEtP,MAAOyT,EAAWxS,GAClBA,EAAEiI,MACFA,IAuBFgQ,cAAEA,IAEF,MAAMuG,EAAY3Z,EAASZ,QAAQG,gBAAgBqa,OAEnD,GAA2B,iBAAhBjM,EACT,MAAM,IAAI7I,MAER,iEAAiE6I,iBAGrE,MAAMkM,EACmB,mBAAhBlM,EACHA,EAAYnD,EAAMhB,GAClBmE,EAEN,IAAIO,EACJ,GAAqB,iBAAV9K,EAAoB,CAC7B,MAAM0W,EAAcH,GAAaA,EAAUvW,GAC3C8K,EACyB,mBAAhB4L,EACHA,EAAYtP,EAAMhB,GAClBsQ,CACR,MACE5L,EACmB,mBAAV9K,EAAuBA,EAAMoH,EAAMhB,GAAgBpG,EAK9D,MAH6B,iBAAlB8K,GACTkF,EAAcpW,KAAK6c,GAEd,CACL7Z,EACA,CACE9F,MAAO2f,EACP1e,KACAiI,MAAO8K,QAETrQ,EAEJ,CAEA,SAASiQ,GACPnE,EACA7C,GAMA,MAAM5M,MAAEA,EAAKkJ,MAAEA,EAAKjI,GAAEA,GAAO2L,EACR,iBAAV1D,GACTuG,EAAW3D,MAAM,KACf,MAAMrL,EAAOgP,EAAWhP,KACxBgP,EAAWxH,OAAOc,UAAUC,SAASvI,EAAMA,EAAMT,EAAOkJ,EAAOjI,IAIrE,CI5EA,MAAM4e,ICyJJC,QDzJkDnc,ECmK3C,CACLgC,OArBF+I,GD/IiCU,MCqK/BV,WAAYA,CAAC5I,EAAU9F,EAAOyP,KACrB,IACF3J,EACHhC,QAAS4K,GAAW5I,EAAShC,QAAS9D,EAAOyP,KAGjDnC,mBAAoBA,CAAC8B,EAAG/N,KACf,CACL8L,OAAQ,SACRjM,YAAQyC,EACRiB,WAAOjB,EACPG,QAC4B,mBAAnBgc,GACFA,GAAuB,CAAEze,UAC1Bye,KAGV7Q,qBAAuBnJ,GAAaA,EACpCuH,gBAAkBvH,GAAkBA,IA/CjC,IAOL4I,GAUAoR,GCvLF,MAAMC,GAAQ,IAAInX,QAEX,SAASoX,GAAQC,EAAa5d,EAAauE,GAChD,IAAIsZ,EAAeH,GAAMzV,IAAI2V,GAS7B,OAPKC,EAGQ7d,KAAO6d,IAClBA,EAAa7d,GAAOuE,MAHpBsZ,EAAe,CAAE7d,CAACA,GAAMuE,KACxBmZ,GAAM5V,IAAI8V,EAAQC,IAKbA,EAAa7d,EACtB,CC6BA,MAAM8d,GAAe,CAAA,EAEfC,GAAwB1T,GACN,iBAAXA,EACF,CAAEvL,KAAMuL,GAEK,mBAAXA,EACL,YAAaA,EACR,CAAEvL,KAAOuL,EAAyBvL,MAEpC,CACLA,KAAMuL,EAAOwP,MAGVxP,EAYF,MAAM2T,GAgFXhhB,WAAAA,CAESsG,EAYPyB,GAoCA,GAnCA7H,KAbOoG,OAAAA,EA9ETpG,KAIO8C,SAAG,EACV9C,KACO0B,QAAE,EACT1B,KASO4B,UAAI,EACX5B,KACO+gB,UAAI,EACX/gB,KACO+R,YAAM,EACb/R,KAMOua,aAAO,EACdva,KACOiU,WAAK,EACZjU,KACOsU,UAAI,EACXtU,KACO8I,YAAM,EACb9I,KACO2F,aAAO,EAgBd3F,KAIOmf,UAAI,EACXnf,KAIO2B,YAAM,EAIb3B,KAIOma,OAAiB,EAACna,KAElBghB,iBAAW,EAAAhhB,KAEXue,KAAiB,GAAEve,KACnBqZ,iBAAW,EAAArZ,KACXke,YAAM,EAkBXle,KAAK8I,OAASjB,EAAQQ,QACtBrI,KAAK8C,IAAM+E,EAAQoZ,KACnBjhB,KAAK2F,QAAUkC,EAAQqZ,SACvBlhB,KAAK+gB,KAAO/gB,KAAK8I,OAAS9I,KAAK8I,OAAOiY,KAAKpK,OAAO3W,KAAK8C,KAAO,GAC9D9C,KAAK0B,GACH1B,KAAKoG,OAAO1E,IAAM,CAAC1B,KAAK2F,QAAQjE,MAAO1B,KAAK+gB,MAAMI,KpBzKzB,KoB0K3BnhB,KAAK4B,KACH5B,KAAKoG,OAAOxE,OACX5B,KAAKoG,OAAO2L,QAAUpP,OAAOC,KAAK5C,KAAKoG,OAAO2L,QAAQ1O,OACnD,WACArD,KAAKoG,OAAOmU,QACV,UACA,UACRva,KAAKghB,YAAchhB,KAAKoG,OAAO4a,YAE/BhhB,KAAKma,MAAQna,KAAK2F,QAAQyb,MAAMzV,KAChC3L,KAAK2F,QAAQyb,MAAMxW,IAAI5K,KAAK0B,GAAI1B,MAEhCA,KAAK+R,OACH/R,KAAKoG,OAAO2L,OACRjO,EACE9D,KAAKoG,OAAO2L,OACZ,CAACsP,EAAiCve,IACd,IAAIge,GAAUO,EAAa,CAC3ChZ,QAASrI,KACTihB,KAAMne,EACNoe,SAAUlhB,KAAK2F,WAKrBib,GAGY,aAAd5gB,KAAK4B,OAAwB5B,KAAKoG,OAAOuP,QAC3C,MAAM,IAAItK,MACR,wDACErL,KAAK0B,+BAELiB,OAAOC,KAAK5C,KAAK+R,QAAQ,8BAM/B/R,KAAKua,SACqB,IAAxBva,KAAKoG,OAAOmU,QAAmB,UAAYva,KAAKoG,OAAOmU,UAAW,EAEpEva,KAAKiU,MAAQ9P,EAAQnE,KAAKoG,OAAO6N,OAAOlK,QACxC/J,KAAKsU,KAAOnQ,EAAQnE,KAAKoG,OAAOkO,MAAMvK,QAEtC/J,KAAKmf,KAAOnf,KAAKoG,OAAO+Y,KACxBnf,KAAK2B,OACW,UAAd3B,KAAK4B,MAAqB5B,KAAK8I,YAA8B1E,EAArBpE,KAAKoG,OAAOzE,OACtD3B,KAAKue,KAAOpa,EAAQiC,EAAOmY,MAAMxU,OACnC,CAGOuX,WAAAA,GACLthB,KAAKqZ,YRwFF,SAILxH,GAEA,MAAMwH,EAAc,IAAInR,IAIxB,GAAI2J,EAAUzL,OAAOyI,GACnB,IAAK,MAAMiG,KAAcnS,OAAOC,KAAKiP,EAAUzL,OAAOyI,IAAK,CACzD,GZjUoB,KYiUhBiG,EACF,MAAM,IAAIzJ,MACR,4FAGJ,MAAMkW,EAAoB1P,EAAUzL,OAAOyI,GAAGiG,GAC9CuE,EAAYzO,IACVkK,EACArQ,EAAwB8c,GAAmB5c,IAAK8Q,GAC9CZ,EAAiBhD,EAAWiD,EAAYW,IAG9C,CAEF,GAAI5D,EAAUzL,OAAOob,OAAQ,CAC3B,MAAM1M,EAAa,qBAAqBjD,EAAUnQ,KAClD2X,EAAYzO,IACVkK,EACArQ,EAAwBoN,EAAUzL,OAAOob,QAAQ7c,IAAK8Q,GACpDZ,EAAiBhD,EAAWiD,EAAYW,IAG9C,CACA,IAAK,MAAMyF,KAAarJ,EAAUxL,OAAQ,CACxC,GAAI6U,EAAUsG,OAAQ,CACpB,MAAM1M,EAAa,qBAAqBoG,EAAUxZ,KAClD2X,EAAYzO,IACVkK,EACArQ,EAAwByW,EAAUsG,QAAQ7c,IAAK8Q,GAC7CZ,EAAiBhD,EAAWiD,EAAYW,IAG9C,CACA,GAAIyF,EAAUuG,QAAS,CACrB,MAAM3M,EAAa,sBAAsBoG,EAAUxZ,KACnD2X,EAAYzO,IACVkK,EACArQ,EAAwByW,EAAUuG,SAAS9c,IAAK8Q,GAC9CZ,EAAiBhD,EAAWiD,EAAYW,IAG9C,CACA,GAAIyF,EAAUC,WAAY,CACxB,MAAMrG,EAAa,mBAAmBoG,EAAUxZ,KAChD2X,EAAYzO,IACVkK,EACArQ,EAAwByW,EAAUC,YAAYxW,IAAK8Q,GACjDZ,EAAiBhD,EAAWiD,EAAYW,IAG9C,CACF,CACA,IAAK,MAAMb,KAAqB/C,EAAU+B,MAAO,CAC/C,IAAIxI,EAAWiO,EAAYtO,IAAI6J,EAAkBZ,WAC5C5I,IACHA,EAAW,GACXiO,EAAYzO,IAAIgK,EAAkBZ,UAAW5I,IAE/CA,EAAS7H,KAAKqR,EAChB,CACA,OAAOyE,CACT,CQjKuBqI,CAAkB1hB,MACjCA,KAAKoG,OAAO8X,SACdle,KAAKke,OAASzZ,EAAwBzE,KAAKoG,OAAO8X,QAAQvZ,IAAK8Q,GAC7DZ,EAAiB7U,KpBhOC,GoBgOiByV,KAIvC9S,OAAOC,KAAK5C,KAAK+R,QAAQjG,QAAShJ,IAChC9C,KAAK+R,OAAOjP,GAAKwe,eAErB,CAGA,cAAWK,GACT,MAAO,CACLjgB,GAAI1B,KAAK0B,GACToB,IAAK9C,KAAK8C,IACV8e,QAAS5hB,KAAK2F,QAAQic,QACtBhgB,KAAM5B,KAAK4B,KACX+T,QAAS3V,KAAK2V,QACV,CACE9Q,OAAQ7E,KAAK2V,QAAQ9Q,OACrB6E,OAAQ1J,KACRwV,QAASxV,KAAK2V,QAAQH,QAAQ7Q,IAAIkc,IAClC7M,UAAW,KACXiB,SAAS,EACTzF,OAAQA,KAAO,CACb3K,OAAQ7E,KAAK2V,QAAQ9Q,OAAOF,IAAK8Q,GAAM,IAAIA,EAAE/T,MAC7CgI,OAAQ,IAAI1J,KAAK0B,KACjB8T,QAASxV,KAAK2V,QAAQH,QAAQ7Q,IAAIkc,IAClC7M,UAAW,aAGf5P,EACJmW,QAASva,KAAKua,QACdxI,OAAQjO,EAAU9D,KAAK+R,OAASpE,GACvBA,EAAMgU,YAEf9S,GAAI7O,KAAK6O,GACTwK,YAAa,IAAIrZ,KAAKqZ,YAAYrM,UAAU6U,OAAOld,IAAK8Q,IAAO,IAC1DA,EACHD,QAASC,EAAED,QAAQ7Q,IAAIkc,OAEzB5M,MAAOjU,KAAKiU,MAAMtP,IAAIkc,IACtBvM,KAAMtU,KAAKsU,KAAK3P,IAAIkc,IACpB1B,KAAMnf,KAAKmf,KACXhF,MAAOna,KAAKma,QAAU,EACtBxY,OAAQ3B,KAAK2B,OACb0E,OAAQrG,KAAKqG,OACb2a,YAAahhB,KAAKghB,YAClBzC,KAAMve,KAAKue,KAEf,CAGO/O,MAAAA,GACL,OAAOxP,KAAK2hB,UACd,CAGA,UAAWtb,GAYT,OAAOoa,GAAKzgB,KAAM,SAAU,IAC1BmE,EAAQnE,KAAKoG,OAAOC,QAAQ1B,IAAI,CAACuB,EAAc9C,KAC7C,MAAMwC,IAAEA,EAAG6C,SAAEA,GAAavC,EACpBmK,EAAanK,EAAaxE,IAAM6D,EAAevF,KAAK0B,GAAI0B,GACxD0e,EACW,iBAARlc,EACHA,EACA,iBAAiBL,EAAevF,KAAK0B,GAAI0B,KAE/C,MAAO,IACF8C,EACHN,IAAKkc,EACLpgB,GAAI2O,EACJ5H,SAAUA,EACV+G,MAAAA,GACE,MAAMgS,OAAEA,EAAMC,QAAEA,KAAYM,GAAoB7b,EAChD,MAAO,IACF6b,EACHngB,KAAM,gBACNgE,IAAKkc,EACLpgB,GAAI2O,EAER,KAaR,CAGA,MAAWxB,GACT,OAAO4R,GAAKzgB,KAAM,KAAM,IAGf,IAFaA,KAAKqZ,aAGtB3S,QAAQ,EAAEoO,EAAYW,KAAOA,EAAE9Q,IAAK8Q,GAAM,CAACX,EAAYW,KACvDmB,OACC,CAACjS,GAAWmQ,EAAY3F,MACtBxK,EAAImQ,GAAcnQ,EAAImQ,IAAe,GACrCnQ,EAAImQ,GAAYvR,KAAK4L,GACdxK,GAET,CACF,GAEN,CAEA,SAAWiP,GACT,OAAO6M,GACLzgB,KACA,qBACA,IAAM0T,EAAsB1T,MAEhC,CAEA,WAAW2V,GACT,OAAO8K,GAAKzgB,KAAM,UAAW,IR0E1B,SAIL6R,EACAmQ,GAKA,MAAM3M,EACe,iBAAZ2M,EACHnQ,EAAUE,OAAOiQ,GACjBA,EACEnQ,EAAUE,OAAOiQ,EAAQnd,aACzBT,EACR,IAAKiR,GAAkB2M,EACrB,MAAM,IAAI3W,MAER,uBAAuB2W,sCAA4CnQ,EAAUnQ,MAGjF,MAAMyN,EAA4D,CAChEzF,OAAQmI,EACR2D,QACGwM,GAA8B,iBAAZA,EAA4B7d,EAAQ6d,EAAQxM,SAArB,GAC5CxB,UAAW,KACXiB,SAAS,EACTpQ,OAAQwQ,EAAiB,CAACA,GAAkB,GAC5C7F,OAAQA,KAAO,IACVL,EACHzF,OAAQ,IAAImI,EAAUnQ,KACtBmD,OAAQwQ,EAAiB,CAAC,IAAIA,EAAe3T,MAAQ,MAIzD,OAAOyN,CACT,CQ9GM8S,CAAwBjiB,KAAMA,KAAKoG,OAAOuP,SAE9C,CAGOpV,IAAAA,CACLgG,EAUA9F,GAEA,MAAMuT,EAAYvT,EAAMmB,KAClB4T,EAA2B,GAEjC,IAAI0M,EAEJ,MAAMC,EAA4D1B,GAChEzgB,KACA,cAAcgU,IACd,KAAMoO,OR7KVC,EQ6K8BrO,GR9K9BnC,EQ8KwB7R,MR1KZqZ,YAAYtO,IAAIsX,IAC1B,IAAIxQ,EAAUwH,YAAYzW,QACvBoP,OAAQsQ,GP4ER,SACLtO,EACAc,GAEA,GAAIA,IAAed,EACjB,OAAO,EAGT,GL1SsB,MK0SlBc,EACF,OAAO,EAGT,IAAKA,EAAWyN,SAAS,MACvB,OAAO,EAST,MAAMC,EAAqB1N,EAAW2N,MAAM,KACtCC,EAAc1O,EAAUyO,MAAM,KAEpC,IACE,IAAIE,EAAa,EACjBA,EAAaH,EAAmBnf,OAChCsf,IACA,CACA,MAAMC,EAAoBJ,EAAmBG,GACvCE,EAAaH,EAAYC,GAE/B,GAA0B,MAAtBC,EASF,OARoBD,IAAeH,EAAmBnf,OAAS,EAWjE,GAAIuf,IAAsBC,EACxB,OAAO,CAEX,CAEA,OAAO,CACT,CO9HQC,CAAuBT,EAAmBC,IAE3CtI,KAAK,CAACC,EAAGC,IAAMA,EAAE7W,OAAS4W,EAAE5W,QAC5BqD,QAAS5D,GAAQ+O,EAAUwH,YAAYtO,IAAIjI,IAX3C,IACL+O,EACAwQ,IQgLE,IAAK,MAAMU,KAAaZ,EAAY,CAClC,MAAM9Q,MAAEA,GAAU0R,EACZC,EAAkBzc,EAAShC,QAEjC,IAAI0e,GAAc,EAElB,IACEA,GACG5R,GACDD,EACEC,EACA2R,EACAviB,EACA8F,EAEL,CAAC,MAAOvE,GACP,MAAMkhB,EACa,iBAAV7R,EACHA,EACiB,iBAAVA,EACLA,EAAMzP,UACNwC,EACR,MAAM,IAAIiH,MACR,4BACE6X,EAAY,IAAIA,MAAgB,8BACNlP,qBAC1BhU,KAAK0B,SACAM,EAAIsT,UAEf,CAEA,GAAI2N,EAAa,CACfzN,EAAQjS,QAAQwf,EAAUvN,SAC1B0M,EAAqBa,EACrB,KACF,CACF,CAEA,OAAOb,EAAqB,CAACA,QAAsB9d,CACrD,CAGA,UAAW+e,GACT,OAAO1C,GAAKzgB,KAAM,SAAU,KAC1B,MAAM+R,OAAEA,GAAW/R,KACbmjB,EAAS,IAAI3c,IAAIxG,KAAK4G,WAE5B,GAAImL,EACF,IAAK,MAAM/O,KAAWL,OAAOC,KAAKmP,GAAS,CACzC,MAAMpE,EAAQoE,EAAO/O,GACrB,GAAI2K,EAAMoE,OACR,IAAK,MAAMtR,KAASkN,EAAMwV,OACxBA,EAAO3X,IAAI,GAAG/K,IAGpB,CAGF,OAAO+D,MAAMmU,KAAKwK,IAEtB,CAOA,aAAWvc,GACT,MAAMhE,EAAOD,OAAOC,KAAKD,OAAOsI,YAAYjL,KAAKqZ,cAC3C8J,EAAS,IAAI3c,IACjB5D,EAAKoP,OAAQ8C,GACJ9U,KAAKqZ,YACTtO,IAAI+J,GACJvB,KACEpE,MAEIA,EAAWtK,SACXsK,EAAWqG,QAAQnS,SACnB8L,EAAW8F,YAMxB,OAAOzQ,MAAMmU,KAAKwK,EACpB,EClaK,MAAMC,GAqDXtjB,WAAAA,CAESsG,EAePN,GACA9F,KAhBOoG,OAAAA,EAtBTpG,KACO4hB,aAAO,EAAA5hB,KAEPqjB,aAAO,EAAArjB,KAEP8F,qBAAe,EAEtB9F,KACOsjB,cAAe,EAEtBtjB,KACOohB,MAAkD,IAAIlZ,IAAKlI,KAE3D0W,UAAI,EAAA1W,KAEJ0B,QAAE,EAAA1B,KAEF+R,YAAM,EAAA/R,KACNmjB,YAAM,EAqBXnjB,KAAK0B,GAAK0E,EAAO1E,IAAM,YACvB1B,KAAK8F,gBAAkB,CACrBC,OAAQD,GAAiBC,QAAU,CAAE,EACrCyP,QAAS1P,GAAiB0P,SAAW,CAAE,EACvC2K,OAAQra,GAAiBqa,QAAU,CAAE,EACrC3O,OAAQ1L,GAAiB0L,QAAU,CAAC,GAEtCxR,KAAK4hB,QAAU5hB,KAAKoG,OAAOwb,QAC3B5hB,KAAKqjB,QAAUrjB,KAAKoG,OAAOid,QAE3BrjB,KAAKmP,WAAanP,KAAKmP,WAAW/J,KAAKpF,MACvCA,KAAK+N,mBAAqB/N,KAAK+N,mBAAmB3I,KAAKpF,MACvDA,KAAK0P,qBAAuB1P,KAAK0P,qBAAqBtK,KAAKpF,MAC3DA,KAAK8N,gBAAkB9N,KAAK8N,gBAAgB1I,KAAKpF,MACjDA,KAAKI,MAAQJ,KAAKI,MAAMgF,KAAKpF,MAE7BA,KAAK0W,KAAO,IAAIoK,GAAU1a,EAAQ,CAChC6a,KAAMjhB,KAAK0B,GACXwf,SAAUlhB,OAGZA,KAAK0W,KAAK4K,cTiPP,SAAgCiC,GACrC,MAAMC,EAA8C,GAC9CC,EAAiB1R,IACrBpP,OAAOqK,OAAO+E,GAAQjG,QAASnF,IAC7B,GAAIA,EAAGP,OAAOsd,OAAS/c,EAAGP,OAAO1E,GAAI,CACnC,MAAMiiB,EAAUhd,EAAGP,OAAO1E,GACpBkiB,EAAYjd,EAAGP,OAAOsd,MAAMrS,MAC5BwS,EAAaA,CACjB9S,EACA1D,IAEI0D,EAAKtQ,MAAMqjB,KAAO,IAAIH,OAGrBC,GAGoB,mBAAdA,GACFA,EAAU7S,EAAM1D,IAIrB8B,EAAkC,IACnCxI,EAAGP,OAAOsd,MACbrS,MAAOwS,EACPhf,OAAQ,IAAI8e,KAGdH,EAAiBjgB,KACfsR,EAAiB0O,EAAe,eAAgBpU,GAEpD,CACIxI,EAAGoL,QACL0R,EAAc9c,EAAGoL,WAIvB0R,EAAcF,EAAcxR,QACxByR,EAAiBngB,OAAS,GAC5BkgB,EAAclK,YAAYzO,IAAI,eAAgB4Y,EAElD,CSzRIO,CAAuB/jB,KAAK0W,MAE5B1W,KAAK+R,OAAS/R,KAAK0W,KAAK3E,OACxB/R,KAAKmjB,OAASnjB,KAAK0W,KAAKyM,MAa1B,CASOa,OAAAA,CACLle,GA4BA,MAAM0P,QAAEA,EAAOhE,OAAEA,EAAMzL,OAAEA,EAAMoa,OAAEA,GAAWngB,KAAK8F,gBAEjD,OAAO,IAAIsd,GAAapjB,KAAKoG,OAAQ,CACnCoP,QAAS,IAAKA,KAAY1P,EAAgB0P,SAC1ChE,OAAQ,IAAKA,KAAW1L,EAAgB0L,QACxCzL,OAAQ,IAAKA,KAAWD,EAAgBC,QACxCoa,OAAQ,IAAKA,KAAWra,EAAgBqa,SAE5C,CAEO8D,YAAAA,CACL7d,GAoBA,MAAM8d,GT4kDR9Q,ES5kD+CpT,KAAK0W,KT6kDpDlT,ES7kD0D4C,EAAOzF,MTglD1DwS,EAAcC,EAAU,IADTf,EAAiBiE,GAAclD,EAAU5P,OAJ1D,IACL4P,EACA5P,ES5kDE,MAAM+O,EAAUF,EACdiE,GAActW,KAAK0W,KAAMwN,IAG3B,OAAO9E,GACL,CACE3Y,OAAQ,IAAI8L,GACZhO,QAAS6B,EAAO7B,SAAY,CAAe,EAC3C2E,SAAU,CAAE,EACZ0E,OAAQyF,EAAed,EAASvS,KAAK0W,MACjC,OACAtQ,EAAOwH,QAAU,SACrBjM,OAAQyE,EAAOzE,OACf0D,MAAOe,EAAOf,MACd8S,aAAc/R,EAAO+R,cAEvBnY,KAWJ,CASOmP,UAAAA,CACL5I,EAUA9F,EACAyP,GAWA,OAAO6M,GAAUxW,EAAU9F,EAAOyP,EAAY,IAC3C3J,QACL,CASOiT,SAAAA,CACLjT,EAUA9F,EACAyP,GAaA,OAAO6M,GAAUxW,EAAU9F,EAAOyP,EAAY,IAAI8M,WAAWrY,IAC3D,EAAE+N,KAAOA,EAEb,CAEOoL,iBAAAA,CACLvX,EAUA9F,GAEA,OAAOuW,GAAehX,KAAK0W,KAAMnQ,EAAS5F,MAAO4F,EAAU9F,IAAU,EACvE,CAQA0jB,mBAAAA,CACEjU,EACAnB,EACA4K,GAWA,MAAMpV,QAAEA,GAAYvE,KAAKoG,OAEnBge,EAAahF,GACjB,CACE7a,QACqB,mBAAZA,GAA0BA,EAAUA,EAAW,CAAe,EACvEkC,OAAQ,CAACzG,KAAK0W,MACdxN,SAAU,CAAE,EACZ0E,OAAQ,UAEV5N,MAGF,GAAuB,mBAAZuE,EAAwB,CAGjC,OAAOiW,GACL4J,EACArV,EACAmB,EACA,CAAC+P,GANgBJ,EAAGF,QAAOlf,QAAOS,UAClCqD,EAAQ,CAAEob,QAAO7d,MAAOrB,EAAMqB,MAAOZ,WAMrCyY,OACAvV,EAEJ,CAEA,OAAOggB,CACT,CAMOrW,kBAAAA,CACLmC,EAeApO,GAWA,MAAMiN,EAAYlN,EAAgBC,GAC5B6X,EAAkC,GAClC0K,EAAkBrkB,KAAKmkB,oBAC3BjU,EACAnB,EACA4K,IAEK1K,GTsiBJ,SACLyH,EACA2N,EACAnU,EACAnB,EACA4K,GAEA,OAAOH,GACL,CACE,CACE3U,OAAQ,IAAIgR,GAAqBa,IACjChN,OAAQgN,EACRzB,SAAS,EACTO,QAAS,GACTxB,UAAW,KACXxE,OAAQ,OAGZ6U,EACAnU,EACAnB,GACA,EACA4K,EAEJ,CS9jBwB2K,CAClBtkB,KAAK0W,KACL2N,EACAnU,EACAnB,EACA4K,IAGMpT,SAAUge,GAAexH,GAC/B9N,EACAF,EACAmB,EACAyJ,GAGF,OAAO4K,CACT,CAEOnkB,KAAAA,CACLmG,GAWA5D,OAAOqK,OAAOzG,EAAS2C,UAAyC4C,QAC7DW,IACoC,WAA/BA,EAAMR,cAAc2B,QACtBnB,EAAMrM,SAId,CAEO+F,gBAAAA,CAAiBnD,GACtB,MAAMwhB,EAAWzhB,EAAYC,GACvByhB,EAAeD,EAASza,MAAM,GAC9B2a,EAAkBlR,EAAUgR,EAAS,IACvCA,EAAS,GAAGza,MAAM4a,GAClBH,EAAS,GAEP3S,EAAY7R,KAAKohB,MAAMrW,IAAI2Z,GACjC,IAAK7S,EACH,MAAM,IAAIxG,MACR,sBAAsBqZ,iCAA+C1kB,KAAK0B,OAG9E,OAAO0T,GAAmBvD,EAAW4S,EACvC,CAEA,cAAW9C,GACT,OAAO3hB,KAAK0W,KAAKiL,UACnB,CAEOnS,MAAAA,GACL,OAAOxP,KAAK2hB,UACd,CAEOjS,oBAAAA,CACLnJ,EAUAsB,GAEA,OPhGG,SASLtB,EAUAsB,GAEA,MACEpB,OAAQkY,EAAKJ,KACbA,EAAI5Y,QACJA,EAAOuD,SACPA,EAAQ3E,QACRA,EAAOsa,IACPA,EAAGC,OACHA,EAAMC,QACNA,EAAOH,QACPA,EAAOpP,OACPA,KACGwP,GACDzY,EAEEqe,EAAwC,CAAA,EAE9C,IAAK,MAAMljB,KAAMwH,EAAU,CACzB,MAAMuD,EAAQvD,EAASxH,GAQvBkjB,EAAaljB,GAAmC,CAC9C6E,SAAUkG,EAAMiD,qBAAqB7H,GACrCjC,IAAK6G,EAAM7G,IACX6C,SAAUgE,EAAMhE,SAChBM,aAAc0D,EAAMnE,cAExB,CAWA,MATkB,IACb0W,EACHza,QAAS+a,GAAe/a,GACxB2E,SAAU0b,EACVzM,aAAckH,GACZL,EAAW7G,cAKjB,COgCWzI,CAAqBnJ,EAAUsB,EACxC,CAEOiG,eAAAA,CACLvH,EACAiC,GAyBA,MAAMU,EAAwC,CAAA,EACxC2b,EAQDte,EAAiB2C,SA0BtB,SAAS4b,EACPpO,EACAqO,GAEA,GAAIA,aAAsBjE,GACxB,OAAOiE,EAET,IACE,OAAOrO,EAAK/Q,QAAQQ,iBAAiB4e,EAAWrjB,GAClD,CAAE,MAIF,CACF,CAtCAiB,OAAOC,KAAKiiB,GAAkB/Y,QAASwC,IACrC,MAAM0W,EAAYH,EAAiBvW,GAC7B2W,EAAaD,EAAUze,SACvBX,EAAMof,EAAUpf,IAEhBgC,EACW,iBAARhC,EAAmBF,EAAuB1F,KAAM4F,GAAOA,EAEhE,IAAKgC,EACH,OAGF,MAAMd,EAAW6I,EAAY/H,EAAO,CAClClG,GAAI4M,EACJxF,OAAQN,EAAYtH,KACpB6H,aAAcic,EAAUjc,aACxBxC,SAAU0e,EACVrf,MACA6C,SAAUuc,EAAUvc,WAGtBS,EAASoF,GAAWxH,IA+CtB,MAAMoe,EA5BN,SACExO,EACAyB,GAKA,IAAKA,GAAwC,iBAAjBA,EAC1B,MAAO,GAET,MAAMgN,EAA0C,CAAA,EAChD,IAAK,MAAMriB,KAAOqV,EAAc,CAC9B,MAAMiN,EAAMjN,EAAarV,GAEzB,IAAK,MAAMkV,KAAQoN,EAAK,CACtB,MAAM7T,EAAWuT,EAA8BpO,EAAMsB,GAEhDzG,IAIL4T,EAAQriB,KAAS,GACjBqiB,EAAQriB,GAAKS,KAAKgO,GACpB,CACF,CACA,OAAO4T,CACT,CAE4BE,CAC1BrlB,KAAK0W,KACJnQ,EAAiB4R,cAGdmN,EAAmBlG,GACvB,IACM7Y,EACJ2C,WACAzC,OAAQjC,MAAMmU,KACZtG,EAAiBiE,GAActW,KAAK0W,KAAOnQ,EAAiB5F,SAE9DwX,aAAc+M,GAEhBllB,MAYIulB,EAAO,IAAI/e,IAyBjB,OAvBA,SAASgf,EACPjG,EACArW,GAEA,IAAIqc,EAAK5S,IAAI4M,GAAb,CAGAgG,EAAK/Z,IAAI+T,GACT,IAAK,MAAMzc,KAAOyc,EAAa,CAC7B,MAAM5e,EAAiB4e,EAAYzc,GAEnC,GAAInC,GAA0B,iBAAVA,EAAoB,CACtC,GAAI,iBAAkBA,GdxmBJ,IcwmBaA,EAAM8O,aAA+B,CAClE8P,EAAYzc,GAAOoG,EAAUvI,EAAce,IAC3C,QACF,CACA8jB,EAAc7kB,EAA6BuI,EAC7C,CACF,CAZA,CAaF,CAEAsc,CAAcF,EAAiB/gB,QAAS2E,GAEjCoc,CACT,ECxpBK,SAASG,GAAgB9kB,GAC9B,OAAO+kB,KAAKC,UAAUhlB,EACxB,CAkEO,SAASilB,GACdrf,GAEA,MAAMsf,EAAiBljB,OAAOC,KAAK2D,EAAShC,SAASlB,OAEjD,IAAIqiB,KAAKC,UAAUpf,EAAShC,YAD5B,GAGEuhB,EAAevf,EAASE,OAC3BuL,OAAQrL,GAAmB,WAAZA,EAAG/E,MAAiC,UAAZ+E,EAAG/E,MAC1C+C,IAAI,EAAGjD,KAAIqf,WACV,MAAM5B,EAAO5Y,EAASqY,UAAUld,GAChC,IAAKyd,EACH,MAAO,IAAI4B,EAAKI,KAAK,QAGvB,MAAMH,YAAEA,GAAgB7B,EAExB,MAA2B,mBAAhB6B,EACFA,EAAYza,GAGdya,EAAc,IAAIA,KAAiB0E,KAAKC,UAAUpf,EAAS5F,SAGtE,MACE,QAAgC,IAAxBmlB,EAAaziB,OAAe,GAAK,OACzCyiB,EAAa3E,KAAK,MAClB,IAAI0E,IAAgBE,MAExB,CCrGO,MCJMC,GACXA,IAKA,CAACpe,EAAOT,IACQ8e,GAAiBre,EAAOT,GAK7B+e,GACXA,IAKA,CAACte,EAAOT,IACQgf,GAAeve,EAAOT,GCrBlCif,GAAiBzY,IACrB,GAAIA,EAAMtH,OAAOhD,OAAS,EACxB,MAAM,IAAIgI,MAAM,kDAElB,GAAIsC,EAAMiG,MAAMvQ,OAAS,EACvB,MAAM,IAAIgI,MAAM,mDAGlB,IACKsC,EAAMsG,SACNtG,EAAM2G,QACN,IAAI3G,EAAM0L,YAAYrM,UAAUtG,QAAS+O,GAC1CA,EAAE/O,QAAS+O,GAAMA,EAAED,WAErB1J,QAASqB,IAET,GACoB,mBAAXA,GACP,YAAaA,GACoB,iBAAzBA,EAAexD,MAEvB,MAAM,IAAI0B,MAAM,wDAIpB,IAAK,MAAMoB,KAAS9J,OAAOqK,OAAOW,EAAMoE,QACtCqU,GAAc3Z,IC2CX,MAAM4Z,GAOJC,iBAAAA,GACL,MAAO,CACLC,eAAiB5Y,GAAU8X,GAAgB9X,GAC3C6Y,eAAiB/lB,GAAUglB,GAAgBhlB,GAG3CgmB,oBAAqBA,CAAC9Y,EAAOlN,IAC3B,GAAGglB,GAAgB9X,MAAUlN,GAAOmB,OACtCuhB,OAAQ,GACRuD,aAAcA,CAAC7W,EAAGsG,IAA0B,MAAbA,EAC/B3O,OAAQ,CACNE,IAAKD,QAAQC,IAAItC,KAAKqC,SACtBpC,MAAOoC,QAAQpC,MAAMD,KAAKqC,UAGhC,CAEA3H,WAAAA,CACS6mB,EACP9e,GACA7H,KAFO2mB,UAAAA,EAAgD3mB,KApBlD6H,aAAO,EAAA7H,KACP4mB,6BAAuB,EAAA5mB,KAyFtB6mB,YACNnjB,IAYA,MAAMojB,EAAepjB,EAAUqjB,MAC5BpiB,IAAK+N,GAXR,SAAqBjS,GACnB,MAAMmB,KAAEA,KAASolB,GAAUvmB,EAM3B,MAAO,GAAGmB,IAJae,OAAOC,KAAKokB,GAAO3jB,OACtC,KAAKqiB,KAAKC,UAAUqB,MACpB,IAGN,CAGcC,CAAYvU,EAAEjS,QACzB0gB,KAAK,OACR,MAAO,IACFzd,EACHwjB,KAAO7Z,GACLrN,KAAKmnB,SAASzjB,EAAW2J,GAC3B2T,YAAavd,GAAkBC,EAAUiK,OACrC,WAAWiY,GACTliB,EAAUiK,OACVoY,WAAWe,IACbpB,KAAKC,UAAUjiB,EAAUiK,SA3F/B3N,KAAK6H,QAAU,IACV7H,KAAKsmB,uBACLze,EAEP,CAEOuf,QAAAA,CACLC,EACAxf,GAEA,MAAMyf,EAAsBzf,GAASyf,sBAAuB,EACtDC,EAAQF,EAAcrnB,KAAK2mB,UAAW3mB,KAAKwnB,gBAAgB3f,IACjE,OAAQyf,EAAsBC,EHvGFE,EAI9BF,EACAf,EAA4Cf,MAG5C,MAAMiC,EAGD,GAELH,EAAMzb,QAASiV,IACb2G,EAA0BnkB,KAAK,CAC7Bwd,OACA4G,cAAe5G,EAAKgG,MAAMpiB,IAAKuY,GAASsJ,EAAetJ,EAAKzc,YAKhEinB,EAA0B1N,KACxB,CAACC,EAAG2N,IAAMA,EAAE7G,KAAKgG,MAAM1jB,OAAS4W,EAAE8G,KAAKgG,MAAM1jB,QAG/C,MAAMwkB,EAAgE,GAGtEC,EAAU,IAAK,MAAMC,KAAyBL,EAA2B,CAEvEM,EAAe,IAAK,MAAMC,KAA8BJ,EAA6B,CAEnF,IAAK,MAAMzkB,KAAK2kB,EAAsBJ,cAUpC,GACEI,EAAsBJ,cAAcvkB,KACpC6kB,EAA2BN,cAAcvkB,GAIzC,SAAS4kB,EAMb,SAASF,CACX,CAIAD,EAA4BtkB,KAAKwkB,EACnC,CAEA,OAAOF,EAA4BljB,IAAKoc,GAASA,EAAKA,OGyCd0G,CAAiBF,IAAQ5iB,IAC7D3E,KAAK6mB,YAET,CAEOZ,gBAAAA,CACLpe,GAEA,OAAO7H,KAAKonB,SAASpB,KAA0Bne,EACjD,CAEOqgB,oBAAAA,CACLX,EACA1f,GAEA,MAAMsgB,EAA6C,GAEnD,IAAK,MAAMpH,KAAQwG,EAAO,CACxB,MAAMa,EAAgBpoB,KAAKimB,iBAAiB,IACvCpe,EACHwgB,UAAWtH,EAAKpT,QAElB,IAAK,MAAM2a,KAAgBF,EACzBD,EAAY5kB,KAAKvD,KAAK6mB,YAAY0B,GAAUxH,EAAMuH,IAEtD,CAEA,OAAOH,CACT,CAEOhC,cAAAA,CACLte,GAEA,OAAO7H,KAAKonB,SAASlB,KAAwBre,EAC/C,CAEO2gB,kBAAAA,CACLjB,EACA1f,GAEA,MAAMsgB,EAA6C,GAEnD,IAAK,MAAMpH,KAAQwG,EAAO,CACxB,MAAMa,EAAgBpoB,KAAKmmB,eAAe,IACrCte,EACHwgB,UAAWtH,EAAKpT,QAElB,IAAK,MAAM2a,KAAgBF,EACzBD,EAAY5kB,KAAKvD,KAAK6mB,YAAY0B,GAAUxH,EAAMuH,IAEtD,CAEA,OAAOH,CACT,CA8BOM,kBAAAA,CACLtF,EACAtb,GAIA,OAFc4gB,GAAmBzoB,KAAK2mB,UAAWxD,EAAQtb,GAE5ClD,IAAI3E,KAAK6mB,YACxB,CAMO6B,eAAAA,GAEL,OADeA,GAAgB1oB,KAAK2mB,UAAW3mB,KAAK6H,QAEtD,CAEA,cAAasf,CACXpG,EACA1T,EACAxF,GAEA,MAAM8gB,EAAiC,CACrC5B,MAAO,GACPpZ,MAAO,CACLtI,MAAO,OAIX,IACE,IAAK,MAAM6X,KAAQ6D,EAAKgG,MAAO,CAC7B,MAAM6B,EAAiC,CACrC1L,OACAvP,MAAO,CAAEtI,MAAO,MAChB5E,MAAO,CAAE4E,MAAO,OAGlBsjB,EAAe5B,MAAMxjB,KAAKqlB,GAE1B,UACQ5oB,KAAK6oB,eAAexb,EAAQ6P,EACnC,CAAC,MAAOlb,GAGP,MAFA4mB,EAAenoB,MAAM4E,MAAQrD,EAEvBA,CACR,CAEA,UACQhC,KAAK8oB,UAAUzb,EAAQ6P,EAAKvP,MAAO9F,EAC1C,CAAC,MAAO7F,GAGP,MAFA4mB,EAAejb,MAAMtI,MAAQrD,EAEvBA,CACR,CACF,CACD,CAAC,MAAOA,GAGP,MADAA,EAAIsT,SJ5OH,SACLyL,EACA4H,EACA9gB,GAEA,MAAMgB,EAA2C,CAC/CkgB,YAAaA,CAACC,EAAQC,IAAWA,EACjC1C,eAAgBd,GAChBe,eAAgBf,MACb5d,IAGCkhB,YAAEA,EAAWxC,eAAEA,EAAcC,eAAEA,GAAmB3d,GAElD8E,MAAEA,GAAUoT,EAEZmI,EAAoB3C,EACxB5Y,EACAoT,EAAKgG,MAAM1jB,OAAS0d,EAAKgG,MAAMhG,EAAKgG,MAAM1jB,OAAS,GAAG5C,WAAQ2D,GAGhE,IAAI+kB,EAAa,GACbC,GAAY,EAuChB,OAtCAD,GACE,YACAR,EAAe5B,MACZpiB,IAAI,CAAC+N,EAAGtP,EAAG2jB,KACV,MAAMsC,EAAc9C,EAClB7T,EAAEwK,KAAKvP,MACPvK,EAAI,EAAI2jB,EAAM3jB,EAAI,GAAG8Z,KAAKzc,WAAQ2D,GAE9BklB,EAAc9C,EAAe9T,EAAEwK,KAAKzc,OAiB1C,MAAO,CAfa,YAClB2oB,EACIL,EAAY,OAAQM,GACpB3W,EAAE/E,MAAMtI,OACJ+jB,GAAY,EAAOL,EAAY,YAAaM,IAC9CN,EAAY,cAAeM,KAEf,YAClBD,EACIL,EAAY,OAAQO,GACpB5W,EAAEjS,MAAM4E,OACJ+jB,GAAY,EAAOL,EAAY,MAAOO,IACxCP,EAAY,QAASO,MAGKnI,KAAK,QAExCxK,OACC,YACEyS,EACIL,EAAY,OAAQG,GACpBP,EAAehb,MAAMtI,MACnB0jB,EAAY,MAAOG,GACnBH,EAAY,QAASG,MAG9B/H,KAAK,QAEHgI,CACT,CI8KqBI,CAAqBxI,EAAM4H,EAAgB3oB,KAAK6H,SACzD7F,CACR,CAEA,OAAO2mB,CACT,CAEA,eAAaG,CACXzb,EACAM,EACA9F,GAEA,MAAMgB,EAAkB7I,KAAKwnB,gBAAgB3f,GAEvC2hB,EAAgBxpB,KAAKypB,kBACzBpc,EACAM,EACA9E,GAGF,IAAK,MAAM6gB,KAAgBF,QACnBnc,EAAO0E,SAAS2X,GAAc/b,GAExC,CAEQ8b,iBAAAA,CACNpc,EACAM,EACA9E,GAEA,MAAMkJ,EAAS1E,EAAO0E,QAAU,GAC1ByX,EAAgB7mB,OAAOC,KAAKmP,GAAQC,OAAQmE,GACzCtN,EAAgB6d,aAAa/Y,EAAOwI,IAQ7C,OAJKqT,EAAcnmB,QAAU,MAAO0O,GAClCyX,EAAcjmB,KAAK,KAGdimB,CACT,CAEQG,aAAAA,CACNtc,EACA6P,GAEA,MAAM0M,EACJvc,EAAO8V,SAAUjG,EAAKzc,MAAcmB,MAEtC,OAAOgoB,CACT,CAEA,oBAAaf,CACXxb,EACA6P,GAEA,MAAM0M,EAAY5pB,KAAK2pB,cAActc,EAAQ6P,SACtC0M,IAAiD1M,GAC1D,CAEQsK,eAAAA,CACN3f,GAEA,MAAO,IAAK7H,KAAK4mB,2BAA4B5mB,KAAK6H,WAAYA,EAChE,EAGF,SAASgiB,GACP5P,EACAC,GAEA,GAAID,IAAMC,EACR,OAAO,EAGT,QAAU9V,IAAN6V,QAAyB7V,IAAN8V,EACrB,OAAO,EAGT,GAAiB,iBAAND,GAA+B,iBAANC,EAClC,OAAOD,IAAMC,EAGf,MAAM4P,EAAQnnB,OAAOC,KAAKqX,GACpB8P,EAAQpnB,OAAOC,KAAKsX,GAE1B,OACE4P,EAAMzmB,SAAW0mB,EAAM1mB,QACvBymB,EAAMjnB,MAAOC,GAAQ+mB,GAAiB5P,EAAEnX,GAAMoX,EAAEpX,IAEpD,CAEA,SAASknB,GACPzjB,EAUA9F,EACAwpB,GAYAzD,eAAEA,IAIF,IACG/lB,GACAwpB,GACCJ,GAAiBI,EAAiBtpB,MAAO4F,EAAS5F,OAEpD,MAAO,GAGT,MAAMupB,EAAkBD,EACpB,SAASxE,GAAgBwE,EAAiBtpB,SAC1C,GAEJ,MAAO,QAAQ6lB,EAAe/lB,KAASypB,GACzC,CChYO,SAASC,KACd,MAAMC,EVkCCza,EAAY2Q,IUjCnB,MAAO,CACLpf,KAAMkpB,EACN5iB,OAAQC,QAAQC,IAChBhG,GAAI,GACJqF,UAAW6C,KAAKC,SAASC,SAAS,IAAIC,MAAM,GAC5CwC,MAAOA,OACP7D,OAAQ0hB,EAAW1hB,OACnB8D,UAAWA,OACXG,KAAMA,OACNO,eAAgBA,OAEpB,CC2BA,SAAS4E,GAAYD,GACnB,IAAKA,EAAUE,OACb,MAAO,GAOT,OAJiBpP,OAAOC,KAAKiP,EAAUE,QAAQpN,IAAK7B,GAC3C+O,EAAUE,OAAOjP,GAI5B,CAEO,SAASunB,GAAkB9jB,GAChC,MAAM5F,MAAEA,EAAK4D,QAAEA,GAAYgC,EAC3B,OAAOmf,KAAKC,UAAU,CACpBhlB,QACA4D,QAAS5B,OAAOC,KAAK2B,GAAW,CAAA,GAAIlB,OAASkB,OAAUH,GAE3D,CAEA,SAASoiB,GACP/lB,GAEA,OAAOilB,KAAKC,UAAUllB,EACxB,CAEO,SAAS6pB,GACd3kB,EACAkC,GAUA,MAAQsb,OAAQoH,KAAcC,GAAiB3iB,GAAW,CAAA,EA0B1D,MArBI,CACF0e,eAAgB8D,GAChB7D,kBACArD,OAASxV,IACP,MAAMwV,EACiB,mBAAdoH,EAA2BA,EAAU5c,GAAU4c,GAAa,GACrE,OAAOE,EAAmC9c,GAAOjH,QAAS9E,IACxD,MAAM8oB,EAAiBvH,EAAOnR,OAAQ2Y,GAAQA,EAAW/oB,OAASA,GAClE,OAAI8oB,EAAernB,OACVqnB,EAEF,CAAC,CAAE9oB,YAGdymB,UAAW1iB,EAAQoI,mBACjBoc,KACAtiB,GAAS/F,UAER0oB,EAIP,CAEO,SAASI,KACd,MAAO,CACLrE,eAAiB5Y,GAAU+X,KAAKC,UAAUhY,GAC1C6Y,kBAEJ,CAoDO,SAASqE,GACdjjB,EACAkjB,EAKA3jB,GAMA,MAAM4jB,EACJ5jB,IAlBJ,SAAwBS,GACtB,MAAO,qBAAsBA,CAC/B,CAiBKojB,CAAepjB,GACX0iB,GACC1iB,EACAkjB,QAMF1mB,GAsBN,MAdI,CACFmiB,eAPAuE,GAAkBvE,gBAClBwE,GAAwBxE,iBACtB5Y,GAAU+X,KAAKC,UAAUhY,IAM3B6Y,kBACArD,OAAQ,GACR8H,MAAOC,IACP7C,eAAWjkB,EACX+mB,aAAS/mB,EAGTgnB,SAAUN,GAAkBK,WACzBJ,KACAD,EAIP,CAEO,SAASvC,GAId8C,EACAC,GAIA,GAFyBA,EAASvE,MAAM,GAAGpZ,QAElB0d,EAAS1d,MAChC,MAAM,IAAItC,MAAM,0BAGlB,MAAO,CACLsC,MAAO2d,EAAS3d,MAEhBoZ,MAAOsE,EAAStE,MAAMpQ,OAAO2U,EAASvE,MAAMhd,MAAM,IAClDwhB,OAAQF,EAASE,OAASD,EAASC,OAEvC,CCzNO,SAAS7C,GAMd9gB,EACAC,GAEA,MAAMsH,WAAEA,GAAevH,GACjB4e,eACJA,EAAcD,eACdA,EACApD,OAAQoH,EAASU,MACjBA,EACA5C,UAAWmD,EAAeJ,SAC1BA,GACEP,GAAwBjjB,EAAOC,GAC7BqI,EAAaia,KAYbsB,EAAuC,CAAA,EAE7C,IAAIC,EAAa,EACjB,MAAMC,EAID,CAAC,CAAE1c,UAbNuc,GACA5jB,EAAMmG,mBACJmC,EAEArI,EAAQ/F,OASkBrB,WAAO2D,EAAWwnB,eAAWxnB,IACrDynB,EAAW,IAAI3jB,IAErB,KAAOyjB,EAAMtoB,QAAQ,CACnB,MAAQ4L,UAAWtB,EAAKlN,MAAEA,EAAKmrB,UAAEA,GAAcD,EAAMzd,QAErD,GAAIwd,IAAeT,EACjB,MAAM,IAAI5f,MAAM,4BAGlB,MAAMygB,EAAkBvF,EACtB5Y,EACAlN,EACAmrB,GAEF,GAAIH,EAAIK,GACN,SASF,GAPAD,EAASjhB,IAAIkhB,EAAiBne,GAE9B8d,EAAIK,GAAmB,CACrBne,QACA0L,YAAa,CAAC,GAGZ+R,GAAYA,EAASzd,GACvB,SAGF,MAAMwV,EACiB,mBAAdoH,EAA2BA,EAAU5c,GAAS4c,EAEvD,IAAK,MAAMlN,KAAa8F,EAAQ,CAC9B,MAAMrJ,EAAe3K,EAAWxB,EAAO0P,EAAWnN,GAElDub,EAAIK,GAAiBzS,YACnBmN,EAAenJ,IACb,CACF5c,MAAO4c,EACP1P,MAAOmM,GAET6R,EAAMpoB,KAAK,CACT0L,UAAW6K,EACXrZ,MAAO4c,EACPuO,UAAWje,GAEf,CACF,CAEA,OAAO8d,CACT,CCrGO,SAASM,GAAyChL,GACvD,IAAIgG,EAAoB,GAExB,GAAKhG,EAAKgG,MAAM1jB,OAOT,CACL,IAAK,IAAID,EAAI,EAAGA,EAAI2d,EAAKgG,MAAM1jB,OAAQD,IAAK,CAC1C,MAAM8Z,EAAO6D,EAAKgG,MAAM3jB,GAExB2jB,EAAMxjB,KAAK,CACToK,MAAOuP,EAAKvP,MACZlN,MAAa,IAAN2C,EAAU,CAAExB,KAAM,eAAkBmf,EAAKgG,MAAM3jB,EAAI,GAAG3C,OAEjE,CACAsmB,EAAMxjB,KAAK,CACToK,MAAOoT,EAAKpT,MACZlN,MAAOsgB,EAAKgG,MAAMhG,EAAKgG,MAAM1jB,OAAS,GAAG5C,OAE7C,MAnBEsmB,EAAQ,CACN,CACEpZ,MAAOoT,EAAKpT,MACZlN,MAAO,CAAEmB,KAAM,iBAiBrB,MAAO,IACFmf,EACHgG,QAEJ,CCHO,SAAS0B,GAMd7gB,EACAub,EACAtb,GAEA,MAAMgB,EAAkBgiB,GACtBjjB,EACA,CACEub,YACGtb,IAlBUlH,EAoBJiH,IAnBK,iBAAkBjH,EAoB9B2pB,GAA4B1iB,GAC5BgjB,MAtBR,IAAmBjqB,EA4BjB,MAAMuP,EAAaia,KAKb9B,EACJxf,EAAgBwf,WAChBzgB,EAAMmG,mBACJmC,EAEArI,GAAS/F,QAGPykB,eAAEA,EAAcC,eAAEA,GAAmB3d,EAErCmjB,EAAYtD,GAAgB9gB,EAAOiB,GAEnCgjB,EAAW,IAAI3jB,IACf6e,EAAkC,GAElCkF,EAAsB1F,EAC1B8B,OACAjkB,OACAA,GAEFynB,EAASjhB,IAAIqhB,EAAqB5D,GAElC,IAAI6D,EAAcD,EACdte,EAAQ0a,EACZ,IAAK,MAAM5nB,KAAS0iB,EAAQ,CAC1B4D,EAAMxjB,KAAK,CACToK,MAAOke,EAAS9gB,IAAImhB,GACpBzrB,UAGF,MAAM0rB,EAAc3F,EAAe/lB,IAC3BkN,MAAOsB,EAAWxO,MAAO2rB,GAC/BJ,EAAUE,GAAa7S,YAAY8S,GAErC,IAAKld,EACH,MAAM,IAAI5D,MACR,2BAA2B6gB,UAAoBC,KAGnD,MACME,EAAkB9F,EACtBtX,EACAxO,EAHgBorB,EAAS9gB,IAAImhB,IAM/BL,EAASjhB,IAAIyhB,EAAiBpd,GAE9Bid,EAAcG,EACd1e,EAAQsB,CACV,CAIA,OAAIpG,EAAgBsiB,UAAYtiB,EAAgBsiB,QAAQxd,GAC/C,GAGF,CACLoe,GAAU,CACRpe,QACAoZ,QACAwE,OAAQxE,EAAM1jB,SAGpB,CC5GO,SAAS4iB,GACdre,EACAC,GASA,MAAMgB,EAAkBgiB,GAAwBjjB,EAAOC,GACjD0e,EAAiB1d,EAAgB0d,eAGjC8B,EACJxf,EAAgBwf,WAChBzgB,EAAMmG,mBAAmBoc,KAAwBtiB,GAAS/F,OACtDkqB,EAAYtD,GAAgB9gB,EAAOiB,GAGnCyjB,EAAY,IAAIpkB,IAQhB2jB,EAAW,IAAI3jB,IACf+jB,EAAsB1F,EAAe8B,OAAWjkB,OAAWA,GACjEynB,EAASjhB,IAAIqhB,EAAqB5D,GAElCiE,EAAU1hB,IAAIqhB,EAAqB,CACjCV,OAAQ,EACR5d,WAAOvJ,EACP3D,WAAO2D,IAET,MAAMmoB,EAAY,IAAI/lB,IAChBgmB,EAAU,IAAIhmB,IAEpB+lB,EAAU/gB,IAAIygB,GACd,IAAK,MAAMH,KAAmBS,EAAW,CACvC,MAAMX,EAAYC,EAAS9gB,IAAI+gB,IACzBP,OAAEA,GAAWe,EAAUvhB,IAAI+gB,GACjC,IAAK,MAAMrrB,KAASkC,OAAOC,KACzBopB,EAAUF,GAAiBzS,aACL,CACtB,MAAQ1L,MAAOsB,EAAWxO,MAAOgsB,GAC/BT,EAAUF,GAAiBzS,YAAY5Y,GACnCisB,EAAsBnG,EAC1BtX,EACAwd,EACAb,GAGF,GADAC,EAASjhB,IAAI8hB,EAAqBzd,GAC7Bqd,EAAU3Z,IAAI+Z,GAMZ,CACL,MAAQnB,OAAQoB,GAAeL,EAAUvhB,IAAI2hB,GACzCC,EAAapB,EAAS,GACxBe,EAAU1hB,IAAI8hB,EAAqB,CACjCnB,OAAQA,EAAS,EACjB5d,MAAOme,EACPrrB,MAAOgsB,GAGb,MAdEH,EAAU1hB,IAAI8hB,EAAqB,CACjCnB,OAAQA,EAAS,EACjB5d,MAAOme,EACPrrB,MAAOgsB,IAYND,EAAQ7Z,IAAI+Z,IACfH,EAAU/gB,IAAIkhB,EAElB,CACAF,EAAQhhB,IAAIsgB,GACZS,EAAUzhB,OAAOghB,EACnB,CAEA,MAAMc,EAAqD,CAAA,EACrDrF,EAAkD,GA8BxD,OA5BA+E,EAAUxgB,QACR,EAAGyf,SAAQ5d,MAAO0a,EAAW5nB,MAAOosB,GAAaX,KAC/C,MAAMve,EAAQke,EAAS9gB,IAAImhB,GACrBnF,EAASsB,EAEXuE,EAAavE,GAAWd,MAAM,GAAGR,MAAMpQ,OAAO,CAC5ChJ,MAAOke,EAAS9gB,IAAIsd,GACpB5nB,MAAOosB,IAHT,GAMJtF,EAAMhkB,KAAK,CACToK,QACAoZ,QACAwE,WAEFqB,EAAaV,GAAe,CAC1Bve,QACA4Z,MAAO,CACL,CACE5Z,QACAoZ,QACAwE,cAON1iB,EAAgBsiB,QACX5D,EACJvV,OAAQ+O,GAASlY,EAAgBsiB,QAASpK,EAAKpT,QAC/ChJ,IAAIonB,IAGFxE,EAAM5iB,IAAIonB,GACnB,CCrHO,SAAS5F,GACdve,EACAC,GASA,MAAMgB,EAAkBgiB,GAAwBjjB,EAAOC,GACjDqI,EAAaia,KACb9B,EACJxf,EAAgBwf,WAChBzgB,EAAMmG,mBAAmBmC,EAAYrI,GAAS/F,OAC1CykB,EAAiB1d,EAAgB0d,eAGjCyF,EAAYtD,GAAgB9gB,EAAOiB,GACnCgjB,EAAW,IAAI3jB,IACf4kB,EAA2C,CAC/CC,SAAU,IAAIvmB,IACdwmB,MAAO,IAAIxmB,KAEPugB,EAA+B,GAC/BkG,EAGF,CAAA,EAEJ,SAASC,EACPC,EACAC,GAEA,MAAM/E,EAAYwD,EAAS9gB,IAAIoiB,GAG/B,GAFAL,EAASC,SAASvhB,IAAI2hB,GAElBA,IAAoBC,EAAe,CAChCH,EAAQG,KACXH,EAAQG,GAAiB,CACvBzf,MAAOke,EAAS9gB,IAAIqiB,GACpB7F,MAAO,KAIX,MAAM8F,EAAcJ,EAAQG,GAEtBE,EAAmC,CACvC3f,MAAO0a,EACPkD,OAAQxE,EAAM1jB,OACd0jB,MAAO,IAAIA,IAGbsG,EAAY9F,MAAMhkB,KAAK+pB,EACzB,MACE,IAAK,MAAMC,KAAmB5qB,OAAOC,KACnCopB,EAAUmB,GAAiB9T,aACL,CACtB,MAAQ1L,MAAOsB,EAAWxO,MAAO+sB,GAC/BxB,EAAUmB,GAAiB9T,YAAYkU,GAEzC,KAAMA,KAAmBvB,EAAUmB,GAAiB9T,aAClD,SAEF,MAAMuS,EAAYC,EAAS9gB,IAAIoiB,GAEzBd,EAAkB9F,EAAetX,EAAWue,EAAU5B,GAC5DC,EAASjhB,IAAIyhB,EAAiBpd,GAEzB6d,EAASC,SAASpa,IAAI0Z,KACzBS,EAASE,MAAMxhB,IAAI+hB,GACnBxG,EAAMxjB,KAAK,CACToK,MAAOke,EAAS9gB,IAAIoiB,GACpB1sB,MAAO+sB,IAETN,EAAKb,EAAiBe,GAE1B,CAGFrG,EAAM0G,MACNX,EAASC,SAASjiB,OAAOqiB,EAC3B,CAEA,MAAMA,EAAkB5G,EAAe8B,OAAWjkB,GAClDynB,EAASjhB,IAAIuiB,EAAiB9E,GAE9B,IAAK,MAAMgE,KAAmB1pB,OAAOC,KACnCopB,GAEAkB,EAAKC,EAAiBd,GAGxB,MAAMqB,EAAc/qB,OAAOqK,OAAOigB,GAASvmB,QAASinB,GAAMA,EAAEpG,OAE5D,OAAI1e,EAAgBsiB,QACXuC,EACJ1b,OAAQ+O,GAASlY,EAAgBsiB,QAASpK,EAAKpT,QAC/ChJ,IAAIonB,IAGF2B,EAAY/oB,IAAIonB,GACzB,sCJXO,SACL6B,GAMA,MAAMpb,EAID,GAEL,IAAK,MAAMqb,KAAYlrB,OAAOqK,OAAO4gB,GACnC,IAAK,MAAMze,KAAcxM,OAAOqK,OAC7B6gB,EAA+CxU,aAEhD7G,EAAQjP,KAAK,CACXoK,MAAQkgB,EAA+ClgB,MACvDlN,MAAO0O,EAAW1O,MAClBwO,UAAWE,EAAWxB,QAK5B,OAAO6E,CACT,0EHyRO,SACL7M,EACAkC,GD/X8BlC,KAC9BygB,GAAczgB,EAAQ+Q,OCsYtBoX,CAAgBnoB,GAEhB,MAAM6gB,EAAkB3e,GAAS2e,gBAAkBf,GAG7CgB,EACJ5e,GAAS4e,qBAAuBuD,IAC1B7G,OAAQoH,KAAcC,GAAiB3iB,GAAW,CAAA,EAwC1D,OAtCkB,IAAIwe,GAIpB1gB,EAAgB,CAChB4gB,eAAgBA,CAAC5Y,EAAOlN,EAAOmrB,IAEtB,GAAGvB,GAAkB1c,KAAS8Y,EACnC9Y,EACAlN,EACAmrB,EACA,CACEpF,qBAINE,aAAcA,CAAC/Y,EAAO7K,IACbA,EAAI0a,WAAW,KACjB7P,EAAclH,OAAOsnB,SAASpoB,EAAQQ,iBAAiBrD,IACvD6K,EAAcoR,QAAQjc,GAE7BqgB,OAASxV,IACP,MAAMwV,EACiB,mBAAdoH,EAA2BA,EAAU5c,GAAU4c,GAAa,GAErE,OAAOE,EAAmC9c,GAAOjH,QAC9CsN,GACKmP,EAAO5P,KAAMsI,GAAOA,EAAkBja,OAASoS,GAC1CmP,EAAOnR,OAAQ6J,GAAOA,EAAkBja,OAASoS,GAGnD,CAAC,CAAEpS,KAAMoS,SAInBwW,GAIP,yGE5bO,SAASlU,EACdzE,GAEA,MAAME,OAAEA,GAAWF,EASnB,OARclP,OAAOC,KAAKmP,GAAQ6E,OAAO,CAACoX,EAAU7X,KAClD,MAAMjD,EAAiBnB,EAAOoE,GACxBlD,EAAkBqD,EAAcpD,GAGtC,OADA8a,EAASzqB,KAAK2P,KAAmBD,GAC1B+a,GACN,GAGL,0DA4EO,SAASC,EACdC,GAEA,MAAMrc,EACJqc,aAAwB9K,GAAe8K,EAAaxX,KAAOwX,EAEvDlB,EAA6B,IAAInb,EAAUwH,YAAYrM,UAC1D6U,OACAnb,QAAQ,CAAC+O,EAAG0Y,KACK1Y,EAAE5Q,OAAS4Q,EAAE5Q,OAAS,CAACgN,IAExBlN,IAAI,CAACE,EAAQupB,KAC1B,MAAMC,EAA0B,CAC9B3sB,GAAI,GAAGmQ,EAAUnQ,MAAMysB,KAAmBC,IAC1C1kB,OAAQmI,EACRhN,OAAQA,EACRsK,WAAYsG,EACZ6Y,MAAO,CACLC,KAAM9Y,EAAEzB,UACRxE,OAAQA,KAAO,CAAE+e,KAAM9Y,EAAEzB,aAE3BxE,OAAQA,KACN,MAAM8e,MAAEA,GAAUD,EAElB,MAAO,CAAE3kB,OAAQmI,EAAUnQ,GAAImD,OAAQA,EAAOnD,GAAI4sB,WAItD,OAAOD,KAIPG,EAAQ,CACZ9sB,GAAImQ,EAAUnQ,GACdmQ,UAAWA,EACX3I,SAAU4I,GAAYD,GAAWlN,IAAIspB,GACrCjB,QACAxd,OAAQA,KACN,MAAM9N,GAAEA,EAAEwH,SAAEA,EAAU8jB,MAAOyB,GAAeD,EAC5C,MAAO,CAAE9sB,KAAIwH,WAAU8jB,MAAOyB,KAIlC,OAAOD,CACT"}